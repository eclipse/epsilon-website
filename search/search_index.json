{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Eclipse Epsilon","text":"<p>Epsilon is a family of scripting languages and tools for automating common model-based software engineering tasks such as code generation, model-to-model transformation, model validation and model visualisation, that work out of the box with EMF (including Xtext and Sirius), UML (including Cameo/MagicDraw), Simulink, XML and other types of models.</p> <p>Epsilon can be used as a standard Java library, and also provides Apache Ant tasks that can be embedded in Maven/Gradle builds. Editing support for Epsilon programs is available in Eclipse, VS Code and Sublime.</p> <p>Online Playground</p> <p>If you prefer not to download/install anything just quite yet, you can fiddle with EMF models and metamodels, and with some of the Epsilon languages in the online Epsilon Playground.</p>"},{"location":"#installation","title":"Installation","text":"<p>Download the Eclipse Installer and select Epsilon, as shown below. Note that you will need a Java Runtime Environment installed on your system. More options for downloading Epsilon (update sites, Maven) are available here.</p> <p></p>"},{"location":"#why-epsilon","title":"Why Epsilon?","text":"<ul> <li>One syntax to rule them all: All languages in Epsilon build on top of a common expression language which means that you can reuse code across your model-to-model transformations, code generators, validation constraints etc.</li> <li>Integrated development tools:  All languages in Epsilon are supported by editors providing syntax and error highlighting, code templates, and graphical tools for configuring, running, debugging and profiling Epsilon programs. </li> <li>Documentation, Documentation, Documentation: More than 80 articles, 15 screencasts and 40 examples are available to help you get from novice to expert.</li> <li>Strong support for EMF: Epsilon supports all flavours of EMF, including reflective, generated and non-XMI (textual) models such as these specified using Xtext or EMFText-based DSLs.</li> <li>No EMF? No problem: While Epsilon provides strong support for EMF, it is not bound to EMF at all. In fact, support for EMF is implemented as a driver for the model connectivity layer of Epsilon. Other drivers provide support for XML, CSV, Simulink and you can even roll out your own driver!</li> <li>No Eclipse? No problem either: While Epsilon provides strong support for Eclipse, we also provide standalone JARs through Maven Central that you can use to embed Epsilon in your plain Java or Android application.</li> <li>Mix and match: Epsilon poses no constraints on the number/type of models you can use in the same program. For example, you can write a transformation that transforms an XML-based and an EMF-based model into a Simulink model and also modifies the source EMF model.</li> <li>Plumbing included: You can use the ANT Epsilon tasks to compose Epsilon programs into complex workflows. Programs executed in the same workflow can share models and even pass parameters to each other.</li> <li>Extensible: Almost every aspect of Epsilon is extensible. You can add support for your own type of models, extend the Eclipse-based development tools, add a new method to the String type, or even implement your own model management language on top of EOL.</li> <li>Java is your friend: You can call methods of Java classes from all Epsilon programs to reuse code you have already written or to perform tasks that Epsilon languages do not support natively.</li> <li>Parallel execution: Since 2.0, Epsilon is multi-threaded, which includes first-order operations and some of the rule-based languages, making it faster than other interpreted tools.</li> <li>All questions answered: The Epsilon forum contains more than 9,500 posts and we're proud that no question has ever gone unanswered.</li> <li>We're working on it: Epsilon has been an Eclipse project since 2006 and it's not going away any time soon.</li> </ul>"},{"location":"#license","title":"License","text":"<p>Epsilon is licensed under the Eclipse Public License 2.0.</p>"},{"location":"#trademarks","title":"Trademarks","text":"<p>Eclipse Epsilon and the Eclipse Epsilon project logo are trademarks of the Eclipse Foundation. Eclipse and the Eclipse logo are registered trademarks of the Eclipse Foundation.</p> <p>Java and all Java-based trademarks are trademarks of Oracle Corporation in the United States, other countries, or both.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>We would like to thank ej-technologies for providing us with free licenses of their powerful JProfiler Java profiler.</p>"},{"location":"examples/","title":"Examples","text":"<p>Looking for in-depth articles?</p> <p>This page contains links to a selection of example projects in Epsilon's Git repository. If you are looking for more in-depth articles describing different features of Epsilon, please visit the articles section of the website.</p> <p>Online Playground</p> <p>If you prefer not to download/install anything just quite yet, you can fiddle with EMF models and metamodels, and with some of the Epsilon languages in the online Epsilon Playground.</p> <p>Each example in this page comes in the form of an Eclipse project, which is stored under the examples dirctory of Epsilon's Git repository. To run an example, you need to:</p> <ol> <li>Clone the repository</li> <li>Import the project in question into your Eclipse workspace</li> <li>Register any Ecore metamodels in it</li> <li>Right click the <code>.launch</code> file in it</li> <li>Select <code>Run as...</code> and click the first item in the menu that pops up</li> </ol> <p>Warning</p> <p>To avoid copying the same metamodels across different example projects, some projects reuse Ecore metamodels stored in the org.eclipse.epsilon.examples.metamodels project.</p> <p>If you are unable to run any of the examples below, please give us a shout.</p>"},{"location":"examples/#epsilon-object-language","title":"Epsilon Object Language","text":"<ul> <li>Create an OO model with EOL: In this example we use EOL to programmatically construct a model that conforms to an object-oriented metamodel.</li> <li>Modify a Tree model with EOL: In this example we use EOL to programmatically modify a model that conforms to a Tree metamodel and store the modified version as a new model.</li> <li>Call Java code from Epsilon: In this example, we create a JFrame from EOL. The aim of this example is to show how to call Java code from within Epsilon languages.</li> <li>Creating custom Java tools for Epsilon: In this example, we create a custom tool for Epsilon.</li> <li>Building and querying plain XML documents with EOL: In this example, we use the plain XML driver of Epsilon to build and query an XML document that is not backed by a XSD/DTD.</li> <li>Cloning and copying XML elements across documents with EOL: In this example, we use the plain XML driver of Epsilon to clone and copy XML elements across different documents with EOL.</li> <li>Cloning EMF model elements with EOL: In this example, we demonstrate how the EmfTool built-in tool can be used to perform deep-copy (cloning) of EMF model elements using EOL.</li> <li>Profiling and caching in EOL: This example demonstrates the caching capabilities and the profiling tools provided by Epsilon.</li> <li>Manage XSD-backed XML files with EOL: In this example we demonstrate using EOL to query an XSD-backed XML file.</li> <li>Manage Matlab Simulink/Stateflow blocks from Epsilon: In this example we show how to manage Matlab Simulink/Stateflow blocks with EOL.</li> </ul>"},{"location":"examples/#epsilon-transformation-language","title":"Epsilon Transformation Language","text":"<ul> <li>Transform a Tree model to a Graph model with ETL: In this example, we use ETL to transform a model that conforms to a Tree metamodel to a model that conforms to a Graph metamodel.</li> <li>Transform an RSS feed to an Atom feed using ETL: In this example, we use ETL and the plain XML driver to transform an RSS feed to an Atom feed.</li> <li>Experiment with the different types of transformation rule in ETL using a Flowchart-to-HTML transformation.: In this example, we show the different types of transformation rule that are provided by ETL, including plain, abstract, lazy, primary and greedy rules. We also explore rule inheritance and rules that generate more than model element. We transform from a Flowchart model to an HTML model.</li> <li>Transform an OO model to a DB model with ETL: In this example, we use ETL to transform a model that conforms to an Object-Oriented metamodel to a model that conforms to the Database metamodel.</li> </ul>"},{"location":"examples/#epsilon-generation-language","title":"Epsilon Generation Language","text":"<ul> <li>Experiment with the different features of EGL using a Flowchart-to-HTML transformation.: In this example, we explore the main features of EGL by generating HTML text from an EMF model of a flowchart. We demonstrate the EGX coordination language, code formatters, preserving hand-written text with protected regions and generating a fine-grained trace model.</li> <li>Generating HTML pages from an XML document: In this example, we use the plain XML driver of Epsilon in the context of an EGL model-to-text transformation.</li> <li>Generate HTML documentation from an Ecore metamodel with EGL: In this example, we demonstrate how EGL can be used to generate HTML documentation from an Ecore metamodel.</li> </ul>"},{"location":"examples/#epsilon-validation-language","title":"Epsilon Validation Language","text":"<ul> <li>Validate an OO model with EVL: In this example, we use EVL, to express constraints for models that conform to an Object-Oriented metamodel.</li> <li>Validate an OO model against a DB model with EVL: In this example, we use EVL to expressing inter-model constraints.</li> <li>Dijkstra's shortest path algorithm with EOL/EVL: In this example, we use EOL and EVL to implement Dijkstra's shortest path algorithm.</li> </ul>"},{"location":"examples/#epsilon-merging-language","title":"Epsilon Merging Language","text":"<ul> <li>Heterogeneous Model Merging with ECL/EML: In this example, we demonstrate merging heterogeneous models using ECL and EML.</li> </ul>"},{"location":"examples/#epsilon-flock","title":"Epsilon Flock","text":"<ul> <li>Migrate Petri net models with Epsilon Flock: In this example we demonstrate how to migrate a model in response to metamodel changes with Epsilon Flock.</li> </ul>"},{"location":"examples/#epsilon-model-generation-language","title":"Epsilon Model Generation Language","text":"<ul> <li>Generate PetriNet models using EMG: In this example we demonstrate how to generate PetriNet elements and how to define relations between them.</li> </ul>"},{"location":"examples/#epsilon-pattern-language","title":"Epsilon Pattern Language","text":"<ul> <li>Find pattern matches in railway models using EPL: In this example we demonstrate how to find matches of the patterns in the Train Benchmark models with EPL.</li> </ul>"},{"location":"examples/#combining-the-epsilon-languages","title":"Combining the Epsilon Languages","text":"<ul> <li>Use Epsilon in standalone Java applications: In this example, we demonstrate how Epsilon languages can be used in standalone, non-Eclipse-based Java applications.</li> <li>MDD-TIF complete case study: In this example, we demonstrate how different languages in Epsilon (EVL, EGL, EML, ETL and ECL) can be combined to implement more complex operations.</li> <li>Compare, validate and merge OO models: In this example, we use ECL to compare two OO models, then use EVL to check the identified matches for consistency and finally EML to merge them.</li> <li>Construct a workflow to orchestrate several Epsilon programs with Ant: In this example we demonstrate how to use the built-in Epsilon Ant tasks to define a workflow by combining several Epsilon programs. Here, we validate, transform and generate HTML from a flowchart model.</li> <li>Provide custom/extended tasks for the workflow: In this example we demonstrate how you can define your own ANT tasks that extend the Epsilon workflow tasks.</li> <li>Use model transactions in a workflow: In this example we demonstrate using the ant-contrib try/catch tasks and the Epsilon model transactions tasks to conditionally rollback changes in models modified in a workflow.</li> </ul>"},{"location":"examples/#eugenia","title":"Eugenia","text":"<ul> <li>Implement a GMF editor with image nodes using Eugenia: In this example we use Eugenia to implement a GMF editor with images instead of shapes for nodes.</li> <li>Implement a GMF editor with end labels in connections using Eugenia: In this example we use Eugenia to implement a GMF editor with end labels in connections.</li> <li>Implement a flowchart GMF editor using Eugenia: In this example we use Eugenia to implement a flowchart GMF editor, and EOL to polish its appearance.</li> </ul>"},{"location":"examples/#eunit","title":"EUnit","text":"<ul> <li>Test EOL scripts with EUnit: In this example we show the basic structure of an EUnit test, some useful assertions for the basic types and how to test for errors and define our own assertions.</li> <li>Reuse EUnit tests with model and data bindings: In this example we show how the same EUnit test can be reused for several models, and how EUnit supports several levels of parametric tests.</li> <li>Test a model validation script with EUnit: In this example we show how a model validation script written in EVL can be tested with EUnit, using the exportAsModel attribute of the EVL workflow task.</li> <li>Test a model-to-text transformation with EUnit: In this example we show how a model-to-text transformation written in EGL can be tested with EUnit and HUTN.</li> <li>Integrate EUnit into a standard JUnit plug-in test: In this example we show how to write an EUnit/JUnit plug-in test of an ETL transformation.</li> </ul>"},{"location":"examples/#even-more-examples","title":"Even more examples","text":"<p>More examples are available in the examples folder of the Git repository.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>In this page we provide answers to common questions about Epsilon. If your question is not answered here, please feel free to ask in the forum.</p>"},{"location":"faq/#what-is-the-relationship-between-epsilon-and-emf","title":"What is the relationship between Epsilon and EMF?","text":"<p>Briefly, with EMF you can specify metamodels and construct models that conform to these metamodels, while with Epsilon you can process these EMF models and metamodels (e.g. validate them, transform them, generate code from them etc.).</p>"},{"location":"faq/#is-epsilon-a-model-transformation-language","title":"Is Epsilon a model transformation language?","text":"<p>No. Epsilon is a family of languages, one of which targets model-to-model transformation (ETL).</p>"},{"location":"faq/#who-is-using-epsilon","title":"Who is using Epsilon?","text":"<p>With more than 9,000 posts in the Epsilon forum, it appears that quite a few people are currently using different parts of Epsilon. A list of companies and open-source projects that use Epsilon is available here.</p>"},{"location":"faq/#how-do-i-get-help","title":"How do I get help?","text":"<p>Epsilon has a dedicated forum where you can ask questions about the tools and languages it provides. Whenever possible, please use the forum instead of direct email. We're monitoring the forum very closely and there is practically no difference in terms of response time. Also, answered questions in the forum form a knowledge base, which other users can consult in case they face similar issues in the future, and an active forum is an indication of a healthy and actively maintained project (properties that the Eclipse Foundation takes very seriously). When posting messages to the forum we recommend that you use your full (or at least a realistic) name instead of a nickname (e.g. \"ABC\", \"SomeGuy\") as the latter can lead to pretty awkward sentences.</p>"},{"location":"faq/#how-do-i-get-notified-when-a-new-version-of-epsilon-becomes-available","title":"How do I get notified when a new version of Epsilon becomes available?","text":"<p>To get notified when a new version of Epsilon becomes available you can configure Eclipse to check for updates automatically by going to <code>Window</code> \u2192 <code>Preferences</code> \u2192 <code>Install/Update/Automatic Updates</code> and checking the <code>Automatically find new updates and notify me</code> option.</p>"},{"location":"faq/#can-i-use-epsilon-in-a-non-eclipse-based-standalone-java-application","title":"Can I use Epsilon in a non-Eclipse-based standalone Java application?","text":"<p>Yes. There are several examples of doing just that in the examples/org.eclipse.epsilon.examples.standalone project in the Git repository. Just grab your JARs through Maven Central.</p>"},{"location":"faq/#how-does-epsilon-compare-to-the-omg-family-of-languages","title":"How does Epsilon compare to the OMG family of languages?","text":"<p>There are two main differences:</p> <p>First, QVT, OCL and MTL are standards while languages in Epsilon are not. While having standards is arguably a good thing, by not having to conform to standardized specifications, Epsilon provides the agility to explore interesting new features and extensions of model management languages, and contribute to advancing the state of the art in the field. Examples of such interesting and novel features in Epsilon include interactive transformation, tight Java integration, extended properties, and support for transactions.</p> <p>Second, Epsilon provides specialized languages for tasks that are currently not explicitly targeted by the OMG standards. Examples of such tasks include interactive in-place model transformation, model comparison, and model merging.</p>"},{"location":"faq/#what-is-the-difference-between-el-and-language-x","title":"What is the difference between E*L and language X?","text":"<p>If the available documentation doesn't provide enough information for figuring this out, please feel free to ask in the Epsilon forum.</p>"},{"location":"faq/#are-epsilon-languages-compiled-or-interpreted","title":"Are Epsilon languages compiled or interpreted?","text":"<p>All Epsilon languages are interpreted. With the exception of EGL templates which are transformed into EOL before execution, all other languages are supported by bespoke interpreters.</p>"},{"location":"faq/#how-can-i-contribute-to-epsilon","title":"How can I contribute to Epsilon?","text":"<p>There are several ways to contribute to Epsilon. In the first phase you can ask questions in the forum and help with maintaining the vibrant community around Epsilon. You may also want to let other developers know about Epsilon by sharing your experiences online. If you are interested in contributing code to Epsilon, you should start by submitting bug reports, feature requests - and hopefully patches that fix/implement them. This will demonstrate your commitment and long-term interest in the project - which is required by the Eclipse Foundation in order to later on be nominated for a committer account.</p>"},{"location":"faq/#where-is-the-metamodel-of-etlevl-etc","title":"Where is the metamodel of ETL/EVL etc.?","text":"<p>Epsilon languages do not have Ecore-based metamodels.</p>"},{"location":"faq/#how-do-i-enable-code-completionassistance-in-the-epsilon-editors","title":"How do I enable code-completion/assistance in the Epsilon editors?","text":"<p>Epsilon does not provide support for type-aware code completion as Epsilon languages are dynamically typed. However, <code>ctrl+space</code> provides a list of previously typed tokens to speed up typing.</p>"},{"location":"forum/","title":"Forum","text":"<p>To ask a question about Epsilon, please start a new Q&amp;A discussion in the project's discussions forum on GitHub.</p> <p>Please include a minimal example</p> <p>If your question is related to an issue you are encountering with one of your Epsilon programs, please include a minimal example that we can use to reproduce the issue locally.</p> <p>Epsilon also has a legacy Eclipse-hosted forum with more than 10K questions and answers, which you may want to search through before your post your question.</p>"},{"location":"getting-started/","title":"Getting Started with Epsilon","text":"<p>Epsilon provides a set of languages and tools for tasks such as model-to-text transformation, model-to-model transformation, model validation (all of which extend the same core language), model editing, weaving and visualisation. While some Epsilon tools are Eclipse IDE plugins, most of Epsilon does not depend on the Eclipse IDE and can be used from standard Java applications and from Maven/Gradle builds.</p> <p>New to Model-Based Software Engineering?</p> <p>If you are a newcomer to model-based software engineering and the Eclipse modelling ecosystem, you may find this series of lectures useful.</p>"},{"location":"getting-started/#trying-epsilon-in-the-playground","title":"Trying Epsilon in the Playground","text":"<p>You can try most Epsilon languages in the online Epsilon Playground, without needing to download or install anything.</p> <p></p>"},{"location":"getting-started/#using-epsilon-as-a-java-library","title":"Using Epsilon as a Java library","text":"<p>The execution engines of Epsilon's languages, the Flexmi parser, and drivers for EMF, UML, XML and Excel are available as standard Java libraries through Maven Central. To get started with parsing and executing Epsilon programs from your Java application:</p> <ul> <li>Go to the Epsilon Playground and select one of the examples;</li> <li>Click the <code>Download</code> button and select <code>Java (Maven)</code> or <code>Java (Gradle)</code> from the window that pops up to download a zipped copy of the example. The downloaded zip file includes an <code>Example</code> Java class as well as a <code>pom.xml</code>/<code>build.gradle</code> file with all the Epsilon dependencies;</li> <li>Import the example in your favourite Java IDE (e.g. Eclipse, IntelliJ, VS Code) and run the <code>Example</code> class;</li> <li>Alternatively, follow the instructions in the <code>readme.txt</code> to run the example from command line (you only need to have Java and Maven/Gradle installed);</li> <li>Read this article that introduces Epsilon's Java API.</li> </ul>"},{"location":"getting-started/#epsilon-in-mavengradle-builds","title":"Epsilon in Maven/Gradle Builds","text":"<p>On some occasions you may need to include model management tasks in your build/CI pipeline (e.g. to validate a model and generate code from it). For such scenarios, Epsilon provides Ant tasks that can be used in the context of Maven and Gradle builds. To get started with running Epsilon from Maven/Gradle builds:</p> <ul> <li>Go to the Epsilon Playground and select one of the examples;</li> <li>Click the <code>Download</code> button and select <code>Maven</code> or <code>Gradle</code> from the window that pops up to download a zipped copy of the example. The downloaded zip file includes a <code>pom.xml</code>/<code>build.gradle</code> file with all the Epsilon dependencies and the respective Epsilon Ant tasks;</li> <li>Follow the instructions in the <code>readme.txt</code> to run the example from command line (you only need to have Java and Maven/Gradle installed).</li> </ul>"},{"location":"getting-started/#epsilon-in-eclipse","title":"Epsilon in Eclipse","text":"<p>Epsilon provides a rich set of Eclipse plugins for editing, running, profiling and debugging model management programs. It also includes tools for editing, weaving and visualising models. You can install these tools through Epsilon's update site or through the Eclipse Installer.</p>"},{"location":"getting-started/#epsilon-in-other-ideseditors","title":"Epsilon in other IDEs/Editors","text":"<p>Support for syntax highlighting Epsilon programs, Flexmi models and Emfatic metamodels is available for the following IDEs and editors, beyond Eclipse.</p> VS Code Sublime"},{"location":"labs/","title":"Epsilon Labs","text":"<p>EpsilonLabs is a satellite project of Epsilon on GitHub that hosts experimental stuff which may (or may not) end up being part of Epsilon in the future. It also hosts contributions that are incompatible with EPL and therefore cannot be hosted under eclipse.org.</p> <p>Warning</p> <p>Please be aware that the code contributed under EpsilonLabs is not part of (or in any other way formally related to) Eclipse, and has not been IP-checked by the Eclipse legal team. </p>"},{"location":"branding/","title":"Branding","text":""},{"location":"branding/#branding","title":"Branding","text":"<p>Below are different versions of the Epsilon logo to use in posters, presentations, demos etc. To download a copy of a logo, right-click on it and select <code>Save Image As...</code> in your browser. The SVG versions are infinitely scalable and the PNG versions are much larger than their thumbnails on this page. The font of the text in the logo is Lucida Grande.</p> Description SVG PNG Sphere and text Sphere only Text only"},{"location":"branding/#what-do-the-name-and-the-logo-mean","title":"What do the name and the logo mean?","text":"<p>Epsilon (pronounced \u025bps\u026al\u0252n) stands for Extensible Platform for Specification of Interoperable Languages for Model Management. The dark blue jigsaw pieces in the logo represent the different languages in Epsilon, while the purple pieces represent the different modelling technologies that Epsilon programs can operate on.</p>"},{"location":"branding/#license","title":"License","text":"<p>As with everything else in Epsilon, the logos are licensed under the Eclipse Public License 2.0.</p>"},{"location":"doc/","title":"Documentation","text":"<p>Epsilon is a family of languages and tools implemented in Java, for automating common model-based software engineering tasks.</p>"},{"location":"doc/#languages","title":"Languages","text":"<p>At the core of Epsilon is the Epsilon Object Language (EOL), a scripting language that combines the imperative style of languages like Java/JavaScript with the powerful functional model querying capabilities of OCL. On top of EOL, Epsilon provides a number of interoperable task-specific languages for tasks such as code generation, model-to-model transformation and model validation.</p> <p>Epsilon languages are underpinnd by a model connectivity layer that shields them from the specifics of individual modeling technologies and allows them to query and modify models that conform to different technologies in a uniform way (e.g. transform an EMF model into Simulink, cross-validate an XML document and a UML model).</p> graph TD     ECL[\"Model&lt;br/&gt;comparison&lt;br/&gt;(ECL)\"]     Flock[\"Model&lt;br/&gt;migration&lt;br/&gt;(Flock)\"]     EGL[\"Code&lt;br/&gt;generation&lt;br/&gt;(EGL)\"]     EVL[\"Model&lt;br/&gt;validation&lt;br/&gt;(EVL)\"]     EPL[\"Pattern&lt;br/&gt;Matching&lt;br/&gt;(EPL)\"]     EML[\"Model&lt;br/&gt;Merging&lt;br/&gt;(EML)\"]     ETL[\"M2M&lt;br/&gt;Transformation&lt;br/&gt;(ETL)\"]     EOL[\"Epsilon Object Language (EOL)\"]     ETL --&gt; |extends|EOL     EML --&gt; |uses for matching|ECL     EML --&gt; |extends|ETL     EPL --&gt; |extends|EOL     ECL --&gt; |extends|EOL     EGL --&gt; |preprocessed into|EOL     EVL --&gt; |extends|EOL     Flock --&gt; |extends|EOL     Pinset --&gt; |extends|EOL      EMC[\"Epsilon Model Connectivity (EMC)\"]     EMF[\"Eclipse Modeling&lt;br/&gt; Framework (EMF)\"]     Simulink[\"MATLAB&lt;br/&gt;Simulink\"]     Excel[\"Excel&lt;br/&gt;Speadsheets\"]     PTC[\"PTC Integrity&lt;br/&gt;Modeller\"]     Dots[\"...\"]      EOL --&gt;|accesses models through| EMC     EMC --- EMF     EMC --- Simulink     EMC --- XML     EMC --- Excel     EMC --- PTC     EMC --- CSV     EMC --- Dots      classDef eol fill:#CCCCCC;     class EOL eol;     classDef emc fill:#AFAFAF;     class EMC emc;     classDef language fill:#ffffff;     class ETL,Flock,EGL,EVL,ECL,EPL,EML,Pinset language;     classDef driver fill:#E8E8E8;     class EMF,XML,CSV,Simulink,Excel,PTC,Dots driver;"},{"location":"doc/#task-specific-languages","title":"Task-Specific Languages","text":"<p>Epsilon provides the following task-specific languages, which use EOL as their core expression language. Each task-specific language provides constructs and syntax that are tailored to the specific task it targets:</p> <ul> <li>Epsilon Generation Language (EGL): A template-based model-to-text language for generating code, documentation and other textual artefacts from models. EGL supports content-destination decoupling, protected regions for mixing generated with hand-written code. EGL also provides a rule-based coordination language (EGX), that allows specific EGL templates to be executed for a specific model element type, with the ability to guard rule execution and specify generation target location by type/element.</li> <li>Epsilon Transformation Language (ETL): A rule-based model-to-model transformation language that supports transforming many input to many output models, rule inheritance, lazy and greedy rules, and the ability to query and modify both input and output models.</li> <li>Epsilon Validation Language (EVL): A model validation language that supports both intra and inter-model consistency checking, constraint dependency management and specifying fixes that users can invoke to repair identified inconsistencies. EVL is integrated with EMF/GMF and as such, EVL constraints can be evaluated from within EMF/GMF editors and generate error markers for failed constraints.</li> <li>Epsilon Wizard Language (EWL): A language tailored to interactive in-place model transformations on model elements selected by the user. EWL is integrated with EMF/GMF and as such, wizards can be executed from within EMF and GMF editors.</li> <li>Epsilon Comparison Language (ECL): A rule-based language for discovering correspondences (matches) between elements of models of diverse metamodels.</li> <li>Epsilon Merging Language (EML): A rule-based language for merging models of diverse metamodels, after first identifying their correspondences with ECL (or otherwise).</li> <li>Epsilon Pattern Language (EPL): A pattern language for matching model elements based on element relations and characteristics.</li> <li>Epsilon Model Generation Language (EMG): A language for semi-automated model generation.</li> <li>Epsilon Flock: A rule-based transformation language for updating models in response to metamodel changes.</li> <li>EUnit: EUnit is a unit testing framework specialized on testing model management tasks, such as model-to-model transformations, model-to-text transformations or model validation. It is based on Epsilon, but it can be used for model technologies external to Epsilon. Tests are written by combining an EOL script and an ANT buildfile.</li> <li>Pinset: A rule-based domain-specific transformation language that allows extracting tabular datasets (i.e. CSVs) from input models.</li> </ul>"},{"location":"doc/#tools","title":"Tools","text":"<p>In addition to the languages above, Epsilon also provides several tools and utilities for working with models.</p>"},{"location":"doc/#graphical-modelling","title":"Graphical Modelling","text":"<ul> <li>Picto: Picto is an Eclipse view for visualising models via model-to-text transformation to SVG/HTML. Compared to existing graphical modelling frameworks such as Sirius and GMF, the main appeal of Picto is that model visualisation takes place in an embedded browser and therefore you can leverage any HTML/SVG/JavaScript-based technology such as D3.js, mxGraph and JointJS. Picto also provides built-in support for the powerful Graphviz and PlantUML textual syntaxes (which are transformed to SVG via the respective tools). A distinguishing feature of Picto is does not require running multiple Eclipse instances as the metamodels, models and visualisation transformations can all reside in the same workspace.</li> <li>Eugenia: Eugenia is a front-end for GMF. Its aim is to speed up the process of developing a GMF editor and lower the entrance barrier for new developers. To this end, Eugenia enables developers to generate a fully-functional GMF editor only by specifying a few high-level annotations in the Ecore metamodel.</li> </ul>"},{"location":"doc/#textual-modelling","title":"Textual Modelling","text":"<ul> <li>Flexmi: Flexmi is a flexible, reflective textual syntax for creating models conforming to Ecore (EMF) metamodels. Flexmi is XML-based and offers features such as fuzzy matching of XML tags and attributes to Ecore class/feature names, support for embedding EOL expressions in models and for defining and instantiating model element templates.</li> <li>Human Usable Textual Notation: An implementation of the OMG standard for representing models in a human understandable format. HUTN allows models to be written using a text editor in a C-like syntax.</li> </ul>"},{"location":"doc/#emf-utilities","title":"EMF Utilities","text":"<ul> <li>Exeed: Exeed is an enhanced version of the built-in EMF reflective tree-based editor that enables developers to customize the labels and icons of model elements simply by attaching a few simple annotations to the respective EClasses in the Ecore metamodel. Exeed also supports setting the values of references using drag-and-drop instead of using the combo boxes in the properties view.</li> <li>ModeLink: ModeLink is an editor consisting of 2-3 side-by-side EMF tree-based editors, and is very convenient for establishing (weaving) links between different models using drag-and-drop.</li> </ul>"},{"location":"doc/#workflow","title":"Workflow","text":"<ul> <li>Workflow: Epsilon provides a set of ANT tasks to enable developers assemble complex workflows that involve both MDE and non-MDE tasks.</li> </ul>"},{"location":"doc/ecl/","title":"The Epsilon Comparison Language (ECL)","text":"<p>Model comparison is the task of identifying matching elements between models. In general, matching elements are elements that are involved in a relationship of interest. For example, before merging homogeneous models, it is essential to identify overlapping (common) elements so that they do not appear in duplicate in the merged model. Similarly, in heterogeneous model merging, it is a prerequisite to identify the elements on which the two models will be merged. Finally, in transformation testing, matching elements are pairs consisting of elements in the input model and their generated counterparts in the output model.</p> <p>The aim of the Epsilon Comparison Language (ECL) is to enable users to specify comparison algorithms in a rule-based manner to identify pairs of matching elements between two models of potentially different metamodels and modelling technologies. In this section, the abstract and concrete syntax, as well as the execution semantics of the language, are discussed in detail.</p>"},{"location":"doc/ecl/#abstract-syntax","title":"Abstract Syntax","text":"<p>In ECL, comparison specifications are organized in modules (EcLModule). As illustrated below, EclModule (indirectly) extends EolModule which means that it can contain user-defined operations and import other library modules and ECL modules. Apart from operations, an ECL module contains a set of match-rules (MatchRule) and a set of pre and post blocks than run before and after all comparisons, respectively.</p> <p>MatchRules enable users to perform comparison of model elements at a high level of abstraction. Each match-rule declares a name, and two parameters (leftParameter and rightParameter) that specify the types of elements it can compare. It also optionally defines a number of rules it inherits (extends) and if it is abstract, lazy and/or greedy. The semantics of the latter are discussed shortly.</p> classDiagram class MatchRule {     -name: String     -abstract: Boolean     -lazy: Boolean     -unique: Boolean     -greedy: Boolean     -guard: ExecutableBlock&lt;Boolean&gt;     -compare: ExecutableBlock&lt;Boolean&gt;     -do: ExecutableBlock&lt;Void&gt; } class Parameter {     -name: String     -type: EolType  } class NamedStatementBlockRule {     -name: String     -body: StatementBlock } EolModule &lt;|-- ErlModule EclModule --|&gt; ErlModule Pre --|&gt; NamedStatementBlockRule Post --|&gt; NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * EclModule -- MatchRule: rules * MatchRule -- Parameter: left MatchRule -- Parameter: right MatchRule -- MatchRule: extends * <p>A match rule has three parts. The guard part is an EOL expression or statement block that further limits the applicability of the rule to an even narrower range of elements than that specified by the left and right parameters. The compare part is an EOL expression or statement block that is responsible for comparing a pair of elements and deciding if they match or not. Finally, the do part is an EOL expression or block that is executed if the compare part returns true to perform any additional actions required.</p> <p>Pre and post blocks are named blocks of EOL statements which as discussed in the sequel are executed before and after the match-rules have been executed respectively.</p>"},{"location":"doc/ecl/#concrete-syntax","title":"Concrete Syntax","text":"<p>The concrete syntax of a match-rule is displayed below.</p> <pre><code>(@lazy)?\n(@greedy)?\n(@abstract)?\nrule &lt;name&gt;\n    match &lt;leftParameterName&gt;:&lt;leftParameterType&gt; \n    with &lt;rightParameterName&gt;:&lt;rightParameterType&gt;\n        (extends &lt;ruleName&gt;(, &lt;ruleName&gt;)*)? { \n\n    (guard (:expression)|({statementBlock}))?\n    compare (:expression)|({statementBlock})\n    (do {statementBlock})?\n}\n</code></pre> <p>Pre and post blocks have a simple syntax that, as shown below, consists of the identifier (pre or post), an optional name and the set of statements to be executed enclosed in curly braces.</p> <pre><code>(pre|post) &lt;name&gt; {\n    statement+\n}\n</code></pre>"},{"location":"doc/ecl/#execution-semantics","title":"Execution Semantics","text":""},{"location":"doc/ecl/#rule-and-block-overriding","title":"Rule and Block Overriding","text":"<p>An ECL module can import a number of other ECL modules. In such a case, the importing ECL module inherits all the rules and pre/post blocks specified in the modules it imports (recursively). If the module specifies a rule or a pre/post block with the same name, the local rule/block overrides the imported one respectively.</p>"},{"location":"doc/ecl/#comparison-outcome","title":"Comparison Outcome","text":"<p>As illustrated below, the result of comparing two models with ECL is a trace (MatchTrace) that consists of a number of matches (Match). Each match holds a reference to the objects from the two models that have been compared (left and right), a boolean value that indicates if they have been found to be matching or not, a reference to the rule that has made the decision, and a Map (info) that is used to hold any additional information required by the user (accessible at runtime through the matchInfo implicit variable). During the matching process, a second, temporary, match trace is also used to detect and resolve cyclic invocation of match-rules as discussed in the sequel.</p> classDiagram class Match {     -left: Object     -right: Object     -matching: Boolean } class EclContext {     -matchTrace: MatchTrace     -tempMatchTrace: MatchTrace } MatchRule -- Match: rule MatchTrace -- Match: matches * EclContext --|&gt; EolContext EclContext -- MatchTrace Map -- Match: info"},{"location":"doc/ecl/#rule-execution-scheduling","title":"Rule Execution Scheduling","text":"<p>Non-abstract, non-lazy match-rules are evaluated automatically by the execution engine in a top-down fashion - with respect to their order of appearance - in two passes. In the first pass, each rule is evaluated for all the pairs of instances in the two models that have a type-of relationship with the types specified by the leftParameter and rightParameter of the rule. In the second pass, each rule that is marked as greedy is executed for all pairs that have not been compared in the first pass, and which have a kind-of relationship with the types specified by the rule. In both passes, to evaluate the compare part of the rule, the guard must be satisfied.</p> <p>Before the compare part of a rule is executed, the compare parts of all of the rules it extends (super-rules) must be executed (recursively). Before executing the compare part of a super-rule, the engine verifies that the super-rule is actually applicable to the elements under comparison by checking for type conformance and evaluating the guard part of the super-rule.</p> <p>If the compare part of a rule evaluates to true, the optional do part is executed. In the do part the user can specify any actions that need to be performed for the identified matching elements, such as to populate the info map of the established match with additional information. Finally, a new match is added to the match trace that has its matching property set to the logical conjunction of the results of the evaluation of the compare parts of the rule and its super-rules.</p>"},{"location":"doc/ecl/#the-matches-built-in-operation","title":"The matches() built-in operation","text":"<p>To refrain from performing duplicate comparisons and to de-couple match-rules from each other, ECL provides the built-in matches(opposite : Any) operation for model elements and collections. When the matches() operation is invoked on a pair of objects, it queries the main and temporary match-traces to discover if the two elements have already been matched and if so it returns the cached result of the comparison. Otherwise, it attempts to find an appropriate match rule to compare the two elements and if such a rule is found, it returns the result of the comparison, otherwise it returns false. Unlike the top-level execution scheme, the matches() operation invokes both lazy and non-lazy rules.</p> <p>In addition to objects, the matches operations can also be invoked to match pairs of collections of the same type (e.g. a Sequence against a Sequence). When invoked on ordered collections (i.e. Sequence and OrderedSet), it examines if the collections have the same size and each item of the source collection matches with the item of the same index in the target collection. Finally, when invoked on unordered collections (i.e. Bag and Set), it examines if for each item in the source collection, there is a matching item in the target collection irrespective of its index. Users can also override the built-in matches operation using user-defined operations with the same name, that loosen or strengthen the built-in semantics.</p>"},{"location":"doc/ecl/#cyclic-invocation-of-matches","title":"Cyclic invocation of matches()","text":"<p>Providing the built-in matches operation significantly simplifies comparison specifications. It also enhances decoupling between match-rules from each other as when a rule needs to compare two elements that are outside its scope, it does not need to know/specify which other rule can compare those elements explicitly.</p> <p>On the other hand, it is possible - and quite common indeed - for two rules to implicitly invoke each other. For example consider the match rule below that attempts to match nodes of the simple Tree metamodel.</p> classDiagram class Tree {     +label: String     +parent: Tree     +children: Tree[*] } Tree -- Tree <pre><code>rule Tree2Tree \n    match l : T1!Tree\n    with r : T2!Tree {\n\n    compare : l.label = r.label and \n        l.parent.matches(r.parent) and\n        l.children.matches(r.children)\n}</code></pre> <p>The rule specifies that for two Tree nodes (l and r) to match, they should have the same label, belong to matching parents and have matching children. In the absence of a dedicated mechanism for cycle detection and resolution, the rule would end up in an infinite loop. To address this problem, ECL provides a temporary match-trace which is used to detect and resolve cyclic invocations of the match() built-in operation.</p> <p>As discussed above, a match is added to the primary match-trace as soon as the compare part of the rule has been executed to completion. By contrast, a temporary match (with its matching property set to true) is added to the temporary trace before the compare part is executed. In this way, any subsequent attempts to match the two elements from invoked rules will not re-invoke the rule. Finally, when a top-level rule returns, the temporary match trace is reset.</p>"},{"location":"doc/ecl/#fuzzy-and-dictionary-based-string-matching","title":"Fuzzy and Dictionary-based String Matching","text":"<p>In the example above, the rule specifies that to match, two trees must - among other criteria - have the same label. However, there are cases when a less-strict approach to matching string properties of model elements is desired. For instance, when comparing two UML models originating from different organizations, it is common to encounter ontologically equivalent classes which however have different names (e.g. Client and Customer). In this case, to achieve a more sound matching, the use of a dictionary or a lexical database (e.g. WordNet) is necessary. Alternatively, fuzzy string matching algorithms can be used.</p> <p>As several such tools and algorithms have been implemented in various programming languages, it is a sensible approach to reuse them instead of re-implementing them. For example, in the listing below a wrapper for the Simmetrics fuzzy string comparison tool is used to compare the labels of the trees using the Levenshtein algorithm. To achieve this, line 11 invokes the fuzzyMatch() operation defined in lines 16-18 which uses the simmterics native tool (instantiated in lines 2-4) to match the two labels using their Levenshtein distance with a threshold of 0.5.</p> <pre><code>pre {\n    var simmetrics = \n        new Native(\"org.epsilon.ecl.tools.\n            textcomparison.simmetrics.SimMetricsTool\"); \n}\n\nrule FuzzyTree2Tree \n    match l : T1!Tree\n    with r : T2!Tree {\n\n    compare : l.label.fuzzyMatch(r.label) and \n        l.parent.matches(r.parent) and\n        l.children.matches(r.children)\n}\n\noperation String fuzzyMatch(other : String) : Boolean {\n    return simmetrics.similarity(self,other,\"Levenshtein\") &gt; 0.5;\n}</code></pre>"},{"location":"doc/ecl/#the-match-trace","title":"The Match Trace","text":"<p>Users can query and modify the match trace calculated during the comparison process in the post sections of the module or export it into another application or Epsilon program. For example, in a post section, the trace can be printed to the default output stream or serialized into a model of an arbitrary metamodel. In another use case, the trace may be exported to be used in the context of a validation module that will use the identified matches to evaluate inter-model constraints, or in a merging module that will use the matches to identify the elements on which the two models will be merged.</p> <p>Querying Match Traces</p> <p>Please note that match traces computed by ECL contain both successful and unsuccessful matches, and can therefore become slow to query as compared models grow in size. If you are only interested in successful matches when querying your match trace, you can use <code>matchTrace.getReduced()</code> to produce a reduced trace that only contains successful matches.  </p>"},{"location":"doc/egl/","title":"The Epsilon Generation Language (EGL)","text":"<p>EGL is a model-to-text transformation (M2T) language that can be used to transform models into various types of textual artefact, including code (e.g. Java), reports (e.g. in HTML/LaTeX), images (e.g. using Graphviz), formal specifications, or even entire applications comprising code in multiple languages (e.g. HTML, Javascript and CSS).</p> <p>EGL is a template-based language (i.e. EGL programs resemble the text that they generate), and provides several features that simplify and support the generation of text from models, including: </p> <ul> <li>a sophisticated and language-independent merging engine (for preserving hand-written sections of generated text), </li> <li>an extensible template system (for generating text to a variety of sources, such as a file on disk, a database server, or even as a response issued by a web server), </li> <li>formatting algorithms (for producing generated text that is well-formatted and hence readable), and traceability mechanisms (for linking generated text with source models).</li> </ul> <p>Try EGL online</p> <p>You can run and fiddle with EGL templates in the online Epsilon Playground.</p>"},{"location":"doc/egl/#abstract-syntax","title":"Abstract Syntax","text":"<p>The figure below shows the abstract syntax of EGL's core functionality.</p> <p>Info</p> <p>As with most languages in Epsilon, EGL uses EOL as its expression language. This page only documents the additional syntax and semantics that EGL provides on top of EOL.</p> classDiagram class EglSection {     +getChildren(): List     +getText(): String } class EglDynamicSection {     +getText(): String } class EglStaticSection {     +getText(): String } class EglShortcutSection {     +getText(): String } EglSection &lt;|-- EglDynamicSection EglSection &lt;|-- EglStaticSection EglSection &lt;|-- EglShortcutSection <p>Conceptually, an EGL program comprises one or more sections. The contents of static sections are emitted verbatim and appear directly in the generated text. The contents of dynamic sections are executed and are used to control the text that is generated.</p> <p>In its dynamic sections, EGL re-uses EOL's syntax for structuring program control flow, performing model inspection and navigation, and defining custom operations. In addition, EGL provides an EOL object, <code>out</code>, which is used in dynamic sections to perform operations on the generated text, such as appending and removing strings; and specifying the type of text to be generated.</p> <p>EGL also provides syntax for defining dynamic output sections, which provide a convenient shorthand for outputting text from within dynamic sections. Similar syntax is often provided by template-based code generators.</p>"},{"location":"doc/egl/#concrete-syntax","title":"Concrete Syntax","text":"<p>The concrete syntax of EGL closely resembles the style of other template-based code generation languages, such as PHP. The tag pair [% %] is used to delimit a dynamic section. Any text not enclosed in such a tag pair is contained in a static section. The listing below illustrates the use of dynamic and static sections to form a basic EGL template.</p> <pre><code>[% for (i in Sequence{1..5}) { %]\ni is [%=i%]\n[% } %]</code></pre> <p>Executing the EGL template above would produce the generated text below. The [%=expr%] construct (line 2) is shorthand for [% out.print(expr); %], which appends expr to the output generated by the transformation.</p> <pre><code>i is 1\ni is 2\ni is 3\ni is 4\ni is 5\n</code></pre> <p>Any EOL statement can be contained in the dynamic sections of an EGL template. For example, the EGL template shown below generates text from a model that conforms to a metamodel that describes an object-oriented system.</p> <pre><code>[% for (c in Class.all) { %]\n[%=c.name%]\n[% } %]</code></pre>"},{"location":"doc/egl/#comments-and-markers","title":"Comments and Markers","text":"<p>Inside an EGL dynamic section, EOL's comment syntax can be used. Additionally, EGL adds syntax for comment blocks <code>[* this is a comment *]</code> and marker blocks <code>[*- this is a marker *]</code>. Marker blocks are highlighted by the EGL editor and EGL outline view in Eclipse.</p>"},{"location":"doc/egl/#user-defined-operations","title":"User-Defined Operations","text":"<p>Like EOL, EGL permits users to define re-usable units of code via operations.</p> <pre><code>[% c.declaration(); %]\n[% operation Class declaration() { %]\n[%=self.visibility%] class [%=self.name%] {}\n[% } %]</code></pre> <p>In EGL, user-defined operations are defined in dynamic sections, but may mix static and dynamic sections in their bodies. Consider, for example, the EGL code in the listing above, which emits a declaration for a Java class (e.g. <code>public class Foo {}</code>). Lines 2-4 declare the operation. Note that the start and the end of the operation's declaration (on lines 2 and 4, respectively) are contained in dynamic sections. The body of the operation (line 3), however, mixes static and dynamic output sections. Finally, note that the operation is invoked from a dynamic section (line 1). It is worth noting that any loose (i.e. not contained in other operations) dynamic or static sections below the first operation of a template will be ignored at runtime.</p> <p>When a user-defined operation is invoked, any static or dynamic sections contained in the body of the operation are immediately appended to the generated text. Sometimes, however, it is desirable to manipulate the text produced by an operation before it is appended to the generated text. To this end, EGL defines the <code>@template</code> annotation which can applied to operations to indicate that any text generated by the operation must be returned from the operation and not appended to the generated text. For example, the EGL program in the listing above could be rewritten using a <code>@template</code> annotation, as demonstrated below.</p> <pre><code>[%=c.declaration()%]\n[% @template\n   operation Class declaration() { %]\n[%=self.visibility%] class [%=self.name%] {}\n[% } %]</code></pre> <p>There is a subtle difference between the way in which standard (i.e. unannotated) operations and <code>@template</code> operations are invoked. Compare the first line of the two listings above. The former uses a dynamic section, because invoking the operation causes the evaluation of its body to be appended to the text generated by this program. By contrast, the latter uses a dynamic output section to append the result returned by the <code>@template</code> operation to the text generated by this program.</p> <p>In general, <code>@template</code> operations afford more flexibility than standard operations. For example, line 1 of the listing above could perform some manipulation of the text returned by the <code>declaration()</code> operation before the text is outputted. Therefore, <code>@template</code> operations provide a mechanism for re-using common pieces of a code generator, without sacrificing the flexibility to slightly alter text before it is emitted. Standard (unannotated) operations also permit re-use, but in a less flexible manner.</p> <p>Finally, it is worth noting that user-defined operations in EGL do not have to generate text. For example, the following listing illustrates two operations defined in an EGL program that do not generate any text. The former is a query that returns a Boolean value, while the latter alters the model, and does not return a value.</p> <pre><code>[%\noperation Class isAnonymous() : Boolean {\n    return self.name.isUndefined();\n}\n\noperation removeOneClass() {\n    delete Class.all.random();\n}\n%]</code></pre>"},{"location":"doc/egl/#the-outputbuffer","title":"The OutputBuffer","text":"<p>As an EGL program is executed, text is appended to a data structure termed the OutputBuffer. In every EGL program, the OutputBuffer is accessible via the <code>out</code> built-in variable. The OutputBuffer provides operations for appending to and removing from the buffer, and for merging generated text with existing text.</p> <p>For many EGL programs, interacting directly with the OutputBuffer is unnecessary. The contents of static and dynamic output sections are sent directly to the OutputBuffer, and no operation of the OutputBuffer need be invoked directly. However, in cases when generated text must be sent to the OutputBuffer from dynamic sections, or when generated text must be merged with existing text, the operations of OutputBuffer are provided in the table below. The [merge engine section]](#merge-engine) discusses merging generated and existing text, and presents several examples of invoking the operations of OutputBuffer.</p> Signature Description chop(numberOfChars : Integer) Removes the specified number of characters from the end of the buffer print(object : Any) Appends a string representation of the specified object to the buffer println(object : Any) Appends a string representation of the specified object and a new line to the buffer println() Appends a new line to the buffer setContentType(contentType : String) Updates the content type of this template. Subsequent calls to <code>preserve</code> or <code>startPreserve</code> that do not specify a style of comment will use the style of comment defined by the specified content type. preserve(id : String, enabled : Boolean, contents : String) Appends a protected region to the buffer with the given identifier, enabled state and contents. Uses the current content type to determine how to format the start and end markers. preserve(startComment : String, endComment : String, id : String, enabled : Boolean, contents : String) Appends a protected region to the buffer with the given identifier, enabled state and contents. Uses the first two parameters as start and end markers. startPreserve(id : String, enabled : Boolean) Begins a protected region by appending the start marker for a protected region to the buffer with the given identifier and enabled state. Uses the current content type to determine how to format the start and end markers startPreserve(startComment : String, endComment : String, id : String, enabled : Boolean) Begins a protected region by appending the start marker to the buffer with the given identifier and enabled state. Uses the first two parameters as start and end markers. stopPreserve() Ends the current protected region by appending the end marker to the buffer. This operation should be invoked only if there a protected region is currently open (i.e. has been started by invoking <code>startPreserve</code> but not yet stopped by invoking <code>stopPreserve</code>). setIndenters(indenters : Collection&lt;String&gt;) Sets the indentation characters for the buffer (default is <code>\\t</code> and four spaces)."},{"location":"doc/egl/#co-ordination","title":"Co-ordination","text":"<p>Warning</p> <p>The recommended way to coordinate the execution of EGL templates is using the EGX rule-based language. This section describes an imperative way to invoke EGL templates which pre-dates EGX and should only be used as a fall-back in case the semantics of EGX are not sufficient for the task at hand.</p> <p>In the large, M2T transformations are used to generate text to various destinations. For example, code generators often produce files on disk, and web applications often generate text as part of the response for a resource on the web server. Text might be generated to a network socket during interprocess communication, or as a query that runs on a database. Furthermore, (parts of) a single M2T transformation might be re-used in different contexts. A M2T transformation that generates files on disk today might be re-purposed to generate the response from a web server tomorrow.</p> <p>Given these concerns, EGL provides a co-ordination engine that provides mechanisms for modularising M2T transformations, and for controlling the destinations to which text is generated. The EGL co-ordination engine fulfils three requirements:</p> <ol> <li> <p>Reusability: the co-ordination engine allows EGL programs to be decomposed into one or more templates, which can be shared between EGL programs.</p> </li> <li> <p>Variety of destination: the co-ordination engine provides an extensible set of template types that can generate text to a variety of destinations. The next section describes the default template type, which is tailored to generate text to files on disk, while a subsequent section discusses the way in which users can define their own template types for generating text to other types of destination.</p> </li> <li> <p>Separation of concerns: the co-ordination engine ensures that the logic for controlling the text that is generated (i.e. the content) and the logic for controlling the way in which text is emitted (i.e. the destination) are kept separate.</p> </li> </ol> <p>There is also the EGX language, which was introduced after this documentation was initially written, but provides a fully-fledged rule-based execution engine for paramterising EGL templates.</p>"},{"location":"doc/egl/#the-template-type","title":"The Template type","text":"<p>Central to the co-ordination engine is the Template type, which EGL provides in addition to the default EOL types. Via the Template type, EGL fulfils the three requirements identified above. Firstly, a Template can invoke other Templates, and hence can be shared and re-used between EGL programs. Secondly, the Template type has been implemented in an extensible manner: users can define their own types of Template that generate text to any destination (e.g. a database or a network socket), as described in the custom coordination section. Finally, the Template type provides a set of operations that are used to control the destination of generated text. Users typically define a \"driver\" template that does not generate text, but rather controls the destination of text that is generated by other templates.</p> <p>For example, consider the EGL program in the listing below. This template generates no text (as it contains only a single dynamic section), but is used instead to control the destination of text generated by another template. Line 1 defines a variable, <code>t</code>, of type Template. Note that, unlike the EOL types, instances of Template are not created with the <code>new</code> keyword. Instead, the TemplateFactory built-in object is used to load templates from, for example, a file system path. On line 3, the generate operation of the Template type invokes the EGL template stored in the file \"ClassNames.egl\" and emits the generated text to \"Output.txt\".</p> <pre><code>[%\nvar t : Template = TemplateFactory.load(\"ClassNames.egl\");\nt.generate(\"Output.txt\");\n%]</code></pre> <p>In addition to <code>generate</code>, the Template type defines further operations for controlling the context and invocation of EGL templates. The following table lists all of the operations defined on Template, and a further example of their use is given in the sequel.</p> Signature Description populate(name : String, value : Any) Makes a variable with the specified name and value available during the execution of the template. process() : String Executes the template and returns the text that is generated. generate(destination : String) Executes the template and stores the text to the specified destination. The format of the destination parameter is dictated by the type of template. For example, the default template type (which can generate files on disk) expects a file system path as the destination parameter. Returns a object representing the generated file. append(destination : String) Executes the template: if the destination exists, it will add a newline and the generated text at the end of the file. If the file does not exist, it will write the generated text to it (with no newline). Returns a object representing the generated file. setFormatter(formatter : Formatter) Changes the formatter for this template to the specified formatter. Subsequent calls to generate or process will produce text that is formatted with the specified formatter. setFormatters(formatters : Sequence(Formatter)) Changes the formatter for this template to the specified sequence of formatters. Subsequent calls to generate or process will produce text that is formatted with each of the specified formatters in turn."},{"location":"doc/egl/#the-templatefactory-object","title":"The TemplateFactory object","text":"<p>As discussed above, instances of Template are not created with the <code>new</code> keyword. Instead, EGL provides a built-in object, the TemplateFactory, for this purpose. Users can customise the type of the TemplateFactory object to gain more control over the way in which text is generated.</p> <p>By default, EGL provides a TemplateFactory that exposes operations for loading templates (by loading files from disk), preparing templates (by parsing a string containing EGL code), and for controlling the file system locations from which templates are loaded and to which text is generated.</p> <p>The table below lists the operations provided by the built-in TemplateFactory object.</p> Signature Description load(path : String) : Template Returns an instance of Template that can be used to execute the EGL template stored at the specified path. prepare(code : String) Changes the default path that is used to resolve relative paths when generating files to disk. Subsequent calls to load and prepare will create templates that use the new path. setOutputRoot(path : String) Changes the default path that is used to resolve relative paths when generating files to disk. Subsequent calls to load and prepare will create templates that use the new path. setTemplateRoot(path : String) Changes the default path that is used to resolve relative paths when loading templates with the load operation. Subsequent calls to load will use the new path. setDefaultFormatter(formatter : Formatter) Changes the formatter for this template factory to the specified formatter. Templates that are constructed after this operation has been invoked will produce text that is, by default, formatted with the specified formatter. setDefaultFormatters(format- ters : Sequence(Formatter)) Sequence(Formatter)) &amp; Changes the formatter for this template to the specified sequence of formatters. Templates that are constructed after this operation has been invoked will produce text that is, by default, formatted with each of the specified formatters in turn."},{"location":"doc/egl/#an-example-of-co-ordination-with-egl","title":"An Example of Co-ordination with EGL","text":"<p>The operations provided by the TemplateFactory object and Template type are demonstrated by the EGL program in the listing below. Lines 2-3 use operations on TemplateFactory to change the paths from which templates will be loaded (line 2) and to which generated files will be created (line 3). Line 5 demonstrates the use of the <code>prepare</code> operation for creating a template from EGL code. When the <code>interface</code> template is invoked, the EGL code passed to the <code>prepare</code> operation will be executed. Finally, line 9 (and line 12) illustrates the way in which the <code>populate</code> operation can be used to pass a value to a template before invoking it. Specifically, the interface and implementation templates can use a variable called root, which is populated by the driver template before invoking them.</p> <pre><code>[%\nTemplateFactory.setTemplateRoot(\"/usr/franz/templates\");\nTemplateFactory.setOutputRoot(\"/tmp/output\");\n\nvar interface : Template =\n    TemplateFactory.prepare(\"public interface [%=root.name] {}\");\n\nvar implementation : Template = \n    TemplateFactory.load(\"Class2Impl.egl\");\n\nfor (c in Class.all) {\n    interface.populate(\"root\", c);    \n    interface.generate(\"I\" + c.name + \".java\");\n\n    implementation.populate(\"root\", c);\n    implementation.generate(c.name + \".java\");\n}\n%]</code></pre>"},{"location":"doc/egl/#customising-the-co-ordination-engine","title":"Customising the Co-ordination Engine","text":"<p>EGL provides mechanisms for customising the co-ordination engine. Specifically, users can define and use their own TemplateFactory. In many cases, users need not customise the co-ordination engine, and can write transformations using the built-in Template type and TemplateFactory object. If, however, you need more control over the co-ordination process, the discussion in this section might be helpful. Specifically, a custom TemplateFactory is typically used to achieve one or more of the following goals:</p> <ol> <li> <p>Provide additional mechanisms for constructing Templates. Example: facilitate the loading of templates from a database.</p> </li> <li> <p>Enrich / change the behaviour of the built-in Template type. Example: change the way in which generated text is sent to its destination.</p> </li> <li> <p>Observe or instrument the transformation process by, for instance, logging calls to the operations provided by the Template type of the TemplateFactory object. Example: audit or trace the transformation process.</p> </li> </ol> <p>Customisation is achieved in two stages: implementing the custom TemplateFactory (and potentially a custom Template) in Java, and using the custom TemplateFactory.</p>"},{"location":"doc/egl/#implementing-a-custom-templatefactory","title":"Implementing a custom TemplateFactory","text":"<p>A custom TemplateFactory is a subclass of <code>EglTemplateFactory</code>. Typically, a custom TemplateFactory is implemented by overriding one of the methods of <code>EglTemplateFactory</code>. For example, the <code>createTemplate</code> method is overriden to specify that a custom type of Template should be created by the TemplateFactory. Likewise, the <code>load</code> and <code>prepare</code> methods can be overriden to change the location from which Templates are constructed.</p> <p>A custom Template is a subclass of <code>EglTemplate</code> or, most often, a subclass of <code>EglPersistentTemplate</code>. Again, customisation is typically achieved by overriding methods in the superclass, or by adding new methods. For example, to perform auditing activities whenever a template is used to generate text, the <code>doGenerate</code> method of <code>EglPersistentTemplate</code> is overriden.</p> <pre><code>import org.eclipse.epsilon.egl.EglFileGeneratingTemplateFactory;\nimport org.eclipse.epsilon.egl.EglTemplate;\nimport org.eclipse.epsilon.egl.EglPersistentTemplate;\nimport org.eclipse.epsilon.egl.exceptions.EglRuntimeException;\nimport org.eclipse.epsilon.egl.execute.context.IEglContext;\nimport org.eclipse.epsilon.egl.spec.EglTemplateSpecification;\n\npublic class CountingTemplateFactory extends EglFileGeneratingTemplateFactory {\n\n@Override\nprotected EglTemplate createTemplate(EglTemplateSpecification spec) throws Exception {\nreturn new CountingTemplate(spec, context, getOutputRootOrRoot(), outputRootPath);\n}   public class CountingTemplate extends EglPersistentTemplate {\n\npublic static int numberOfCallsToGenerate = 0;\n\npublic CountingTemplate(EglTemplateSpecification spec, IEglContext context, URI outputRoot, String outputRootPath) throws Exception {\nsuper(spec, context, outputRoot, outputRootPath);\n}\n\n@Override\nprotected void doGenerate(File file, String targetName, boolean overwrite, boolean protectRegions) throws EglRuntimeException {\nnumberOfCallsToGenerate++;\n}\n}\n}\n</code></pre>"},{"location":"doc/egl/#using-a-custom-templatefactory","title":"Using a custom TemplateFactory","text":"<p>When invoking an EGL program, the user may select a custom TemplateFactory. For example, the EGL development tools provide an Eclipse launch configuration that provides a tab named \"Generated Text.\"On this tab, users can select a TemplateFactory (under the group called \"Type of Template Factory\"). Note that a TemplateFactory only appears on the launch configuration tab if it has been registered with EGL via an Eclipse extension. Similarly, the workflow language provided by Epsilon allows the specification of custom types of TemplateFactory via the <code>templateFactoryType</code> parameter.</p>"},{"location":"doc/egl/#summary","title":"Summary","text":"<p>The co-ordination engine provided by EGL facilitates the construction of modular and re-usable M2T transformations and can be used to generate text to various types of destination. Furthermore, the logic for specifying the contents of generated text is kept separate from the logic for specifying the destination of generated text.</p>"},{"location":"doc/egl/#merge-engine","title":"Merge Engine","text":"<p>EGL provides language constructs that allow M2T transformations to designate regions of generated text as protected. Whenever an EGL program attempts to generate text, any protected regions that are encountered in the specified destination are preserved.</p> <p>Within an EGL program, protected regions are specified with the preserve(String, String, String, Boolean, String) method on the <code>out</code> keyword. The first two parameters define the comment delimiters of the target language. The other parameters provide the name, enable-state and content of the protected region, as illustrated in the listing below.</p> <pre><code>[%=out.preserve(\"/*\", \"*/\", \"anId\", true, \"System.out.println(foo);\")%]</code></pre> <p>A protected region declaration may have many lines, and use many EGL variables in the contents definition. To enhance readability, EGL provides two additional methods on the <code>out</code> keyword: startPreserve(String, String, String, Boolean) and <code>stopPreserve</code>. The listing below uses these to generate a protected region.</p> <pre><code>[%=out.startPreserve(\"/*\", \"*/\", \"anId\", true)%]\nSystem.out.println(foo);\n[%=out.stopPreserve()%]</code></pre> <p>Because an EGL template may contain many protected regions, EGL also provides a separate method to set the target language generated by the current template, setContentType(String). By default, EGL recognises Java, HTML, Perl and EGL as valid content types. An alternative configuration file can be used to specify further content types. Following a call to <code>setContentType</code>, the first two arguments to the <code>preserve</code> and <code>startPreserve</code> methods can be omitted, as shown in the listing below.</p> <pre><code>[% out.setContentType(\"Java\"); %]\n[%=out.preserve(\"anId\", true, \"System.out.println(foo);\")%]</code></pre> <p>Because some languages define more than one style of comment delimiter, EGL allows mixed use of the styles for <code>preserve</code> and <code>startPreserve</code> methods.</p> <p>Once a content type has been specified, a protected region may also be declared entirely from a static section, using the syntax in the listing below.</p> <pre><code>[% out.setContentType(\"Java\"); %]\n// protected region anId [on|off] begin\nSystem.out.println(foo);\n// protected region anId end</code></pre> <p>When a template that defines one or more protected regions is processed by the EGL execution engine, the target output destinations are examined and existing contents of any protected regions are preserved. If either the output generated by from the template or the existing contents of the target output destination contains protected regions, a merging process is invoked. The table below shows the default behaviour of EGL's merge engine.</p> Protected Regions in Generated Protected Regions in Existing Contents taken from On On Existing On Off Generated On Absent Generated Off On Existing Off Off Generated Off Absent Generated Absent On Neither (causes a warning) Absent Off Neither (causes a warning)"},{"location":"doc/egl/#formatters","title":"Formatters","text":"<p>Often the text generated by a model-to-text transformation is not formatted in a desirable manner. Text generated with a model-to-text transformation might contain extra whitespace or inconsistent indentation. This is because controlling the formatting of generated text in a model-to-text transformation language can be challenging.</p> <p>In a template-based model-to-text language, such as EGL, it can be difficult to know how best to format a transformation. On the one hand, the transformation must be readable and understandable, and on the other hand, the generated text must typically also be readable and understandable.</p> <p>Conscientious developers apply various conventions to produce readable code. EGL encourages template developers to prioritise the readability of templates over the readability of generated text when writing EGL templates. For formatting generated text, EGL provides an extensible set of formatters that can be invoked during a model-to-text transformation.</p>"},{"location":"doc/egl/#using-a-formatter","title":"Using a Formatter","text":"<p>EGL provides several built-in formatters. Users can implement additional formatters. To use a formatter, invoke the <code>setFormatter</code> or <code>setFormatters</code> operation on an instance of the Template type. A formatter is a Java class that implements EGL's Formatter interface. From within an EGL program, formatters can be created using a Native (i.e. Java) type. The listing below demonstrates the use of a built-in formatter (XmlFormatter).</p> <pre><code>[%\nvar f = new Native(\"org.eclipse.epsilon.egl.formatter.language.XmlFormatter\");\nvar t = TemplateFactory.load(\"generate_some_xml.egl\");\nt.setFormatter(f);\nt.generate(\"formatted.xml\");\n%]</code></pre> <p>To facilitate the re-use of a formatter with many templates, the TemplateFactory object provides the <code>setDefaultFormatter</code> and <code>setDefaultFormatters</code> operations. Templates that are loaded or prepared after a call to <code>setDefaultFormatter</code> or <code>setDefaultFormatters</code> will, by default, use the formatter(s) specified for the TemplateFactory. Note that setting the formatter on a template overwrite any formatter that may have been set on that template by the TemplateFactory.</p> <p>The default formatters for an EGL program can also be set when invoking the program. For example, the EGL development tools provide an Eclipse launch configuration that provides a tab named \"Generated Text.\" On this tab, users can configure one or more formatters which will be used as the default formatters for this EGL program. Note that custom formatters only appear on the launch configuration tab if they have been registered with EGL via an Eclipse extension. Similarly, the workflow language provided by Epsilon provides a <code>formatter</code> nested element that can be used to specify one or more default formatters.</p>"},{"location":"doc/egl/#implementing-a-custom-formatter","title":"Implementing a Custom Formatter","text":"<p>Providing a user-defined formatter involves implementing the <code>Formatter</code> interface (in <code>org.eclipse.epsilon.egl.formatter</code>). For example, the listing below demonstrates a simple formatter that transforms all generated text to uppercase.</p> <pre><code>import org.eclipse.epsilon.egl.formatter.Formatter;\n\npublic class UppercaseFormatter implements Formatter {\n\n@Override\npublic String format(String text) {\nreturn text.toUpperCase();\n}\n}\n</code></pre> <p>The set of built-in formatters provided by EGL includes some partial implementations of the <code>Formatter</code> interface that can be re-used to simplify the implementation of custom formatters. For instance, the <code>LanguageFormatter</code> class can correct the indentation of a program written in most languages, when given a start and end regular expression.</p> <p>Finally, an Eclipse extension point is provided for custom formatters. Providing an extension that conforms to the custom formatter extension point allows EGL to display the custom formatter in the launch configuration tabs of the EGL development tools.</p>"},{"location":"doc/egl/#outdentation","title":"Outdentation","text":"<p>New in 2.4</p> <p>Support for outdentation was added in version 2.4 of Epsilon. If outdentation does not behave as expected in your EGX-coordinated templates with 2.4, please install the latest interim version of Epsilon.</p> <p>A common issue encountered when writing EGL templates is that the ideal indentation for the template code itself and the output it produces may be different. For example, consider the template below, which produces a Graphviz graph from a state machine model.</p> <pre><code>digraph G {\n    [%for (t in Transition.all){%]\n    [%=t.from.name%] -&gt; [%=t.to.name%]\n    [%}%]\n}</code></pre> <p>The output of the template for a minimal state machine model is shown below.</p> <pre><code>digraph G {\nA -&gt; B\nB -&gt; C\nC -&gt; A\n}\n</code></pre> <p>Note that in order to indent lines 2-4 of the output with one tab, we had to \"pull\" line 3 of the template at the same indentation level as its container <code>for</code> loop, which is not ideal. To format both the template and its output properly in this case, we can use <code>-%]</code> instead of <code>%]</code> to close the <code>for</code> loop statement in line 2. This will instruct a built-in EGL formatter to remove one indentation character (see the <code>setIndenters</code> method above) from each of the lines of the content produced within the <code>for</code> loop. The template below uses this feature to produce the same output as the template above.</p> <pre><code>digraph G {\n    [%for (t in Transition.all){-%]\n        [%=t.from.name%] -&gt; [%=t.to.name%]\n    [%}%]\n}</code></pre> <p>Run this example</p> <p>You can run and tweak this example is the Epsilon Playground.</p> <p>Outdentation also works with <code>if</code>, <code>switch</code>, <code>while</code> statements etc. More examples are available in the unit tests folder of this feature.</p>"},{"location":"doc/egl/#traceability","title":"Traceability","text":"<p>EGL also provides a traceability API, as a debugging aid, to support auditing of the M2T transformation process, and to facilitate change propagation. This API facilitates exploration of the templates executed, files affected and protected regions processed during a transformation. The figure below shows sample output from the traceability API after execution of an EGL M2T transformation to generate Java code from an instance of an OO metamodel. The view shown is accessed via the ... menu in Eclipse. Traceability information can also be accessed programmatically, as demonstrated in the listing below.</p> <p></p> <pre><code>EglTemplateFactoryModuleAdapter module = new EglTemplateFactoryModuleAdapter(new EglTemplateFactory());\n\nboolean parsed = module.parse(new File(\"myTemplate.egl\"));\n\nif (parsed &amp;&amp; module.getParseProblems().isEmpty()) {\nmodule.execute();\n\nTemplate base = module.getContext().getBaseTemplate();\n\n// traverse the template hierachy\n// display data \n\n} else {\n// error handling\n}\n</code></pre>"},{"location":"doc/egl/#additional-resources","title":"Additional Resources","text":"<p>Additional resources about EGL/EGX are available here.</p>"},{"location":"doc/egx/","title":"The EGL Co-Ordination Language (EGX)","text":"<p>EGX is a rule-based co-ordination language designed for automating the parametrised execution of model-to-text template transformations. Although built on top of the Epsilon Generation Language (EGL), EGX can in principle work with any template-based model-to-text transformation language. The rationale for this co-ordination language comes from the need to invoke text generation templates multiple times with various parameters, usually derived from input models. To better understand EGX, it is helpful to be familiar with template-based text generation. </p>"},{"location":"doc/egx/#epsilon-generation-language","title":"Epsilon Generation Language","text":"<p>EGL is Epsilon's model-to-text transformation language. EGL in principle is similar in purpose to server-side scripting languages like PHP (and can indeed be used for such purposes, as demonstrated in this article). To recap, a template is a text file which has both static and dynamic regions. As the name implies, a static region is where text appears as-is in the output, whereas a dynamic region uses code to generate the output, often relying on data which is only available at runtime (hence, \"dynamic\"). Dynamic regions are expressed using EOL. One can think of an EGL template as a regular text file with some EOL embedded in it, or as an EOL program with the added convenience of verbatim text generation. Indeed, it is possible to use EGL without any static regions, relying on the output buffer variable to write the output text. In EGL, the output variable is called \"out\" and the markers for the start and end of dynamic regions are <code>[%</code> and <code>%]</code> respectively. For convenience, <code>[%=</code> outputs the string value of the expression which follows. EGL has many advanced features, such as recording traceability information, post-process formatting (to ensure consistent style in the final output) and protected regions, which allow certain parts of the text to be preserved if modified by hand, rather than being overwritten on each invocation of the template. EGL can handle merges, and also supports outputting text to any output stream.</p> <p>As an example, consider a simple Library metamodel (shown below). Suppose each model may have multiple Libraries, and each Library has a name, multiple Books and Authors. Similarly, each Book has one or more Authors, and each Author has multiple Books, similar to the relation between Actors and Movies in the IMDb metamodel used in previous chapters. Now suppose we have a single monolithic model and want to transform this into multiple structured files, such as web pages (HTML) or XML documents. One possible decomposition of this is to generate a page for each Library in the model.</p> classDiagram class Library{     name: EString     id: ELong     books: Book[*] }  class Book {     title: EString     pages: EInt     ISBN: EString     authors: Author[*] }  class Author{     name: EString     books: Book[*] }  Library -- Book: books * Book -- Author: books * / authors * <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;library id=[%=lib.id%] name=\"[%=name%]\"&gt;\n[% for (book in books) {%]\n  &lt;book&gt;\n    &lt;title&gt;[%=book.title%]&lt;/title&gt;\n    &lt;isbn&gt;[%=book.isbn%]&lt;/isbn&gt;\n    &lt;pages&gt;[%=book.pages.asString()%]&lt;/pages&gt;\n    &lt;authors&gt;\n    [% for (author in book.authors) {%]\n      &lt;author name=\"[%=author.name%]\"/&gt;\n    [%}%]\n    &lt;/authors&gt;\n  &lt;/book&gt;\n[%}%]\n&lt;/library&gt;</code></pre> <p>Notice how the template refers to <code>books</code> (which is a collection of Book elements) without deriving them directly from the underlying model (i.e. there are no uses of allInstances). This is because the variables were provided to the template before invocation.</p>"},{"location":"doc/egx/#template-orchestration","title":"Template Orchestration","text":"<p>In the previous example, we stated that we want to invoke the template for all instances of Library in the model. To do this, we need to loop through all Library instances in the model(s), load the template, populate it with the required variables derived from the current Library instance and execute the template. However since we want each Library's contents to be written to a distinct XML file (perhaps identified by its name or id), we also need to set the output file for each template based on the current instance. In more complex cases, we may also want to have certain rules for whether a Library should be generated at all (e.g. if it does not have a threshold number of Books), and whether we should overwrite an existing file. For example, we may decide that for Libraries with a large number of books, we do not want to overwrite the file. Furthermore, we may want to have a different naming convention for certain libraries based on their name or ID, which may be decided based on an arbitrarily complex function. Also, we may not want to include all of the Books in the output file, but a subset, which requires additional processing logic. We may even have different templates for libraries based on the number of Books they hold \u2013 for example, with a large Library, we may want to inline all of the properties of each Book to save disk space, rather than having the title, pages, authors etc. enumerated as children. Or we may want to omit the authors. This can be achieved by modifying the template with conditionals, but this makes the template much less readable and harder to modify, so it can be easier to have a separate template instead.</p> <p>All of these factors are tedious to implement manually and can be difficult to maintain and modify by domain experts using handwritten imperative code. Therefore, a more declarative way of achieving this is needed. This is precisely the purpose of EGX.</p>"},{"location":"doc/egx/#features-and-execution-algorithm","title":"Features and Execution Algorithm","text":"<p>Like all of Epsilon's rule-based (ERL) languages, an EGX module consists of any number of named rules, as well as optional pre and post blocks which can be used to perform arbitrarily complex tasks using imperative code before and after the execution of rules, respectively. The execution algorithm of EGX is quite simple, since the language itself is essentially a means to parameterise a <code>for</code> loop. EGX adds on top of ERL only a single top-level rule construct: the <code>GenerationRule</code>. The execution algorithm is thus as simple as executing all of these rules, in the order they are defined in the module. Thus, the remainder of this section describes the components and execution semantics of <code>GenerationRule</code>. Note that since variables declared in an earlier scope (executable block) within a <code>GenerationRule</code> are visible to later blocks, the order in which the engine executes each component block is important. Thus, we summarise each component block in execution order; which should also be the order in which they are declared by the user in the program. Note also that all of the component blocks of a <code>GenerationRule</code> are optional \u2013 that is, one can use any combination of them, including all or none.</p> <ul> <li>transform: A parameter (name and type), optionally followed by the collection of elements to run the rule over. The parameter name is bound to the current element, and this rule is executed for all elements in the specified collection. If the user does not specify a domain from which the elements are drawn using the <code>in:</code> construct, the engine will retrieve all model elements matching the type (but not subtypes) of the parameter type. To include all types and subtypes of the specified parameter, rule must be marked with the <code>@greedy</code> annotation, otherwise the entire rule must be repeated for each subtype.</li> <li>guard: True by default. If this returns false, the <code>GenerationRule</code> will skip execution of the remaining blocks for the current element (or altogether if the rule has no input elements).</li> <li>pre: Arbitrary block of code, can be used to set up variables or any other pre-processing.</li> <li>overwrite: Whether to overwrite the target file if it already exists. True by default.</li> <li>merge: Whether to merge new contents with existing contents. True by default.</li> <li>append: Whether to append new contents to existing contents. False by default.</li> <li>patch: Whether to patch existing contents with new contents. False by default.</li> <li>template: The path (usually relative) and name of the template to invoke.</li> <li>parameters: Key-value pairs mapping variable names to values, which will be passed to the template. That is, the template will be populated with variable names (the keys) and values based on the provided Map.</li> <li>target: The path of the file to which the output of the template should be written.</li> <li>formatter: The <code>Formatter</code> implementation to post-process the output with. See the documentation on formatters for more details.</li> <li>post: Arbitrarily code block for post-processing. In addition to having access to all variable declared in previous blocks, a new variable called <code>generated</code> is also available, which is usually a reference to the generated file so the user can call any methods available on <code>java.io.File</code>. If the EGL execution engine has not been configured to output to files, or the <code>target</code> is ommitted, then this variable will be the output of the template as a String instead.</li> </ul> <p>The only other noteworthy aspect of EGX's execution algorithm is that it keeps a cache of templates which have been loaded, to avoid re-parsing and re-initialising them every time. Of course, the variables for the template are reset and rebound every time, as they may be different. The purpose of the cache is only to avoid the potentially expensive process of parsing EGL templates.</p>"},{"location":"doc/egx/#parallel-execution","title":"Parallel Execution","text":"<p>Owing to its rule-based declarative nature, EGX can execute rules independently, and even if you only have a single rule, it can be invoked on a per-element basis by separate threads. You can declare a rule to be executed in parallel using the <code>@parallel</code> annotation, or by using the automatic parallelisation execution engine.</p>"},{"location":"doc/egx/#example-programs","title":"Example Programs","text":"<p>Returning to our example, we can orchestrate the generation of Libraries as shown below, which demonstrates most of the features of EGX. Here we see how it is possible to screen eligible Library instances for generation, populate the template with the necessary parameters, invoke a different version of the template, format the output, and direct the output to the desired file, all based on arbitrary user-defined criteria expressed declaratively using EOL. We can also compute aggregate metadata thanks to the pre and post blocks available both globally and on a per-rule basis. In this example, we simply compute the size of each file and print them once all transformations have taken place. Furthermore, we demonstrate that not all rules need to transform a specific model element: EGX can be used for convenience to invoke EGL templates with parameters, as shown by the <code>AuthorsAndBooks</code> rule. Here we only want to generate a single file from the Authors and Books in the model, where the logic for doing this is in a single EGL template. Although it wouldn't make much sense to use EGX purely for invoking single templates without parameters, the reader can perhaps appreciate that in large and complex models, there may be many different templates - e.g. one for each type - so all of the co-ordination in invoking them can be centralised to a single declarative file. EGX can thus be used as a workflow language in directing model-to-text transformations and is suitable for various use cases of almost any complexity.</p> <pre><code>operation Book isValid() : Boolean {\n  return self.isbn.isDefined() and self.isbn.length() == 13;\n}\n\npre {\n  var outDirLib : String = \"../libraries/\";\n  var libFileSizes = new Map;\n  var xml = new Native(\"org.eclipse.epsilon.egl.formatter.language.XmlFormatter\");\n}\n\nrule Lib2XML transform lib : Library {\n  guard : lib.name.length() &gt; 3 and lib.books.size() &gt; 10\n  pre {\n    var eligibleBooks = lib.books.select(b | b.isValid());\n    var isBigLibrary = eligibleBooks.size() &gt; 9000;\n  }\n  merge : isBigLibrary\n  overwrite : not isBigLibrary\n  template {\n    var libTemplate = \"rel/path/to/Lib2XML\";\n    if (isBigLibrary) {\n      libTemplate += \"_minified\";\n    }\n    return libTemplate + \".egl\";\n  }\n  parameters : Map {\n    \"name\" = lib.name,\n    \"id\" = lib.id,\n    \"books\" = lib.books\n  }\n  target {\n    var outFile = outDirLib + lib.name;\n    if (isBigLibrary) {\n      outFile += \"_compact\";\n    }\n    return outFile + \".xml\";\n  }\n  formatter : xml\n  post {\n    libFileSizes.put(generated.getName(), generated.length());\n  }\n}\n\nrule AuthorsAndBooks {\n  parameters : Map {\n    \"authors\" = Authors.allInstances(),\n    \"books\" = Book.allInstances()\n  }\n  template : \"AuthorsAndBooks.egl\"\n  target : \"AllAuthorsBooks.txt\"\n}\n\npost {\n  libFileSizes.println();\n    (\"Total: \"+libFileSizes.values().sum()).println();\n}</code></pre> <p>The previous example demonstrated the use of model-to-text transformations over Library model elements. However, there may be scenarios in which one would like to use model-to-text transformations over the items of a list. This is particularly useful when the list has been populated by other model-to-text transformations. The following example will generate a text file for each item in the <code>files</code> list, and the content of each file is specified by the <code>data</code> map.</p> <pre><code>pre {\n  var files = Sequence{\"file1\", \"file2\", \"file3\"};\n  var data = Map {\n    \"file1\" = \"Content of the first file\",\n    \"file2\" = \"Content of the second file\",\n    \"file3\" = \"Content of the third file\"\n  };\n}\n\nrule ItemToFile transform file: String in: files {\n    parameters : Map {\"content\" = data.get(file)}\n    target : file + \".txt\"\n    template: \"file.egl\"\n}</code></pre>"},{"location":"doc/egx/#additional-resources","title":"Additional Resources","text":"<p>Additional resources about EGL/EGX are available here.</p>"},{"location":"doc/emc/","title":"The Epsilon Model Connectivity Layer (EMC)","text":"<p>The Epsilon Model Connectivity (EMC) layer provides abstraction facilities over concrete modelling technologies such as EMF, XML, Simulink etc. and enables Epsilon programs to interact with models conforming to these technologies in a uniform manner. A graphical overview of the core classes and methods of EMC is displayed below.</p> <p>Tip</p> <p>If you are interested in examples of EMC-based drivers for Epsilon, rather than on the organisation of EMC itself, please scroll to the bottom of this page.</p> classDiagram class IModel {     -name: String     -aliases: String[*]     +load()     +load(properties : StringProperties)     +store()     +getAllOfKind(type: String): Object[*]     +isKindOf(element: Object, type: String): boolean     +getAllOfType(type: String): Object[*]     +isTypeOf(element: Object, type: String): boolean     +createInstance(type: String): Object     +deleteElement(element: Object) }  class ModelRepository {     +getOwningModel(modelElement: Object)     +getModelByName(name: String)     +dispose() }  class IPropertyGetter {     +invoke(object: Object, property: String) }  class IPropertySetter {     +invoke(object: Object, property: String, value: Object) }  ModelRepository -- IModel: models * ModelGroup -- IModel: models * IModel &lt;|-- ModelGroup IModel -- IPropertySetter: propertySetter IModel -- IPropertyGetter: propertyGetter <p>To abstract away from diverse model representations and APIs provided by different modelling technologies, EMC defines the IModel interface. IModel provides a number of methods that enable querying and modifying the model elements it contains at a higher level of abstraction. To enable languages and tools that build atop EMC to manage multiple models simultaneously, the ModelRepository class acts as a container that offers fa\u00e7ade services. The following sections discuss these two core concepts in detail.</p>"},{"location":"doc/emc/#the-imodel-interface","title":"The IModel interface","text":"<p>Each model specifies a name which must be unique in the context of the model repository in which it is contained. Also, it defines a number of aliases; that is non-unique alternate names; via which it can be accessed. The interface also defines the following services.</p>"},{"location":"doc/emc/#loading-and-persistence","title":"Loading and Persistence","text":"<p>The load() and load(properties : Properties) methods enable extenders to specify in a uniform way how a model is loaded into memory from the physical location in which it resides. Similarly, the store() and store(location : String) methods are used to define how the model can be persisted from memory to a permanent storage location.</p>"},{"location":"doc/emc/#type-related-services","title":"Type-related Services","text":"<p>The majority of metamodelling architectures support inheritance between meta-classes and therefore two types of type-conformance relationships generally appear between model elements and types. The type-of relationship appears when a model element is an instance of the type and the kind-of relationship appears when the model element is an instance of the type or any of its sub-types. Under this definition, the getAllOfType(type: String) and the getAllOfKind(type: String) operations return all the elements in the model that have a type-of and a kind-of relationship with the type in question respectively.</p> <p>Similarly, the isTypeOf(element: Object, type : String) and isKindOf(element: Object, type : String) return whether the element in question has a type-of or a kind-of relationship with the type respectively. The getTypeOf(element: Object) method returns the fully-qualified name of the type an element conforms to.</p> <p>The hasType(type: String) method returns true if the model supports a type with the specified name. To support technologies that enable users to define abstract (non-instantiable) types, the isInstantiable(type: String) method returns if instances of the type can be created.</p>"},{"location":"doc/emc/#ownership","title":"Ownership","text":"<p>The allContents() method returns all the elements that the model contains and the owns(element: Object) method returns true if the element under question belongs to the model.</p>"},{"location":"doc/emc/#creation-deletion-and-modifications","title":"Creation, Deletion and Modifications","text":"<p>Model elements are created and deleted using the createInstance(type: String) and deleteElement(element: Object) methods respectively.</p> <p>To retrieve and set the values of properties of its model elements, IModel uses its associated propertyGetter (IPropertyGetter) and propertySetter (IPropertySetter) respectively. Technology-specific implementations of those two interfaces are responsible for accessing and modifying the value of a property of a model element through their invoke(element: Object, property : String) and invoke(value: Object) respectively.</p>"},{"location":"doc/emc/#the-modelrepository-class","title":"The ModelRepository class","text":"<p>A model repository acts as a container for a set of models that need to be managed in the context of a task or a set of tasks. Apart from a reference to the models it contains, ModelRepository also provides the following fa\u00e7ade functionality.</p> <p>The getOwningModel(element: Object) method returns the model that owns a particular element. The transactionSupport property specifies an instance of the ModelRepositoryTransactionSupport class which is responsible for aggregate management of transactions by delegating calls to its startTransaction(), commitTransaction() and abortTransaction() methods, to the respective methods of instances of IModelTransactionSupport associated with models contained in the repository.</p>"},{"location":"doc/emc/#the-modelgroup-class","title":"The ModelGroup class","text":"<p>A ModelGroup is a group of models that have a common alias. ModelGroups are calculated dynamically by the model repository based on common model aliases. That is, if two or more models share a common alias, the repository forms a new model group. Since ModelGroup implements the IModel interface, clients can use all the methods of IModel to perform aggregate operations on multiple models, such as collecting the contents of more than one models. An exception to that is the createInstance(type: String) method which cannot be defined for a group of models as it cannot be determined in which model of the group the newly created element should belong.</p>"},{"location":"doc/emc/#assumptions-about-the-underlying-modelling-technologies","title":"Assumptions about the underlying modelling technologies","text":"<p>The discussion provided above has demonstrated that EMC makes only minimal assumptions about the structure and the organization of the underlying modelling technologies. Thus, it intentionally refrains from defining classes for concepts such as model element, type and metamodel. By contrast, it employs a lightweight approach that uses primitive strings for type names and objects of the target implementation platforms as model elements. There are two reasons for this decision.</p> <ul> <li> <p>The primary reason is that by minimizing the assumptions about the underlying technologies EMC becomes more resistant to future changes of the implementations of the current technologies and can also embrace new technologies without changes.</p> </li> <li> <p>Another reason is that if a heavy-weight approach was used, extending the platform with support for a new modelling technology would involve providing wrapping objects for the native objects which represent model elements and types in the specific modelling technology. Experiments in the early phases of the design of EMC demonstrated that such a heavy-weight approach significantly increases the amount of memory required to represent the models in memory, degrades performance and provides little benefits in reward.</p> </li> </ul>"},{"location":"doc/emc/#emc-drivers","title":"EMC Drivers","text":"<p>Below are known drivers that implement the EMC interfaces discussed above and allow Epsilon programs to access different types of models and structured data.</p>"},{"location":"doc/emc/#eclipse-modeling-framework","title":"Eclipse Modeling Framework","text":"<p>The Eclipse Modelling Framework (EMF) is one of the most robust and widely used open-source modelling frameworks, and the cornerstone of an extensive ecosystem of technologies for graphical/textual model editing, model comparison and merging etc. Being an Eclipse project, Epsilon naturally provides support for all flavours of EMF models (e.g. textual, graphical, XSD-based XML), and most of the screencasts, articles and examples in Epsilon's Git repository use EMF models. Epsilon can also connect to CDO repositories of EMF models.</p>"},{"location":"doc/emc/#matlab-simulink","title":"Matlab Simulink","text":"<p>Epsilon also provides mature support for querying and modifying Matlab Simulink models as shown in these articles.</p>"},{"location":"doc/emc/#cameo-magicdraw-systems-modeler","title":"Cameo / MagicDraw Systems Modeler","text":"<p>Cameo Systems Modeler is a widely-used graphical systems modelling tool. A driver that allows Epsilon programs to read/write Cameo models is available under EpsilonLabs on GitHub.</p>"},{"location":"doc/emc/#csv-excel-json-xml-yaml","title":"CSV / Excel / JSON / XML / YAML","text":"<p>For quick and dirty metamodel-less modelling, Epsilon also supports CSV files, Excel spreadsheets, JSON documents, plain XML documents, and YAML files.</p>"},{"location":"doc/emc/#eclipse-hawk","title":"Eclipse Hawk","text":"<p>Hawk is an Eclipse project that provides tools for monitoring, indexing and querying repositories (i.e. local folders, Eclipse workspaces, Git/SVN repositories) containing models. Hawk provides an EMC driver through which model indices can be queried with Epsilon languages.</p>"},{"location":"doc/emc/#other-drivers","title":"Other Drivers","text":"<p>There are also less mature/well-documented drivers for Epsilon for tools and formats such as:</p> <ul> <li>ArgoUML</li> <li>Connected Data Objects (CDO)</li> <li>Eclipse C/C++ Development Tools</li> <li>Eclipse Java Development Tools</li> <li>MagicDraw / Cameo Systems Modeler</li> <li>MetaEdit+</li> <li>NeoEMF</li> <li>PTC Integrity Modeller</li> <li>Relational Databases (JDBC)</li> </ul> <p>These drivers have not had much external use historically, but if you're interested in them, please give us a shout.</p>"},{"location":"doc/emg/","title":"The Epsilon Model Generation Language (EMG)","text":"<p>At some point, programs written in any of the Epsilon model management languages might need to be tested in order to find defects (bugs) and assert their correctness, or benchmarked in order to assess their performance. Both testing and benchmarking activities require appropriate test data, i.e. models that conform to specific metamodels and their constraints, satisfy additional requirements or characteristics (e.g. certain size), and/or contain data and provide a structure that exercises particular aspects of the program under test.</p> <p>Manual assembly of test models is an error prone, time and labour consuming activity. This type of activities are perfect candidates for automation. Given that it is also a model management activity, it follows that the automation can be provided by a model generation engine that can execute model generation scripts. The scripts should be written in a model generation language that allows the user to generate models that conform to specific metamodels and its arbitrarily complex constraints (e.g constraints formulated in compound first-order OCL operations), satisfy particular characteristics, and contain specific data and exhibit particular structures. The model generation engine should exhibit characteristics such as randomness, repeatability, scalability and easy parametrization. The Epsilon Model Generation Language addresses the automated generation of complex models.</p>"},{"location":"doc/emg/#approaches-to-model-generation","title":"Approaches to Model Generation","text":"<p>The model generation approaches found in literature provide fully-automated behaviour. In a fully-automated approach, the tool loads the metamodel (and in some cases its constraints) and generates models that conform to the metamodel (and satisfy the constraints, if constraints are supported). However, the existing solutions can generate invalid models and in the case where constraints are supported, only simple constraints are supported.</p> <p>The Epsilon Model Generation follows a semi-automated generation approach. There are three main tasks in model generation:</p> <ul> <li> <p>Create instances of types in the metamodel(s).</p> </li> <li> <p>Assign values to the instance's attributes (properties typed by primitive types: String, Integer, etc.).</p> </li> <li> <p>Create links between instances to assign values to references (properties typed by complex types: other types in the metamodel).</p> </li> </ul> <p>In the semi-automated approach, all of these tasks can be configured to execute statically or dynamically (with randomness). Statically, the user must specify every single aspect of the generation. Dynamically, for example, the number of instances to create of a given type can be random, or the value of a given attribute can be set to random values, or the links between elements can be done between random pairs of elements. The combination of random and static definition of the generation tasks allows the user to generate models that can satisfy complex constraints, guarantee additional characteristics and exercise particular aspects of the program under test.</p> <p>This chapter discusses the concrete syntax of EMG as well as its execution semantics. To aid understanding, the discussion of the syntax and the semantics of the language revolves around an exemplar generation which is developed incrementally throughout the chapter.</p>"},{"location":"doc/emg/#syntax","title":"Syntax","text":"<p>The EMG language does not provide additional syntax. Instead it provides a set of predefined annotations that can be added to EOL operations and EPL patterns in order to perform the model generation. The predefined EOL operation annotations are:</p> Name Description instances Defines the number of instances to create. This annotation accepts one parameter. The parameter can be an expression that resolves to an Integer (e.g. literal, variable name, etc.) or a sequence in the form <code>Sequence {min, max}</code>). An integer value statically defines how many instances are to be created. A sequence defines a range that is used by the engine to generates a random number n of instances, with <code>min &lt;= n &lt;= max</code>. list Defines an identifier (listID) for a placeholder list for the elements created. This annotation accepts one parameter. The parameter is the identifier (String) that can later be used in operations that accept it as an argument in order to access the elements created by the operation. parameters If the instantiated type accepts/needs arguments for instantiation, the parameters annotation can be used to provide them. This annotation accepts one parameter. The parameter must be a Sequence that contains the desired arguments in the order expected by the constructor. <p>All three annotations are executable and hence must be prefixed with a <code>$</code> symbol when used. Further, these annotations are only evaluated on create operations.</p> <p>The EPL pattern annotations are:</p> Name Description number This limits the number of times the pattern is matched, to constraint the number of links created between elements. This annotation accepts one parameter. The parameter can be an expression that resolves to an Integer (e.g. literal, variable name, etc.) or a sequence in the form <code>Sequence {min, max}</code>). An integer value statically defines how many instances are to be created. A sequence defines a range that is used by the engine to generates a random number n of instances, with <code>min &lt;= n &lt;= max</code>. probability This defines the probability that the body of the pattern will be executed for a matching set of elements. The effect is that not all matching elements are linked. Effectively this also limits the number of times links are created. noRepeat This forbids previous matched elements to be re-linked. <p>The first two annotations are executable and hence must be prefixed with a <code>$</code> symbol when used and the last one is a simple annotation and must be prefixed with <code>@</code>.</p> <p>Additionally the EMG engine provides a set of predefined operations that provide support for generating random data that can be used to set the attributes and references of the generated model elements, to select random elements from collections, etc.</p>"},{"location":"doc/emg/#emg-predefined-operations","title":"EMG predefined operations","text":"Signature Description nextAddTo(n : Integer, m : Integer): Sequence(Integer) Returns a sequence of n integers who's sum is equal to m. nextBoolean() Returns the next pseudorandom, uniformly distributed <code>boolean</code> value. nextCamelCaseString(length : Integer, minWordLength : Integer) : String Generates a string of the given length formatted as CamelCase, with subwords of a minimum length of the minWordLength argument. nextCapitalisedString(charSet : String, length : Integer) : String Generates a Capitalized string of the given length using characters from the given charSet. nextFromCollection(c : Sequence) : Any Returns the next <code>object</code> from the collection, selected pseudorandomly using the uniform distribution. If the collection is empty, returns null. nextFromList(listID : String) : Any Returns the next <code>object</code> from the list, selected pseudorandomly using the uniform distribution. If the list is empty, returns null. The listID can either be a name defined by the <code>@list</code> annotation or a parameter name from the run configuration. In the latter case, the parameter value can be either a comma separated string or a file path. If it is a comma separated string, then a list is created by splitting the string; if the value is a path, then the file will be read and each line will be treated as a list element. nextFromListAsSample(listID : String) : Any Same as nextFromList, but in this case the list is treated as a sample without replacement, i.e. each call will return a unique member of the list. nextHttpURI(addPort : Boolean, addPath : Boolean, addQuery : Boolean, addFragment : Boolean) : String Generates a random URI that complies to <code>http:[//host[:port]][/]path [?query][#fragment]</code>. The path, query and fragment parts are optional and will be added if the respective argument is True. nextInt() : Integer Returns the next pseudorandom, uniformly distributed integer. All <code>2^32</code> possible integer values should be produced with (approximately) equal probability. nextInt(upper : Integer) : Integer Returns a pseudorandom, uniformly distributed integer value between 0 (inclusive) and upper (exclusive). The argument must be positive. nextInteger(upper : Integer) : Integer Alias for <code>nextInt(upper : Integer)</code>. nextInteger(lower: Integer, upper : Integer) : Integer Returns a pseudorandom, uniformly distributed integer value between lower and upper (endpoints included). The arguments must be positive and <code>upper &gt;= lower</code>. nextReal() : Real Returns the next pseudorandom, uniformly distributed <code>real</code> value between <code>0.0</code> and <code>1.0</code>. nextReal(upper : Real) : Real Returns the next pseudorandom, uniformly distributed <code>real</code> value between <code>0.0</code> and upper (inclusive). nextReal(lower: Real, upper : Real) : Real Returns a pseudorandom, uniformly distributed <code>real</code> value between lower and upper (endpoints included). nextSample(c : Sequence, k : Integer) : Sequence(Any) Returns a Sequence of <code>k</code> objects selected randomly from the Sequence <code>c</code> using a uniform distribution. Sampling from <code>c</code> is without replacement; but if c contains identical objects, the sample may include repeats. If all elements of <code>c</code> are distinct, the resulting object collection represents a Simple Random Sample of size <code>k</code> from the elements of <code>c</code>. nextSample(listID : String, k : Integer) : Sequence(Any) Same as nextSample but the sequence is referenced by listID. The listID has the same meanings as for operation nextFromList. nextString() : String Returns the next string made up from characters of the <code>LETTER</code> character set, pseudorandomly selected with a uniform distribution. The length of the string is between 4 and 10 characters. nextString(length : Integer) : String Returns the next String made up from characters of the <code>LETTER</code> character set, pseudorandomly selected with a uniform distribution. The length of the String is equal to length. nextString(charSet : String, length : Integer) : String Returns the next String of the given length using the specified character set, pseudorandomly selected with a uniform distribution. nextURI() : String Generates a random URI that complies to: <code>scheme:[//[user:password]host[:port]][/]path [?query][#fragment]</code>. The port, path, query and fragment are added randomly. The scheme is randomly selected from: http, ssh and ftp. For ssh and ftp, a user and pasword are randomly generated. The host is generated from a random string and uses a top-level domain. The number of paths and queries are random between 1 and 4. nextURI(addPort : Boolean, addPath : Boolean, addQuery : Boolean, addFragment : Boolean) : String Same as nextURI, but the given arguments control what additional port, path, query and fragment information is added. nextUUID() : String Returns a type 4 (pseudorandomly generated) UUID. The UUID is generated using a cryptographically strong pseudorandom number generator. nextValue() : Real Returns the next pseudorandom value, picked from the configured distribution (by default the uniform distribution is used). nextValue(d : String, p : Sequence) : Real Returns the next pseudorandom, from the provided distribution <code>d</code>. The parameters <code>p</code> are used to configure the distribution (if required). The supported distributions are: Binomial, Exponential and Uniform. For Binomial parameters are: numberOfTrials and probabilityOfSuccess. For Exponential, the mean. For Uniform, the lower and upper values (lower inclusive). setNextValueDistribution(d : String, p : Sequence) Define the distribution to use for calls to nextValue(). Parameters are the same as for nextValue(d, p)."},{"location":"doc/emg/#character-sets-for-string-operations","title":"Character Sets for String operations","text":"<p>For the operations that accept a character set, the supported sets are defined as follows:</p> Name Characters ID abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 NUMERIC 1234567890 LETTER abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ LETTER_UPPER ABCDEFGHIJKLMNOPQRSTUVWXYZ LETTER_LOWER abcdefghijklmnopqrstuvwxyz UPPER_NUM ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 LOWER_NUM abcdefghijklmnopqrstuvwxyz 1234567890 ID_SYMBOL abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 ~{}!@#\\$%\\^&amp;( ) _+-=[] \\|;': \\\" \\&lt; &gt; ? , . /\\ HEX_LOWER abcdef1234567890 HEX_UPPER ABCDEF1234567890"},{"location":"doc/emg/#creating-model-elements","title":"Creating Model Elements","text":"<p>The EMG engine will search for EOL operations that follow a particular signature in order to determine what elements to create in the generated model. The signature is: <code>create &lt;OutputType&gt; () { ... }</code>. That is, the operation must be named create, the operation's context type defines the type of the created instance and no parameters should be passed. By default the create operation only creates one instance. Hence, the provided annotations can be used to tailor the behaviour of the operation.</p> <p>Consider the case of the PetriNet metamodel in the figure below. </p> classDiagram class Element {     +name: String } class Place {     +outgoing: PlaceToTransArc[*]     +incoming: TransToPlaceArc[*] } class PetriNet {     +places: Place[*]     +transitions: Transition[*]     +arcs: Arc[*] } class Transition {     +incoming: PlaceToTransArc[*]     +outgoing: TransToPlaceArc[*] } class TransToPlaceArc {     +source: Transition     +target: Place } class PlaceToTransArc {     +target: Transition     +source: Place } Element &lt;|-- PetriNet Element &lt;|-- Place Transition --|&gt; Element PetriNet *-- Arc PetriNet *-- Place PetriNet *-- Transition Arc &lt;|-- TransToPlaceArc Arc &lt;|-- PlaceToTransArc <p>The code excerpt displayed below creates a PetriNet and then adds some places and transitions to it. Note that the instances annotation is executable and hence you can use absolute values, variables or expressions. The <code>list</code> annotation in the PetriNet creation will result in all PetriNet instances to be stored in a sequence called net. The list name is then used in the Place and Transition create operations to add the places and transitions to a random (nextFromList) PetriNet. In this example there is only one, but we could easily create more PetriNet instances and hence have them contain random number of Places and Transitions. The name of the elements is generated using the random string generation facilities.</p> <pre><code>pre {\n    var num_p = 10\n}\n\n$instances 1\n@list net\noperation PetriNet create() {\n    self.name = nextCamelCaseWords(\"LETTER_LOWER\", 15, 10);\n}\n\n$instances num_p\noperation Place create() {\n    self.name = \"P_\" + nextString(\"LETTER_LOWER\", 15);\n    nextFromList(\"net\").transitions.add(self);\n}\n\n$instances num_p / 2\noperation Transition create() {\n    self.name = \"T_\" + nextString(\"LETTER_LOWER\", 15);\n    nextFromList(\"net\").transitions.add(self);\n}</code></pre>"},{"location":"doc/emg/#creating-model-links","title":"Creating Model Links","text":"<p>In the previous section, the places and transitions references of the PetriNet were defined during the creation of the Place and Transition elements. For more complex reference patterns, EMG leverages the use of EPL patterns. For example, Arcs can have complex constraints in order to determine the source and target transition/place, and possibly even having separate rules for each type of Arc.</p> <p>The EPL pattern in the listing below creates two arcs in order to connect a source and a target Place via a Transition. The pattern matches all transitions in a given PetriNet. The pattern body selects a random Place for the source and a random Place for the target (the while loops are used to pick places that have the lowest incoming/outgoing arcs possible). The weight of the arc is generated randomly from 0 to 10 (nextInt(10)). The pattern has been annotated with the <code>@probability</code> annotation which will effectively only use 70% of the transitions to create arcs (i.e. of all the possible PetriNet-Transition matches, the code of the pattern will only be executed with a probability of 0.70).</p> <pre><code>@probability 0.7\npattern Transition\nnet:PetriNet,\ntra:Transition\nfrom: net.transitions {\n    onmatch {\n        var size = 0;\n        var freeSources = Place.all().select(s | s.incoming.size() == size);\n        while (freeSources.isEmpty()) {\n            size += 1;\n            freeSources = Place.all().select(s | s.incoming.size() == size);\n        }\n        size = 0;\n        var freeTarget = Place.all().select(s | s.outgoing.size() == size);\n        while (freeTarget.isEmpty()) {\n            size += 1;\n            freeTarget = Place.all().select(s | s.outgoing.size() == size);\n        }\n        var source = nextFromCollection(freeSources);\n        var target = nextFromCollection(freeTarget);\n        var a1:Arc = new PlaceToTransArc();\n        a1.weight = nextInt(10);\n        a1.source = source;\n        net.places.add(source);\n        a1.target = tra;\n        net.arcs.add(a1);\n        var a2:Arc = new TransToPlaceArc();\n        a1.weight = nextInt(10);\n        a2.source = tra;\n        a2.target = target;\n        net.places.add(target);\n        net.arcs.add(a2);\n    }\n}</code></pre>"},{"location":"doc/emg/#meaningful-strings","title":"Meaningful Strings","text":"<p>In some scenarios having completely random Strings for some of the element fields might not be desirable. In this case EMG has an embedded mechanism to facilitate the use of meaningful attribute values (not only for Strings) and we show a second approach based on additional models.</p>"},{"location":"doc/emg/#values-as-a-parameter","title":"Values as a parameter","text":"<p>The nextFromList() operation will first look for a list with that name, if it can't find it will look for a parameter (from the run configuration) with that name. The value of the parameter can be either an absolute path to a file or a comma separated list of values.</p> <p>If it is a comma separated list of values, then the individual values will be loaded as a Collection. For example, if we added the parameter <code>names: John, Rose, Juan, Xiang, Joe</code> to the run configuration, the listing below shows how to use that information to define the instance attributes.</p> <pre><code>$instances num_p\noperation Place create() {\n    self.name = nextFromList(\"name\");\n    nextFromList(\"net\").transitions.add(self);\n}</code></pre> <p>If it is a file path, then each line of the file will be loaded as an item to the Collection. Note that the distinction between paths and comma separated values is the assumption that paths don't contain commas.</p>"},{"location":"doc/emg/#values-as-a-model","title":"Values as a model","text":"<p>A more powerful approach would be to use an existing model to serve as the source for attribute values. Given that there are several websites1 to generate random data in the form of CSV files, we recommend the use of a CSV model to serve as an attribute value source. A CSV file with name, lastName, and email can be easily generated and loaded as a second model in the EMG script. Then, a Row of data can be picked randomly to set an element's attributes. The listing below shows this approach.</p> <pre><code>$instances num_p\noperation Person create() {\n    var p = nextFromCollection(dataModel.Row.all());\n    self.name = p.name;\n    self.lastName = p.lastName;\n    self.email = p.email;\n}</code></pre> <p>Note that in this case, by using different rows for each value you can further randomize the data.</p> <ol> <li> <p>https://www.mockaroo.com/, https://www.generatedata.com/, www.freedatagenerator.com/, etc.\u00a0\u21a9</p> </li> </ol>"},{"location":"doc/eml/","title":"The Epsilon Merging Language (EML)","text":"<p>The aim of EML is to contribute model merging capabilities to Epsilon. More specifically, EML can be used to merge an arbitrary number of input models of potentially diverse metamodels and modelling technologies. This section provides a discussion on the abstract and concrete syntax of EML, as well as its execution semantics. It also provides two examples of merging homogeneous and heterogeneous models.</p>"},{"location":"doc/eml/#abstract-syntax","title":"Abstract Syntax","text":"<p>In EML, merging specifications are organized in modules (EmlModule). As displayed below, EmlModule inherits from EtlModule.</p> classDiagram class MergeRule {     -name: String     -abstract: Boolean     -lazy: Boolean     -primary: Boolean     -greedy: Boolean     -guard: ExecutableBlock&lt;Boolean&gt;     -compare: ExecutableBlock&lt;Boolean&gt;     -do: ExecutableBlock&lt;Void&gt; } class Parameter {     -name: String     -type: EolType  } class NamedStatementBlockRule {     -name: String     -body: StatementBlock } EolModule &lt;|-- ErlModule EtlModule &lt;|-- EmlModule Pre --|&gt; NamedStatementBlockRule Post --|&gt; NamedStatementBlockRule EtlModule &lt;|-- ErlModule ErlModule -- Pre: pre * ErlModule -- Post: post * EmlModule -- MergeRule: rules * MergeRule -- Parameter: left MergeRule -- Parameter: right MergeRule -- Parameter: target MergeRule -- MergeRule: extends * <p>By extending EtlModule, an EML module can contain a number of transformation rules and user-defined operations. An EML module can also contain one or more merge rules as well as a set of pre and post named EOL statement blocks. As usual, pre and post blocks will be run before and after all rules, respectively.</p> <p>Each merge rule defines a name, a left, a right, and one or more target parameters. It can also extend one or more other merge rules and be defined as having one or more of the following properties: abstract, greedy, lazy and primary.</p>"},{"location":"doc/eml/#concrete-syntax","title":"Concrete Syntax","text":"<p>The listing below demonstrates the concrete syntax of EML merge-rules.</p> <pre><code>(@abstract)?\n(@lazy)?\n(@primary)? (@greedy)? \nrule &lt;name&gt;\n    merge &lt;leftParameter&gt;\n    with &lt;rightParameter&gt;\n    into (&lt;targetParameter&gt;(, &lt;targetParameter&gt;)*)? \n        (extends &lt;ruleName&gt;(, &lt;ruleName&gt;)*)? {\n\n    statementBlock\n\n}\n</code></pre> <p>Pre and post blocks have a simple syntax that consists of the identifier (pre or post), an optional name and the set of statements to be executed enclosed in curly braces.</p> <pre><code>(pre|post) &lt;name&gt; {\n    statement+\n}\n</code></pre>"},{"location":"doc/eml/#execution-semantics","title":"Execution Semantics","text":""},{"location":"doc/eml/#rule-and-block-overriding","title":"Rule and Block Overriding","text":"<p>An EML module can import a number of other EML and ETL modules. In this case, the importing EML module inherits all the rules and pre/post blocks specified in the modules it imports (recursively). If the module specifies a rule or a pre/post block with the same name, the local rule/block overrides the imported one respectively.</p>"},{"location":"doc/eml/#rule-scheduling","title":"Rule Scheduling","text":"<p>When an EML module is executed, the pre blocks are executed in the order in which they have been defined.</p> <p>Following that, for each match of the established matchTrace the applicable non-abstract, non-lazy merge rules are executed. When all matches have been merged, the transformation rules of the module are executed on all applicable elements - that have not been merged - in the models.</p> <p>Finally, after all rules have been applied, the post blocks of the module are executed.</p>"},{"location":"doc/eml/#rule-applicability","title":"Rule Applicability","text":"<p>By default, for a merge-rule to apply to a match, the left and right elements of the match must have a type-of relationship with the leftParameter and rightParameter of the rule respectively. This can be relaxed to a kind-of relationship by specifying that the merge rule is greedy (using the \\@greedy annotation in terms of concrete syntax).</p>"},{"location":"doc/eml/#source-elements-resolution","title":"Source Elements Resolution","text":"<p>As with model transformation, in model merging it is often required to resolve the counterparts of an element of a source model into the target models. In EML, this is achieved by overloading the semantics of the equivalents() and equivalent() operations defined by ETL. In EML, in addition to inspecting the transformation trace and invoking any applicable transformation rules, the equivalents() operation also examines the mergeTrace (displayed in the figure below) that stores the results of the application of merge-rules and invokes any applicable (both lazy and non-lazy) rules.</p> <p>Similarly to ETL, the order of the results of the equivalents() operation respects the order of the (merge or transform) rules that have produced them. An exception to that occurs if one of the rules has been declared as primary, in which case its results are prepended to the list of elements returned by equivalent.</p> classDiagram class Merge {     -left: Object     -right: Object     -targets: Object[*] } EtlContext &lt;|-- EmlContext EmlContext -- MatchTrace: matchTrace MergeTrace -- EmlContext: mergeTrace MergeTrace -- Merge: merges * Merge -- MergeRule"},{"location":"doc/eml/#homogeneous-model-merging-example","title":"Homogeneous Model Merging Example","text":"<p>In this scenario, two models conforming to the Graph metamodel need to be merged. The first step is to compare the two graphs using the ECL module below.</p> <pre><code>rule MatchNodes\n    match l : Left!Node\n    with r : Right!Node {\n\n    compare : l.label = r.label\n}\n\nrule MatchEdges\n    match l : Left!Edge\n    with r : Right!Edge {\n\n    compare : l.source.matches(r.source)\n        and l.target.matches(r.target)\n}\n\nrule MatchGraphs\n    match l : Left!Graph\n    with r : Right!Graph {\n\n    compare : true\n}</code></pre> <p>The MatchNodes rule in line 1 defines that two nodes match if they have the same label. The MatchEdges rule in line 8 specifies that two edges match if both their source and target nodes match (regardless of whether the labels of the edges match or not as it is assumed that there can not be two distinct edges between the same nodes). Finally, since only one instance of Graph is expected to be in each model, the MatchGraphs rule in line 16 returns true for any pair of Graphs.</p> <p>Having established the necessary correspondences between matching elements of the two models, the EML specification below performs the merge.</p> <pre><code>import \"Graphs.etl\";\n\nrule MergeGraphs\n    merge l : Left!Graph\n    with r : Right!Graph\n    into t : Target!Graph {\n\n    t.label = l.label + \" and \" + r.label;\n\n}\n\n@abstract\nrule MergeGraphElements\n    merge l : Left!GraphElement\n    with r : Right!GraphElement\n    into t : Target!GraphElement {\n\n    t.graph ::= l.graph;\n\n}\n\nrule MergeNodes\n    merge l : Left!Node\n    with r : Right!Node\n    into t : Target!Node \n    extends GraphElements {\n\n    t.label = \"c_\" + l.label;\n\n}\nrule MergeEdges\n    merge l : Left!Edge\n    with r : Right!Edge\n    into t : Target!Edge \n    extends GraphElements {\n\n    t.source ::= l.source;\n    t.target ::= l.target;\n\n}</code></pre> <p>In line 3, the MergeGraphs merge rule specifies that two matching Graphs (l and r) are to be merged into one Graph t in the target model that has as a label, the concatenation of the labels of the two input graphs separated using 'and'. The mergeNodes rule In line 22 specifies that two matching Nodes are merged into a single Node in the target model. The label of the merged node is derived by concatenating the c (for common) static string with the label of the source Node from the left model. Similarly, the MergeEdges rule specifies that two matching Edges are merged into a single Edge in the target model. The source and target nodes of the merged Edge are set to the equivalents (::=) of the source and target nodes of the edge from the left model.</p> <p>To reduce duplication, the MergeNodes and MergeEdges rules extend the abstract MergeGraphElements rule specified in line 13 which assigns the graph property of the graph element to the equivalent of the left graph.</p> <p>The rules displayed above address only the matching elements of the two models. To also copy the elements for which no equivalent has been found in the opposite model, the EML module imports the ETL module below.</p> <pre><code>rule TransformGraph \n    transform s : Source!Graph\n    to t : Target!Graph {\n\n    t.label = s.label;\n\n}\n\n@abstract\nrule TransformGraphElement \n    transform s : Source!GraphElement\n    to t : Target!GraphElement {\n\n    t.graph ::= s.graph;\n}\n\nrule TransformNode\n    transform s : Source!Node\n    to t : Target!Node \n    extends TransformGraphElement {\n\n    t.label = s.graph.label + \"_\" + s.label;\n}\n\nrule TransformEdge \n    transform s : Source!Edge\n    to t : Target!Edge \n    extends TransformGraphElement {\n\n    t.source ::= s.source;\n    t.target ::= s.target;  \n} </code></pre> <p>The rules of the ETL module apply to model elements of both the Left and the Right model as both have been aliased as Source. Of special interest is the TransformNode rule in line 17 that specifies that non-matching nodes in the two input models will be transformed into nodes in the target model the labels of which will be a concatenation of their input graph and the label of their counterparts in the input models.</p> <p>Executing the ECL and EML modules on the exemplar models displayed in the following two figures creates the target model of the final figure.</p> <p>graph LR     n1 --&gt; n2     n1 --&gt; n3     n3 --&gt; n5     n2 --&gt; n4 Left model</p> <p>graph LR     n1 --&gt; n8     n1 --&gt; n6     n8 --&gt; n6     n6 --&gt; n3 Right model</p> <p>graph LR     c_n1 --&gt; g1_n2     g1_n2 --&gt; c_n4     c_n1 --&gt; g2_n8     g2_n8 --&gt; g2_n6     c_n1 --&gt; g2_n6     c_n1 --&gt; c_n3     c_n3 --&gt; g1_n5     g2_n6 --&gt; c_n3 Merged model</p>"},{"location":"doc/eol/","title":"The Epsilon Object Language (EOL)","text":"<p>EOL is the core expression language of Epsilon, and the foundation for task-specific languages for tasks such as model-validation, model-to-text transformation, model-to-model transformation and model migration. EOL can also be used as a general-purpose standalone model management language for automating tasks that do not fall into the patterns targeted by task-specific languages.</p> <p>Try EOL online</p> <p>You can run and fiddle with an EOL program that queries a project scheduling model in the online Epsilon Playground.</p>"},{"location":"doc/eol/#syntax","title":"Syntax","text":"<p>EOL programs are organized in <code>modules</code>. Each module defines a <code>body</code> and a number of <code>operations</code>. The body is a block of statements that are evaluated when the module is executed. Each operation defines the kind of objects on which it is applicable (<code>context</code>), a <code>name</code>, a set of <code>parameters</code> and optionally a <code>return type</code>. Modules can also import other modules using <code>import</code> statements and access their operations, as shown in the listing below.</p> <p><pre><code>// file imported.eol\noperation hello() {\n  \"Hello world!\".println();\n}</code></pre> <pre><code>// file importer.eol\n// We can use relative/absolute paths or platform:/ URIs\nimport \"imported.eol\";\n\nhello(); // main body\n\n// ... more operations could be placed here ...</code></pre></p> classDiagram class EolModule {   +main:StatementBlock } class ImportStatement {   +imported:EolModule } class Operation {   +name: String   +context: EolType   +parameters: Parameter[*]   +returnType: EolType } class ExecutableAnnotation {     +expression: Expression } class SimpleAnnotation {     +values: String[*] } EolModule -- ImportStatement: * EolModule -- Operation: operations * Operation -- Annotation: annotations * Operation -- StatementBlock: body EolModule -- StatementBlock: main StatementBlock -- Statement: statements * Annotation &lt;|-- ExecutableAnnotation Annotation &lt;|-- SimpleAnnotation"},{"location":"doc/eol/#user-defined-operations","title":"User-Defined Operations","text":"<p>In mainstream object oriented languages such as Java and C++, operations are defined inside classes and can be invoked on instances of those classes. EOL on the other hand is not object-oriented in the sense that it does not define classes itself, but nevertheless needs to manage objects of types defined externally to it (e.g. in metamodels). By defining the context-type of an operation explicitly, the operation can be called on instances of the type as if it was natively defined by the type.</p> <p>For example, consider the code excerpts displayed in the listings below. In the first listing, the operations <code>add1</code> and <code>add2</code> are defined in the context of the built-in <code>Integer</code> type, which is specified before their names. Therefore, they can be invoked in line 1 using the <code>1.add1().add2()</code> expression: the context (the integer <code>1</code>) will be assigned to the special variable <code>self</code>.</p> <pre><code>1.add1().add2().println();\n\noperation Integer add1() : Integer {\n  return self + 1;\n}\n\noperation Integer add2() : Integer {\n  return self + 2;\n}</code></pre> <p>On the other hand, in the following listing where no context is defined, they have to be invoked in a nested manner which follows an in-to-out direction instead of the left to right direction used by the former excerpt. As complex model queries often involve invoking multiple properties and operations, this technique is particularly beneficial to the overall readability of the code.</p> <pre><code>add2(add1(1)).println();\n\noperation add1(base : Integer) : Integer {\n  return base + 1;\n}\n\noperation add2(base : Integer) : Integer {\n  return base + 2;\n}</code></pre> <p>EOL supports polymorphic operations using a runtime dispatch mechanism. Multiple operations with the same name and parameters can be defined, each defining a distinct context type. For example, in the listing below, the statement in line 1 invokes the test operation defined in line 4, while the statement in line 2 invokes the test operation defined in line 8.</p> <pre><code>\"1\".test();\n1.test();\n\noperation String test() {\n  (self + \" is a string\").println();\n}\n\noperation Integer test() {\n  (self + \"is an integer\").println();\n}</code></pre> <p>Statements after operations are ignored</p> <p>Any loose statements after the first operation of an EOL program will be ignored by the EOL interpreter e.g. <pre><code>\"This statement will be executed\".println();\n\noperation foo() {}\n\n\"This statement won't be executed\".println();</code></pre></p> <p>Statements outside operations in imported modules are ignored</p> <p>Any statements outside operations in imported EOL modules will be ignored.</p> <p>For example, suppose you had this <code>utilities.eol</code> file: <pre><code>\"This statement will be ignored\".println();\n\noperation useful() { /* code */ }</code></pre></p> <p>If you tried to run this <code>main.eol</code> file, the above <code>println()</code> call would not be executed: <pre><code>import \"utilities.eol\";\n\nuseful();</code></pre></p>"},{"location":"doc/eol/#annotations","title":"Annotations","text":"<p>EOL supports two types of annotations: simple and executable. A simple annotation specifies a name and a set of String values while an executable annotation specifies a name and an expression. The concrete syntaxes of simple and executable annotations are displayed in the listing below.</p> <pre><code>// Simple annotation\n@name value(,value)\n\n// Executable annotation\n$name expression</code></pre> <p>Several examples for simple annotations are shown the listing below. Examples for executable annotations will be given in the following sections.</p> <pre><code>@colors red\n@colors red, blue\n@colors red, blue, green</code></pre> <p>In stand-alone EOL, annotations are supported only in the context of operations, however as discussed in the sequel, task-specific languages also make use of annotations in their constructs, each with task-specific semantics. EOL operations support three particular annotations: the <code>pre</code> and <code>post</code> executable annotations for specifying pre and post-conditions, and the <code>cached</code> simple annotation, which are discussed below.</p>"},{"location":"doc/eol/#prepost-conditions-in-user-defined-operations","title":"Pre/post conditions in user-defined operations","text":"<p>A number of <code>pre</code> and <code>post</code> executable annotations can be attached to EOL operations to specify the pre- and post-conditions of the operation. When an operation is invoked, before its body is evaluated, the expressions of the <code>pre</code> annotations are evaluated. If all of them return <code>true</code>, the body of the operation is executed, otherwise, an error is raised. Similarly, once the body of the operation has been executed, the expressions of the <code>post</code> annotations of the operation are executed to ensure that the operation has had the desired effects. <code>Pre</code> and <code>post</code> annotations can access all the variables in the parent scope, as well as the parameters of the operation and the object on which the operation is invoked (through the <code>self</code> variable). Moreover, in <code>post</code> annotations, the returned value of the operation is accessible through the built-in <code>_result</code> variable. An example of using pre and post conditions in EOL appears below.</p> <pre><code>1.add(2); \n1.add(-1);\n\n$pre i &gt; 0 \n$post _result &gt; self \noperation Integer add(i : Integer) : Integer {\n  return self + i;\n}</code></pre> <p>In line 4 the <code>add</code> operation defines a pre-condition stating that the parameter <code>i</code> must be a positive number. In line 5, the operation defines that result of the operation (<code>_result</code>) must be greater than the number on which it was invoked (<code>self</code>). Thus, when executed in the context of the statement in line 1 the operation succeeds, while when executed in the context of the statement in line 2, the pre-condition is not satisfied and an error is raised.</p>"},{"location":"doc/eol/#operation-result-caching","title":"Operation Result Caching","text":"<p>EOL supports caching the results of parameter-less operations using the <code>@cached</code> simple annotation. In the following example, the Fibonacci number of a given Integer is calculated using the <code>fibonacci</code> recursive operation displayed in the listing below. Since the <code>fibonacci</code> operation is declared as <code>cached</code>, it is only executed once for each distinct Integer and subsequent calls on the same target return the cached result. Therefore, when invoked in line 1, the body of the operation is called 16 times. By contrast, if no <code>@cached</code> annotation was specified, the body of the operation would be called recursively 1973 times. This feature is particularly useful for performing queries on large models and caching their results without needing to introduce explicit variables that store the cached results.</p> <p>It is worth noting that caching works <code>by reference</code>, which means that all clients of a cached method for a given context will receive the same returned object. As such, if the first client modifies the returned object in some way (e.g. sets a property in the case of an object or adds an element in the case of the collection), subsequent clients of the method for the same context will receive the modified object/collection.</p> <pre><code>15.fibonacci().println();\n\n@cached\noperation Integer fibonacci() : Integer {\n  if (self = 1 or self = 0) {\n    return 1;\n  }\n  else {\n    return (self-1).fibonacci() + (self-2).fibonacci();\n  }\n}</code></pre>"},{"location":"doc/eol/#types","title":"Types","text":"<p>As is the case for most programming languages, EOL defines a built-in system of types, illustrated in the figure below. The <code>Any</code> type, inspired by the <code>OclAny</code> type of OCL, is the basis of all types in EOL including Collection types.</p> classDiagram class ModelElementType {   -model: String   -type: String } class Native {   -implementation: String } ModelElementType --|&gt; Any Any &lt;|-- Native Any &lt;|-- Collection Any &lt;|-- Map Collection &lt;|-- Bag Collection &lt;|-- Set Collection &lt;|-- OrderedSet Collection &lt;|-- Sequence PrimitiveType --|&gt; Any PrimitiveType &lt;|-- Integer PrimitiveType &lt;|-- String PrimitiveType &lt;|-- Boolean PrimitiveType &lt;|-- Real  <p>The operations supported by instances of the Any type are outlined in the table below1.</p> Signature Description asBag() : Bag Returns a new Bag containing the object asBoolean() : Boolean Returns a Boolean based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asInteger() : Integer Returns an Integer based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asOrderedSet() : OrderedSet Returns a new OrderedSet containing the object asReal() : Real Returns a Real based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asDouble() : Double Returns a Java Double based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asFloat() : Float Returns a Java Float based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asSequence() : Sequence Returns a new Sequence containing the object asSet() : Set Returns a new Set containing the object asString() : String Returns a string representation of the object asVar(name : String) : Any Creates a new variable with the specified name out of the object, and returns the object err([prefix : String]) : Any Prints a string representation of the object on which it is invoked to the error stream prefixed with the optional <code>prefix</code> string and returns the object on which it was invoked. In this way, the <code>err</code> operation can be used for debugging purposes in a non-invasive manner errln([prefix : String]) : Any Has the same effects as the <code>err</code> operation but also produces a new line in the output stream. format([pattern : String]) : String Uses the provided pattern to form a String representation of the object on which the method is invoked. The pattern argument must conform to the format string syntax defined by Java2. hasProperty(name : String) : Boolean Returns true if the object has a property with the specified name or false otherwise ifUndefined(alt : Any) : Any If the object is undefined, it returns alt else it returns the object isDefined() : Boolean Returns true if the object is defined and false otherwise isKindOf(type : Type) : Boolean Returns true if the object is of the given type or one of its subtypes and false otherwise instanceOf(type : Type) : Boolean Alias for <code>isKindOf</code> isTypeOf(type : Type) : Boolean Returns true if the object is of the given type and false otherwise isUndefined() : Boolean Returns true if the object is undefined and false otherwise owningModel() : Model Returns the model that contains this object or an undefined value otherwise print([prefix : String]) : Any Prints a string representation of the object on which it is invoked to the regular output stream, prefixed with the optional <code>prefix</code> string and returns the object on which it was invoked. In this way, the <code>print</code> operation can be used for debugging purposes in a non-invasive manner println([prefix : String]) : Any Has the same effects as the <code>print</code> operation but also produces a new line in the output stream. type() : Type Returns the type of the object."},{"location":"doc/eol/#primitive-types","title":"Primitive Types","text":"<p>EOL provides four primitive types: String, Integer, Real and Boolean. The String type represents a finite sequence of characters and supports the following operations which can be invoked on its instances.</p> Signature Description characterAt(index : Integer) : String Returns the character in the specified index concat(str : String) : String Returns a concatenated form of the string with the <code>str</code> parameter endsWith(str : String) : Boolean Returns true iff the string ends with <code>str</code> escapeXml() : String Returns a new string with escaped XML-reserved characters firstToLowerCase() : String Returns a new string the first character of which has been converted to lower case ftlc() : String Alias for <code>firstToLowerCase()</code> firstToUpperCase() : String Returns a new string, the first character of which has been converted to upper case ftuc : String Alias for <code>firstToUpperCase()</code> isInteger() : Boolean Returns true iff the string is an integer isReal() : Boolean Returns true iff the string is a real number isSubstringOf(str : String) : Boolean Returns true iff the string the operation is invoked on is a substring of <code>str</code> length() : Integer Returns the number of characters in the string matches(reg : String) : Boolean Returns true if there are occurrences of the regular expression <code>reg</code> in the string pad(length : Integer, padding : String, right : Boolean) : String Pads the string up to the specified length with specified padding (e.g. <code>\"foo\".pad(5, \"*\", true)</code> returns <code>\"foo**\"</code>) replace(source : String, target : String) : String Returns a new string in which all instances of <code>source</code> have been replaced with instances of <code>target</code> split(reg : String) : Sequence(String) Splits the string using as a delimiter the provided regular expression, <code>reg</code>, and returns a sequence containing the parts startsWith(str : String) : Boolean Returns true iff the string starts with <code>str</code> substring(index : Integer) : String Returns a sub-string of the string starting from the specified <code>index</code> and extending to the end of the original string substring(startIndex : Integer, endIndex : Integer) : String Returns a sub-string of the string starting from the specified <code>startIndex</code> and ending at <code>endIndex</code> toCharSequence() : Sequence(String) Returns a sequence containing all the characters of the string toLowerCase() : String Returns a new string where all the characters have been converted to lower case toUpperCase() : String Returns a new string where all the characters have been converted to upper case trim() : String Returns a trimmed copy of the string <p>The Real type represents real numbers and provides the following operations.</p> Signature Description abs() : Real Returns the absolute value of the real ceiling() : Integer Returns the nearest Integer that is greater than the real floor() : Integer Returns the nearest Integer that is less than the real log() : Real Returns the natural logarithm of the real log10() : Real Returns the 10-based logarithm of the real max(other : Real) : Real Returns the maximum of the two reals min(other : Real) : Real Returns the minimum of the two reals pow(exponent : Real) : Real Returns the real to the power of exponent round() : Integer Rounds the real to the nearest Integer <p>The Integer type represents natural numbers and negatives and extends the Real primitive type. It also defines the following operations:</p> Signature Description iota(end : Integer, step : Integer) : Sequence(Integer) Returns a sequence of integers up to <code>end</code> using the specified step (e.g. 1.iota(10,2) returns Sequence{1,3,5,7,9}) mod(divisor : Integer) : Integer Returns the remainder of dividing the integer by the divisor to(other : Integer) : Sequence(Integer) Returns a sequence of integers (e.g. 1.to(5) returns Sequence{1,2,3,4,5}) toBinary() : String Returns the binary representation of the integer (e.g. 6.toBinary() returns \"110\") toHex() : String Returns the hexadecimal representation of the integer (e.g. 42.toBinary() returns \"2a\") <p>Finally, the Boolean type represents true/false states and provides no additional operations to those provided by the base Any type.</p>"},{"location":"doc/eol/#collections-and-maps","title":"Collections and Maps","text":"<p>EOL provides several types of collections and a Map type:</p> <ul> <li>The <code>Bag</code> type represents non-unique, unordered collections and implements the <code>java.util.Collection</code> interface.</li> <li>The <code>Sequence</code> type represents non-unique, ordered collections and implements the <code>java.util.List</code> interface.</li> <li>The <code>Set</code> type represents unique and unordered collections and implements the <code>java.util.Set</code> interface.</li> <li>The <code>OrderedSet</code> represents unique and ordered collections.</li> <li>Since version 2.0, there are also two concurrent collection types, which can safely be modified from multiple threads. These are <code>ConcurrentBag</code> and <code>ConcurrentSet</code>, which are thread-safe variants of the <code>Bag</code> and <code>Set</code> types respectively.</li> </ul> <p>All collection types inherit from the abstract <code>Collection</code> type.</p> <p>Apart from simple operations, EOL also supports logic operations on collections. The following operations (along with any operations declared on the <code>java.util.Collection</code> interface) apply to all types of collections:</p> Signature Description add(item : Any) : Boolean Adds an item to the collection. If the collection is a set, addition of duplicate items has no effect. Returns true if the collection increased in size: this is always the case for bags and sequences, and for sets and ordered sets it is true if the element was not part of the collection before. addAll(col : Collection) : Boolean Adds all the items of the <code>col</code> argument to the collection. If the collection is a set, it only adds items that do not already exist in the collection. Returns true if this collection changed as a result of the call asBag() Returns a Bag that contains the same elements as the collection. asOrderedSet() Returns a duplicate-free OrderedSet that contains the same elements as the collection. asSequence() Returns a Sequence that contains the same elements as the collection. asSet() Returns a duplicate-free Set that contains the same elements as the collection. clear() Empties the collection clone() : Collection Returns a new collection of the same type containing the same items with the original collection concat() : String Returns the string created by converting each element of the collection to a string (equivalent to the <code>join</code> method used in some other languages) concat(separator : String) : String Returns the string created by converting each element of the collection to a string, using the given argument as a separator (equivalent to the <code>join</code> method used in some other languages) count(item : Any) : Integer Returns the number of times the item exists in the collection excludes(item : Any) : Boolean Returns true if the collection excludes the <code>item</code> excludesAll(col : Collection) : Boolean Returns true if the collection excludes all the items of collection col excluding(item : Any) : Collection Returns a new collection that excludes the item -- unlike the remove() operation that removes the <code>item</code> from the collection itself excludingAll(col : Collection) : Collection Returns a new collection that excludes all the elements of the col collection flatten() : Collection Recursively flattens all items that are of collection type and returns a new collection where no item is a collection itself includes(item : Any) : Boolean Returns true if the collection includes the <code>item</code> includesAll(col : Collection) : Boolean Returns true if the collection includes all the items of collection <code>col</code> including(item : Any) : Collection Returns a new collection that also contains the <code>item</code> -- unlike the add() operation that adds the <code>item</code> to the collection itself includingAll(col : Collection) : Collection Returns a new collection that is a union of the two collections. The type of the returned collection (i.e. Bag, Sequence, Set, OrderedSet) is same as the type of the collection on which the operation is invoked isEmpty() : Boolean Returns true if the collection does not contain any elements and false otherwise min() : Real Returns the minimum of all reals/integers in the collection, or 0 if it is empty min(default : Real) : Real Returns the minimum of all reals/integers in the collection, or the default value if it is empty max() : Real Returns the maximum of all reals/integers in the collection, or 0 if it is empty max(default : Real) : Real Returns the maximum of all reals/integers in the collection, or the default value if it is empty notEmpty() : Boolean Returns true if the collection contains any elements and false otherwise powerset() : Set Returns the set of all subsets of the collection product() : Real Returns the product of all reals/integers in the collection random() : Any Returns a random item from the collection remove(item : Any) : Boolean Removes an <code>item</code> from the collection. Returns true if the collection contained the specified element removeAll(col : Collection) : Boolean Removes all the items of <code>col</code> from the collection. Returns true if the collection changed as a result of the call size() : Integer Returns the number of items the collection contains sum() : Real Returns the sum of all reals/integers in the collection <p>The following operations apply to ordered collection types (i.e. Sequence and OrderedSet):</p> Signature Description at(index : Integer) : Any Returns the item of the collection at the specified index first() : Any Returns the first item of the collection fourth() : Any Returns the fourth item of the collection indexOf(item : Any) : Integer Returns the index of the item in the collection or -1 if it does not exist invert() : Collection Returns an inverted copy of the collection last() : Any Returns the last item of the collection removeAt(index : Integer) : Any Removes and returns the item at the specified index. second() : Any Returns the second item of the collection third() : Any Returns the third item of the collection <p>Also, EOL collections support the following first-order operations. Apart from <code>aggregate</code> and <code>closure</code>, all of these operations have a parallel variant which can take advantage of multiple cores to improve performance. All computations contained in these operations are assumed to be free from side-effects (i.e. do not mutate global variables).</p> <p>Aside from the following built-in first-order operations which are evaluated eagerly, all Collection types in the Java implementation of EOL support Streams. This allows for chains of queries and transformations on collections to be evaluated more efficiently. A stream can be obtained by calling the <code>stream()</code> method on the collection. The API is defined by the Java standard library3.</p> Signature Description atLeastNMatch(iterator : Type | condition, n : Integer) : Boolean Returns true if there are <code>n</code> or more items in the collection that satisfy the condition atMostNMatch(iterator : Type | condition, n : Integer) : Boolean Returns true if there are <code>n</code> or fewer items in the collection that satisfy the condition aggregate(iterator : Type | keyExpression, valueExpression) : Map Returns a map containing key-value pairs produced by evaluating the key and value expressions on each item of the collection that is of the specified type closure(iterator : Type | expression) : Collection Returns an ordered set containing the results of evaluating the transitive closure of the results produced by the expression on each item of the collection that is of the specified type. For example, if <code>t</code> is a tree model element, <code>t.closure(it|it.children)</code> will return all its descendants collect(iterator : Type | expression) : Collection Returns a collection containing the results of evaluating the expression on each item of the collection that is of the specified type count(iterator : Type | condition) : Integer Returns the number of elements in the collection that satisfy the condition exists(iterator : Type | condition) : Boolean Returns true if there exists at least one item in the collection that satisfies the condition forAll(iterator : Type | condition) : Boolean Returns true if all items in the collection satisfy the condition mapBy(iterator : Type | expression) : Map Returns a map containing the results of the expression as keys and the respective items of the collection as values. nMatch(iterator : Type | condition, n : Integer) : Boolean Returns true if there are exactly <code>n</code> items in the collection that satisfy the condition none(iterator : Type | condition) : Boolean Returns true if there are no items in the collection that satisfy the condition one(iterator : Type | condition) : Boolean Returns true if there exists exactly one item in the collection that satisfies the condition reject(iterator : Type | condition) : Collection Returns a sub-collection containing only items of the specified type that do not satisfy the condition rejectOne(iterator : Type | condition) : Collection Returns a sub-collection containing all elements except the first element which does not satisfy the condition select(iterator : Type | condition) : Collection Returns a sub-collection containing only items of the specified type that satisfy the condition selectByKind(Type) : Collection Returns a sub-collection containing only items of the specified type and subtypes selectByType(Type) : Collection Returns a sub-collection containing only items of the specified type only selectOne(iterator : Type | condition) : Any Returns any element that satisfies the condition sortBy(iterator: Type | expression) : Collection Returns a copy of the collection sorted by the results of evaluating the expression on each item of the collection that conforms to the iterator type. The expression should return either an Integer, a String or an object that is an instance of Comparable. The ordering is calculated as follows: for integers, smaller to greater; for Strings, as defined by the compareTo method of Java strings; for Comparable objects, according to the semantics of the type's compareTo method implementation. <p>The Map type (which implements the <code>java.util.Map</code> interface) represents a Set of key-value pairs in which the keys are unique. Since version 2.0, there is also a thread-safe <code>ConcurrentMap</code> type, which implements the <code>java.util.concurrent.ConcurrentMap</code> interface. The following operations are supported:</p> Signature Description clear() Clears the map containsKey(key : Any) : Boolean Returns true if the map contains the specified key containsValue(value : Any) : Boolean Returns true if this map maps one or more keys to the specified value. get(key : Any) : Any Returns the value for the specified key isEmpty() : Boolean Returns true if the map contains no key-value mappings. keySet() : Set Returns the keys of the map put(key : Any, value : Any) Adds the key-value pair to the map. If the map already contains the same key, the value is overwritten putAll(map : Map) Copies all of the mappings from the specified map to this map. remove(key : Any) : Any Removes the mapping for the specified key from this map if present. Returns the previous value associated with key. size() : Integer Returns the number of key-value mappings in this map. values() : Bag Returns the values of the map"},{"location":"doc/eol/#tuples","title":"Tuples","text":"<p>Since version 2.2, EOL supports Tuples, which can be used to compose arbitrary data structures on-the-fly. A <code>Tuple</code> in EOL behaves like a <code>Map&lt;String, Object&gt;</code>, except that the values of the map can be accessed using literal property call expressions. There are three ways to instantiate a tuple, as shown below.</p> <pre><code>// After construction\nvar alice = new Tuple;\nalice.name = \"Alice\";\nalice.age = 32;\n\n// During construction\nvar bob = new Tuple(name = \"Bob\", age = 28);\n\n// Map Literal\nvar charlie = Tuple{\"name\" = \"Charlie\", \"age\" = 36};</code></pre> <p>If a non-existent property on a Tuple is accessed, an exception is thrown.</p> <pre><code>var p = new Tuple(name = \"Alice\", age = 32);\n\np.name.substring(0, 3); // \"Ali\"\np.age; // 32\np.occupation.isDefined(); // false\np.occupation.toUpperCase(); // Property 'occupation' not found</code></pre>"},{"location":"doc/eol/#native-types","title":"Native Types","text":"<p>As discussed earlier, while the purpose of EOL is to provide significant expressive power to enable users to manage models at a high level of abstraction, it is not intended to be a general-purpose programming language. Therefore, there may be cases where users need to implement some functionality that is either not efficiently supported by the EOL runtime (e.g. complex mathematical computations) or that EOL does not support at all (e.g. developing user interfaces, accessing databases). To overcome this problem, EOL enables users to create objects of the underlying programming environment by using <code>native</code> types. A native type specifies an <code>implementation</code> property that indicates the unique identifier for an underlying platform type. For instance, in a Java implementation of EOL the user can instantiate and use a Java class via its class identifier. Thus, the EOL excerpt in the listing below creates a Java window (Swing JFrame) and uses its methods to change its title and dimensions and make it visible.</p> <pre><code>var frame = new Native(\"javax.swing.JFrame\");\nframe.title = \"Opened with EOL\";\nframe.setBounds(100,100,300,200);\nframe.visible = true;</code></pre> <p>To pass arguments to the constructor of a native type, a parameter list must be added, such as that in the listing below. </p> <pre><code>var file = new Native(\"java.io.File\")(\"myfile.txt\");\nfile.absolutePath.println();</code></pre> <p>Static types can also be referenced in EOL and stored in a variable for convenience, as shown below.</p> <pre><code>var Collectors = Native(\"java.util.stream.Collectors\");</code></pre>"},{"location":"doc/eol/#model-element-types","title":"Model Element Types","text":"<p>A model element type represents a meta-level classifier for model elements. Epsilon intentionally refrains from defining more details about the meaning of a model element type, to be able to support diverse modelling technologies where a type has different semantics. For instance an Ecore EClass, an XSD complex type and a Java class can all be regarded as model element types according to the implementation of the underlying modelling framework.</p> <p>Info</p> <p>As EOL is decoupled from modelling technologies (e.g. EMF, Simulink), through Epsilon's Model Connectivity Layer, we refrain from referring to specific modelling technologies in this section as much as possible.</p> <p>In case of multiple models, as well as the name of the type, the name of the model is also required to resolve a particular type since different models may contain elements of homonymous but different model element types. In case a model defines more than one type with the same name (e.g. in different packages), a fully qualified type name must be provided.</p> <p>In terms of concrete syntax, inspired by ATL, the <code>!</code> character is used to separate the name of the type from the name of the model it is defined in. For instance, <code>Ma!A</code> represents the type <code>A</code> of model <code>Ma</code>. Also, to support modelling technologies that provide hierarchical grouping of types (e.g. using packages) the <code>::</code> notation is used to separate between packages and classes. A model element type supports the following operations:</p> Signature Description all() : Collection Alias for getAllOfKind() (for syntax-compactness purposes) allInstances() : Collection Alias for getAllOfKind() (for compatibility with OCL) getAllOfKind() : Collection Returns all the elements in the model that are instances either of the type itself or of one of its subtypes getAllOfType() : Collection Returns all the elements in the model that are instances of the type createInstance() : Any Creates an instance of the type in the model. The same can be achieved using the <code>new</code> operator (see below) isInstantiable() : Boolean Returns true if the type is instantiable (i.e. non-abstract) <p>As an example of the concrete syntax, the listing below retrieves all the instances of the Class type (including instances of its subtypes) defined in the Core package of the UML 1.4 metamodel that are contained in the model named UML14.</p> <pre><code>UML14!Core::Foundation::Class.allInstances();\n</code></pre>"},{"location":"doc/eol/#creating-and-deleting-model-elements","title":"Creating and Deleting Model Elements","text":"<p>EOL provides the <code>new</code> and <code>delete</code> operators for creating and deleting model elements as shown below. The <code>new</code> operator is an alias for the <code>createInstance()</code> method above, and can also be used to create instances of primitive and native types (i.e Java classes).</p> <pre><code>var t : new Tree; // Creates a new instance of type Tree\nvar p : new Source!Person; // Creates a new Person in model Source\ndelete t; // Deletes the element created in line 1</code></pre>"},{"location":"doc/eol/#expressions","title":"Expressions","text":""},{"location":"doc/eol/#literal-values","title":"Literal Values","text":"<p>EOL provides special syntax constructs to create instances of each of the built-in types:</p> <ul> <li>Integer literals are defined by using one or more decimal digits (such as <code>42</code> or <code>999</code>). Optionally, long integers (with the same precision as a Java <code>Long</code>) can be produced by adding a \"l\" suffix, such as <code>42l</code>.</li> <li> <p>Real literals are defined by:</p> <ul> <li>Adding a decimal separator and non-empty fractional part to the     integer part, such as <code>42.0</code> or <code>3.14</code>. Please note that <code>.2</code>     and <code>2.</code> are <code>not</code> valid literals.</li> <li>Adding a floating point suffix: \"f\" and \"F\" denote single     precision, and \"d\" and \"D\" denote double precision. For example,     <code>2f</code> or <code>3D</code>.</li> <li>Adding an exponent, such as <code>2e+1</code> (equal to <code>2e1</code>) or <code>2e-1</code>.</li> <li>Using any combination of the above options.</li> </ul> </li> <li> <p>String literals are sequences of characters delimited by single (<code>'hi'</code>) or double (<code>\"hi\"</code>) quotes. Quotes inside the string can be escaped by using a backslash, such as in <code>'A\\'s'</code> or <code>\"A\\\"s\"</code>. Literal backslashes need to be escaped as well, such as in <code>'A\\\\B'</code>. Special escape sequences are also provided: <code>\\n</code> for a newline, <code>\\t</code> for a horizontal tab and <code>\\r</code> for a carriage return, among others.</p> </li> <li> <p>Boolean literals use the <code>true</code> reserved keyword for the true Boolean value, and <code>false</code> reserved keyword for the false Boolean value.</p> </li> <li> <p>Sequence and most other collections (except <code>Map</code>s) also have literals. Their format is <code>T {e}</code>, where <code>T</code> is the name of the type and <code>e</code> are zero or more elements, separated by commas. For instance, <code>Sequence{}</code> is the empty sequence, and <code>Set {1, 2, 3}</code> is the set of numbers between 1 and 3.</p> </li> <li> <p>Map literals are similar to the sequential collection literals, but their elements are of the form <code>key = value</code>. For instance, <code>Map{\"a\" = 1, \"b\" = 2}</code> is a map which has two keys, \"a\" and \"b\", which map to the integer values 1 and 2, respectively.</p> <p>Please note that, when defining an element such as <code>1 = 2 = 3</code>, the key would be <code>1</code> and the value would be the result of evaluating <code>2 = 3</code> (false). If you would like to use the result of the expression <code>1 = 2</code> as key, you will need to enclose it in parenthesis, such as in <code>(1 = 2) = 3</code>.</p> </li> </ul>"},{"location":"doc/eol/#feature-navigation","title":"Feature Navigation","text":"<p>Since EOL needs to manage models defined using object oriented modelling technologies, it provides expressions to navigate properties and invoke simple and declarative operations on objects.</p> <p>In terms of concrete syntax, <code>.</code> is used as a uniform operator to access a property of an object and to invoke an operation on it. The <code>-&gt;</code> operator, which is used in OCL to invoke first-order logic operations on sets, has been also preserved for syntax compatibility reasons. In EOL, every operation can be invoked both using the <code>.</code> or the <code>-&gt;</code> operators, with a slightly different semantics to enable overriding the built-in operations. If the <code>.</code> operator is used, precedence is given to the user-defined operations, otherwise precedence is given to the built-in operations. For instance, the Any type defines a println() method that prints the string representation of an object to the standard output stream. In the listing below, the user has defined another parameterless println() operation in the context of Any. Therefore the call to <code>println()</code> in line 1 will be dispatched to the user-defined <code>println()</code> operation defined in line 3. In its body the operation uses the <code>-&gt;</code> operator to invoke the built-in <code>println()</code> operation (line 4).</p> <pre><code>\"Something\".println();\n\noperation Any println() : Any {\n  (\"Printing : \" + self)-&gt;println();\n}</code></pre> <p>Navigating to the parent/children of model elements</p> <p>EOL does not provide a technology-independent way of navigating to the parent/children of a model element. If you need to do this, you should use any methods provided by the underlying modelling platform. For example, as all elements of EMF models are instances of the EObject Java class, the <code>me.eContainer()</code> and <code>me.eContents()</code> method calls in EMF return the parent and children of element <code>me</code> respectively.</p>"},{"location":"doc/eol/#escaping-reserved-keywords","title":"Escaping Reserved Keywords","text":"<p>Due to the variable nature of (meta-)models and the various domain-specific languages of Epsilon (including EOL itself), feature navigation calls may clash with reserved keywords, leading to a parsing error. Back-ticks can be used to escape such keywords. For example, if a model element contains a feature called <code>operation</code>, then this can be navigated as shown in the listing below.</p> <pre><code>var op = modelElement.`operation`;</code></pre>"},{"location":"doc/eol/#arithmetical-and-comparison-operators","title":"Arithmetical and Comparison Operators","text":"<p>EOL provides common operators for performing arithmetical computations and comparisons illustrated in the following two tables respectively.</p> Operator Description + Adds reals/integers and concatenates strings - Subtracts reals/integers - (unary). Returns the negative of a real/integer * Multiplies reals/integers / Divides reals/integers += Adds the r-value to the l-value -= Subtracts the r-value from the l-value *= Multiplies the l-value by the r-value /= Divides the l-value by the r-value ++ Increments the integer by one -- Decrements the integer by one Operator Description = Returns true if the left hand side equals the right hand side. In the case of primitive types (String, Boolean, Integer, Real) the operator compares the values; in the case of objects it returns true if the two expressions evaluate to the same object == Same as = &lt;&gt; Is the logical negation of the (=) operator != Same as &lt;&gt; &gt; For reals/integers returns true if the left hand side is greater than the right hand side number &lt; For reals/integers returns true if the left hand side is less than the right hand side number &gt;= For reals/integers returns true if the left hand side is greater or equal to the right hand side number &lt;= For reals/integers returns true if the left hand side is less or equal to then right hand side number"},{"location":"doc/eol/#logical-operators","title":"Logical Operators","text":"<p>EOL provides common operators for performing logical computations illustrated in the table below. Logical operations apply only to instances of the Boolean primitive type.</p> <p>Operator Precedence</p> <p>All logical operators in EOL have the same priority. This is in contrast to other languages like Java where e.g. <code>and</code> has a higher priority than <code>or</code>. As a result, while <code>true || true &amp;&amp; false</code> returns <code>true</code> in Java, the equivalent <code>true or true and false</code> expression in EOL returns <code>false</code>. Default priorities can be overridden using brackets (<code>true or (true and false)</code> in this case.)</p> Operator Description and Returns the logical conjunction of the two expressions or Returns the logical disjunction of the two expressions not Returns the logical negation of the expression implies Returns the logical implication of the two expressions (see below) xor Returns true if only one of the involved expressions evaluates to true and false otherwise <p>The truth table for the <code>implies</code> logical operator is below.</p> Left Right Result true true true true false false false true true false false true"},{"location":"doc/eol/#ternary-operator","title":"Ternary Operator","text":"<p>As of version 2.0, EOL has a ternary operator which is a concise way of using if/else as an expression. The semantics and syntax are similar to Java, but can be used anywhere as an expression, not only in variable assignments or return statements. The listing below shows some examples of this4. Note that is also possible to use the <code>else</code> keyword in place of the colon for separating the true and false expressions for greater clarity. As one would expect, the branches are evaluated lazily: only one of the branches is executed and returned as the result of the expression depending on the value of the Boolean expression before the question mark.</p> <pre><code>var result = 2+2==4 ? \"Yes\" else \"No\";\nreturn ((result == \"Yes\" ? 1 : 0) * 2 == 2).mod(2) == 0;</code></pre>"},{"location":"doc/eol/#safe-navigation-and-elvis-operator","title":"Safe Navigation and Elvis Operator","text":"<p>As of version 2.1, EOL supports safe null navigation <code>?.</code>, which makes it more concise to chain feature call expressions without resorting to defensive <code>null</code> / <code>isDefined()</code> checks. In the following example, the variable <code>result</code> will be <code>null</code>, and the program won't crash since the safe navigation operator is used.</p> <pre><code>var a = null;\nvar result = a?.someProperty?.anotherProperty;</code></pre> <p>The null variant of the \"Elvis operator\" can also be used to simplify null check ternary expressions, as shown in the example below.</p> <p><pre><code>var a = null;\nvar b = \"result\";\nvar c = a != null ? a : b;\nvar d = a ?: b;\nassert(c == d);</code></pre> As with the ternary operator, the Elvis operator can also be used anywhere an expression is expected, not just in assignments.</p> <p>As of Epsilon 2.2, there is also the <code>?=</code> shortcut assignment operator. This is useful for reassigning a variable if it is null. In other words, <code>a ?= b</code> is equivalent to <code>if (a == null) a = b;</code>.</p> <pre><code>var a = null;\nvar b = \"result\";\na ?= b;\nassert(a == b);</code></pre>"},{"location":"doc/eol/#enumerations","title":"Enumerations","text":"<p>EOL provides the <code>#</code> operator for accessing enumeration literals. For example, the <code>VisibilityEnum#vk_public</code> expression returns the value of the literal <code>vk_public</code> of the <code>VisibilityEnum</code> enumeration. For EMF metamodels, <code>VisibilityEnum#vk_public.instance</code> can also be used.</p> <p>Since 2.5.0, you can optionally omit the type when referring to enumeration literals. All these options are available:</p> <ul> <li><code>#vk_public</code></li> <li><code>VisibilityEnum#vk_public</code></li> <li><code>Model!#vk_public</code></li> <li><code>Model!VisibilityEnum#vk_public</code></li> </ul> <p>If a reference to an enumeration literal is ambiguous (i.e. there are several enumerations with a literal with the given name), EOL will report a warning and continue executing by assuming it refers to the first match.</p>"},{"location":"doc/eol/#statements","title":"Statements","text":""},{"location":"doc/eol/#variable-declaration-statement","title":"Variable Declaration Statement","text":"<p>A variable declaration statement declares the name and (optionally) the type and initial value of a variable in an EOL program. If no type is explicitly declared, the variable is assumed to be of type <code>Any</code>. For variables of primitive type, declaration automatically creates an instance of the type with the default values presented in the table below. For non-primitive types the user has to explicitly assign the value of the variable either by using the <code>new</code> keyword or by providing an initial value expression. If neither is done the value of the variable is undefined. Variables in EOL are strongly-typed. Therefore a variable can only be assigned values that conform to its type (or a sub-type of it).</p> Type Default value Integer 0 Boolean false String \"\" Real 0.0"},{"location":"doc/eol/#scope","title":"Scope","text":"<p>The scope of variables in EOL is generally limited to the block of statements where they are defined, including any nested blocks. Nevertheless, as discussed in the sequel, there are cases in task-specific languages that build atop EOL where the scope of variables is expanded to other non-nested blocks as well. EOL also allows variable shadowing; that is to define a variable with the same name in a nested block that overrides a variable defined in an outer block.</p> <p>The listing below provides an example of declaring and using variables.</p> <ul> <li>Line 1 defines a variable named <code>i</code> of type <code>Integer</code> and assigns it an initial value of <code>5</code>.</li> <li>Line 2 defines a variable named <code>c</code> of type <code>Class</code> (from model Uml) and creates a new instance of the type in the model (by using the <code>new</code> keyword).</li> <li>The commented out assignment statement of line 3 would raise a runtime error since it would attempt to assign a <code>String</code> value to an <code>Integer</code> variable.</li> <li>The condition of line 4 returns true since the <code>c</code> variable has been initialized before.</li> <li>Line 5 defines a new variable also named <code>i</code> that is of type <code>String</code> and which overrides the <code>Integer</code> variable declared in line 1.</li> <li>Therefore the assignment statement of line 6 is legitimate as it assigns a string value to a variable of type String.</li> <li>As the program has exited the scope of the <code>if</code> statement, the assignment statement of line 7 is also legitimate as it refers to the <code>i</code> variable defined in line 1.</li> <li>In line 8, we declare <code>s1</code> as a <code>Sequence</code> of any type of value.</li> <li>Line 9 declares <code>s2</code> as a <code>Sequence</code> containing values of type <code>Integer</code>. Note that type parameters can be written as <code>CollectionType&lt;ValueType&gt;</code> or as <code>CollectionType(ValueType)</code>.</li> <li>Line 10 declares <code>m1</code> as a <code>Map</code> where the keys and values can be of any type.</li> <li>Line 11 declares <code>m2</code> as a <code>Map</code> where the keys are <code>String</code>s, and the values are <code>Integer</code>s.</li> </ul> <pre><code>var i : Integer = 5;\nvar c : new Uml!Class;\n//i = \"somevalue\";\nif (c.isDefined()) {\n  var i : String;\n  i = \"somevalue\";\n}\ni = 3;\nvar s1 : Sequence;\nvar s2 : Sequence&lt;Integer&gt;;\nvar m1 : Map;\nvar m2 : Map(String, Integer);</code></pre> <p>Type parameters are only for documentation purposes in version 2.5.0</p> <p>As of version 2.5.0, type parameters (e.g. <code>&lt;Integer&gt;</code> in <code>Sequence&lt;Integer&gt;</code>, or <code>(String, Integer)</code> in <code>Map(String, Integer)</code>) are only used for documentation purposes. EOL does not enforce that values of appropriate types are used during execution.</p>"},{"location":"doc/eol/#assignment-statement","title":"Assignment Statement","text":"<p>The assignment statement is used to update the values of variables and properties of native objects and model elements.</p>"},{"location":"doc/eol/#variable-assignment","title":"Variable Assignment","text":"<p>When the left hand side of an assignment statement is a variable, the value of the variable is updated to the object to which the right hand side evaluates to. If the type of the right hand side is not compatible (kind-of relationship) with the type of the variable, the assignment is illegal and a runtime error is raised. Assignment to objects of primitive types is performed by value while assignment to instances of non-primitive values is performed by reference. For example, in the listing below, in line 1 the value of the a variable is set to a new Class in the Uml model. In line 2, a new untyped variable b is declared and its value is assigned to a. In line 3 the name of the class is updated to Customer and thus, line 4 prints Customer to the standard output stream.</p> <pre><code>var a : new Uml!Class;\nvar b = a;\na.name = \"Customer\";\nb.name.println();</code></pre> <p>On the other hand, in the listing below, in line 1 the a String variable is declared. In line 2 an untyped variable b is declared. In line 3, the value of a is changed to Customer (which is an instance of the primitive <code>String</code> type). This has no effect on b and thus line 4 prints an empty string to the standard output stream.</p> <pre><code>var a : String;\nvar b = a;\na = \"Customer\";\nb.println();</code></pre>"},{"location":"doc/eol/#native-object-property-assignment","title":"Native Object Property Assignment","text":"<p>When the left hand side of the assignment is a property of a native object, deciding on the legality and providing the semantics of the assignment is delegated to the execution engine. For example, in a Java-based execution engine, given that x is a native object, the statement <code>x.y = a</code> may be interpreted as <code>x.setY(a)</code> or if x is an instance of a map <code>x.put(\"y\",a)</code>. By contrast, in a C# implementation, it can be interpreted as <code>x.y = a</code> since the language natively supports properties in classes.</p>"},{"location":"doc/eol/#model-element-property-assignment","title":"Model Element Property Assignment","text":"<p>When the left hand side of the assignment is a property of a model element, the model that owns the particular model element (accessible using the <code>ModelRepository.getOwningModel()</code> operation) is responsible for implementing the semantics of the assignment using its associated <code>propertyGetter</code>. For example, if x is a model element, the statement <code>x.y = a</code> may be interpreted using the Java code of the first listing below if x belongs to an EMF-based model or using the Java code of the second listing if it belongs to an MDR-based model.</p> <pre><code>EStructuralFeature feature = x.eClass().getEStructuralFeature(\"y\");\nx.eSet(feature, a);\n</code></pre> <pre><code>StructuralFeature feature = findStructuralFeature(x.refClass(), \"y\");\nx.refSetValue(feature, a);\n</code></pre>"},{"location":"doc/eol/#special-assignment-statement","title":"Special Assignment Statement","text":"<p>In task-specific languages, an assignment operator with task-specific semantics is often required. Therefore, EOL provides an additional assignment operator. In standalone EOL, the operator has the same semantics with the primary assignment operator discussed above, however task-specific languages can redefine its semantics to implement custom assignment behaviour. For example, consider the simple model-to-model transformation of the listing below where a simple object oriented model is transformed to a simple database model using an ETL transformation.</p> <pre><code>rule Class2Table\n  transform c : OO!Class\n  to t : DB!Table {\n\n    t.name = c.name;\n}\n\nrule Attribute2Column\n  transform a : OO!Attribute\n  to c : DB!Column {\n\n    c.name = a.name;\n    //c.owningTable = a.owningClass;\n    c.owningTable ::= a.owningClass;\n}</code></pre> <p>The <code>Class2Table</code> rule transforms a <code>Class</code> of the OO model into a <code>Table</code> in the DB model and sets the name of the table to be the same as the name of the class. Rule <code>Atribute2Column</code> transforms an <code>Attribute</code> from the OO model into a <code>Column</code> in the DB model. Except for setting its name (line 12), it also needs to define that the column belongs to the table which corresponds to the class that defines the source attribute. The commented-out assignment statement of line 13 cannot be used for this purpose since it would illegally attempt to assign the owningTable feature of the column to a model element of an inappropriate type (<code>OO!Class</code>). However, the special assignment operator in ETL has language-specific semantics, and thus in line 14 it assigns to the <code>owningTable</code> feature not the class that owns the attribute but its corresponding table (calculated using the <code>Class2Table</code> rule) in the DB model.</p>"},{"location":"doc/eol/#if-statement","title":"If Statement","text":"<p>As in most programming languages, an if statement consists of a condition, a block of statements that is executed if the condition is satisfied and (optionally) a block of statements that is executed otherwise. As an example, in the listing below, if variable a holds a value that is greater than 0 the statement of line 3 is executed, otherwise the statement of line 5 is executed.</p> <pre><code>if (a &gt; 0) {\n  \"A is greater than 0\".println();\n}\nelse { \"A is less equal than 0\".println(); }</code></pre>"},{"location":"doc/eol/#switch-statement","title":"Switch Statement","text":"<p>A switch statement consists of an expression and a set of cases, and can be used to implement multi-branching. Unlike Java/C, switch in EOL doesn't by default fall through to the next case after a successful one. Therefore, it is not necessary to add a <code>break</code> statement after each case. To enable falling through to all subsequent cases you can use the <code>continue</code> statement. Also, unlike Java/C, the switch expression can return anything (not only integers). As an example, when executed, the code in the listing below prints <code>2</code> while the code in the following listing prints <code>2,3,default</code>.</p> <pre><code>var i = \"2\";\n\nswitch (i) {\n  case \"1\" : \"1\".println(); \n  case \"2\" : \"2\".println();\n  case \"3\" : \"3\".println();\n  default : \"default\".println(); \n}</code></pre> <pre><code>var i = \"2\";\n\nswitch (i) {\n  case \"1\" : \"1\".println(); \n  case \"2\" : \"2\".println(); continue;\n  case \"3\" : \"3\".println();\n  default : \"default\".println(); \n}</code></pre>"},{"location":"doc/eol/#while-statement","title":"While Statement","text":"<p>A while statement consists of a condition and a block of statements which are executed as long as the condition is satisfied. For example, in the listing below, the body of the while statement is executed 5 times printing the numbers 0 to 4 to the output console. Inside the body of a <code>while</code> statement, the built-in read-only <code>loopCount</code> integer variable holds the number of times the innermost loop has been executed so far (including the current iteration). Right after entering the loop for the first time and before running the first statement in its body, <code>loopCount</code> is set to 1, and it is incremented after each following iteration.</p> <pre><code>var i : Integer = 0;\nwhile (i &lt; 5) {\n  // both lines print the same thing\n  i.println();\n  (loopCount - 1).println();\n  // increment the counter\n  i = i+1;\n}</code></pre>"},{"location":"doc/eol/#for-statement","title":"For Statement","text":"<p>In EOL, for statements are used to iterate the contents of collections. A for statement defines a typed iterator and an iterated collection as well as a block of statements that is executed for every item in the collection that has a kind-of relationship with the type defined by the iterator. As with the majority of programming languages, modifying a collection while iterating it raises a runtime error. To avoid this situation, users can use the clone() built-in operation of the Collection type.</p> <pre><code>var col : Sequence = Sequence{\"a\", 1, 2, 2.5, \"b\"};\nfor (r : Real in col) {\n  r.print();\n  if (hasMore){\",\".print();}\n}</code></pre> <p>Inside the body of a <code>for</code> statement, two built-in read-only variables are visible: the <code>loopCount</code> integer variable and the <code>hasMore</code> boolean variable. <code>hasMore</code> is used to determine if there are more items if the collection for which the loop will be executed. For example, in the listing below the <code>col</code> heterogeneous <code>Sequence</code> is defined that contains two strings (<code>a</code> and <code>b</code>), two integers (<code>1</code>,<code>2</code>) and one real (<code>2.5</code>). The for loop of line 2 only iterates through the items of the collection that are of kind Real and therefore prints <code>1,2,2.5</code> to the standard output stream.</p>"},{"location":"doc/eol/#break-breakall-and-continue-statements","title":"Break, BreakAll and Continue Statements","text":"<p>To exit from for and while loops on demand, EOL provides the break and breakAll statements. The break statement exits the innermost loop while the breakAll statement exits all outer loops as well. On the other hand, to skip a particular loop and proceed with the next one, EOL provides the continue statement. For example, the program in the listing below, prints <code>2,1 3,1</code> to the standard output stream.</p> <pre><code>for (i in Sequence{1..3}) {\n  if (i = 1) {continue;}\n  for (j in Sequence{1..4}) {\n    if (j = 2) {break;}\n    if (j = 3) {breakAll;}\n    (i + \",\" + j).println();\n  }\n}</code></pre>"},{"location":"doc/eol/#throw-statement","title":"Throw Statement","text":"<p>EOL provides the throw statement for throwing a value as an Java exception. This is especially useful when invoking EOL scripts from Java code: by catching and processing the exception, the Java code may be able to automatically handle the problem without requiring user input. Any value can be thrown, as shown in the listing below where we throw a number and a string.</p> <pre><code>throw 42;\nthrow \"Error!\";</code></pre>"},{"location":"doc/eol/#transaction-statement","title":"Transaction Statement","text":"<p>The underlying EMC layer provides support for transactions in models. To utilize this feature EOL provides the transaction statement. A transaction statement (optionally) defines the models that participate in the transaction. If no models are defined, it is assumed that all the models that are accessible from the enclosing program participate. When the statement is executed, a transaction is started on each participating model. If no errors are raised during the execution of the contained statements, any changes made to model elements are committed. On the other hand, if an error is raised the transaction is rolled back and any changes made to the models in the context of the transaction are undone. The user can also use the abort statement to explicitly exit a transaction and roll-back any changes done in its context. In the listing below, an example of using this feature in a simulation problem is illustrated.</p> <pre><code>var system : System.allInstances.first();\n\nfor (i in Sequence {1..100}) {\n\n  transaction {\n\n    var failedProcessors : Set; \n\n    while (failedProcessors.size() &lt; 10) {\n        failedProcessors.add(system.processors.random());\n    }\n\n    for (processor in failedProcessors) {\n        processor.failed = true;\n        processor.moveTasksElsewhere();\n    }\n\n    system.evaluateAvailability();\n\n    abort;\n  }\n\n}</code></pre> <p>In this problem, a system consists of a number of processors. A processor manages some tasks and can fail at any time. The EOL program in the listing above performs 100 simulation steps, in every one of which 10 random processors from the model (lines 7-11) are marked as failed by setting their <code>failed</code> property to true (line 14). Then, the tasks that the failed processors manage are moved to other processors (line 15). Finally the availability of the system in this state is evaluated.</p> <p>After a simulation step, the state of the model has been drastically changed since processors have failed and tasks have been relocated. To be able to restore the model to its original state after every simulation step, each step is executed in the context of a transaction which is explicitly aborted (line 20) after evaluating the availability of the system. Therefore after each simulation step the model is restored to its original state for the next step to be executed.</p>"},{"location":"doc/eol/#extended-properties","title":"Extended Properties","text":"<p>Quite often, during a model management operation it is necessary to associate model elements with information that is not supported by the metamodel they conform to. For instance, the EOL program in the listing below calculates the depth of each Tree element in a model that conforms to the Tree metamodel displayed below.</p> classDiagram class Tree {   +label: String   +parent: Tree   +children: Tree[*] } Tree -- Tree   <p>As the Tree metamodel doesn't support a <code>depth</code> property in the Tree metaclass, each Tree has to be associated with its calculated depth using the <code>depths</code> map defined in line 1. Another approach would be to extend the Tree metamodel to support the desired <code>depth</code> property; however, applying this technique every time an additional property is needed for some model management operation would quickly pollute the metamodel with properties of secondary importance.</p> <pre><code>var depths = new Map;\n\nfor (n in Tree.allInstances.select(t|not t.parent.isDefined())) {\n  n.setDepth(0);\n}\n\nfor (n in Tree.allInstances) {\n  (n.name + \" \" + depths.get(n)).println();\n}\n\noperation Tree setDepth(depth : Integer) {\n  depths.put(self,depth);\n  for (c in self.children) {\n    c.setDepth(depth + 1);\n  }\n}</code></pre> <p>To simplify the code required in such cases, EOL provides the concept of extended properties. In terms of concrete syntax, an extended property is a normal property, the name of which starts with the tilde character (<code>~</code>). With regards to its execution semantics, the first time the value of an extended property of an object is assigned, the property is created and associated with the object. Then, the property can be accessed as a normal property. If an extended property is accessed before it is assigned, it returns <code>null</code>. The listing below demonstrates using a <code>~depth</code> extended property to eliminate the need for using the <code>depths</code> map in the listing that follows it.</p> <pre><code>for (n in Tree.allInstances.select(t|not t.parent.isDefined())) {\n  n.setDepth(0);\n}\n\nfor (n in Tree.allInstances) {\n  (n.name + \" \" + n.~depth).println();\n}\n\noperation Tree setDepth(depth : Integer) {\n  self.~depth = depth;\n  for (c in self.children) {\n    c.setDepth(depth + 1);\n  }\n}</code></pre>"},{"location":"doc/eol/#context-independent-user-input","title":"Context-Independent User Input","text":"<p>A common assumption in model management languages is that model management tasks are only executed in a batch-manner without human intervention. However, as demonstrated in the sequel, it is often useful for the user to provide feedback that can precisely drive the execution of a model management operation.</p> <p>Model management operations can be executed in a number of runtime environments in each of which a different user-input method is more appropriate. For instance when executed in the context of an IDE (such as Eclipse) visual dialogs are preferable, while when executed in the context of a server or from within an ANT workflow, a command-line user input interface is deemed more suitable. To abstract away from the different runtime environments and enable the user to specify user interaction statements uniformly and regardless of the runtime context, EOL provides the <code>IUserInput</code> interface that can be realized in different ways according to the execution environment and attached to the runtime context via the <code>IEolContext.setUserInput(IUserInput userInput)</code> method. The <code>IUserInput</code> specifies the methods presented in the table below.</p> Signature Description inform(message : String) Displays the specified message to the user confirm(message : String, [default : Boolean]) : Boolean Prompts the user to confirm if the condition described by the message holds prompt(message : String, [default : String]) : String Prompts the user for a string in response to the message promptInteger(message : String, [default : Integer]) : Integer Prompts the user for an Integer promptReal(message : String, [default : Real]) : Real Prompts the user for a Real choose(message : String, options : Sequence, [default : Any]) : Any Prompts the user to select one of the options chooseMany(message : String, options : Sequence, [default : Sequence]) : Sequence Prompts the user to select one or more of the options <p>As displayed above, all the methods of the <code>IUserInput</code> interface accept a <code>default</code> parameter. The purpose of this parameter is dual. First, it enables the designer of the model management program to prompt the user with the most likely value as a default choice and secondly it enables a concrete implementation of the interface (<code>UnattendedExecutionUserInput</code>) which returns the default values without prompting the user at all and thus, can be used for unattended execution of interactive Epsilon programs. The figures below demonstrate the interfaces through which input is required by the user when the exemplar <code>System.user.promptInteger(\"Please enter a number\", 1);</code> statement is executed using an Eclipse-based and a command-line-based <code>IUserInput</code> implementation respectively.</p> <p></p> <p></p> <p>User-input facilities have been found to be particularly useful in all model management tasks. Such facilities are essential for performing operations on live models such as model validation and model refactoring but can also be useful in model comparison where marginal matching decisions can be delegated to the user and model transformation where the user can interactively specify the elements that will be transformed into corresponding elements in the target model.</p>"},{"location":"doc/eol/#additional-resources","title":"Additional Resources","text":"<p>Additional resources about EOL are available here.</p> <ol> <li> <p>Parameters within square brackets are optional\u00a0\u21a9</p> </li> <li> <p>http://download.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax \u21a9</p> </li> <li> <p>https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html \u21a9</p> </li> <li> <p>For further examples of ternary operator, see https://github.com/eclipse/epsilon/tree/main/tests/org.eclipse.epsilon.eol.engine.test.acceptance/src/org/eclipse/epsilon/eol/engine/test/acceptance/TernaryTests.eol \u21a9</p> </li> </ol>"},{"location":"doc/epl/","title":"The Epsilon Pattern Language (EPL)","text":"<p>The aim of EPL is to contribute pattern matching capabilities to Epsilon. This chapter discusses the abstract and concrete syntax of EPL as well as its execution semantics. To aid understanding, the discussion of the syntax and the semantics of the language revolves around an exemplar pattern which is developed incrementally throughout the chapter. The exemplar pattern is matched against models extracted from Java source code using tooling provided by the MoDisco project. MoDisco is an Eclipse project that provides a fine-grained Ecore-based metamodel of the Java language as well as tooling for extracting models that conform to this Java metamodel from Java source code. A simplified view of the relevant part of the MoDisco Java metamodel used in this running example is presented below.</p> <p>The aim of the pattern developed here (which we will call PublicField) is to identify quartets of <code>&lt;ClassDeclaration, FieldDeclaration, MethodDeclaration, MethodDeclaration&gt;</code>, each representing a field of a Java class for which appropriately named accessor/getter (getX/isX) and mutator/setter (setX) methods are defined by the class.</p> classDiagram class ClassDeclaration {     +name: String     +bodyDeclarations: BodyDeclaration[*] } class BodyDeclaration {     +name: String     +modifiers: Modifier[*] } class VariableDeclarationFragment {     +name: String } class FieldDeclaration {     +fragments: VariableDeclarationFragment[*]     +type: TypeAccess } class MethodDeclaration {     +returnType: TypeAccess } class VariableDeclarationFragment {     +name: String } class Modifier {     +visibility: VisibilityKind } class VisibilityKind {     #none     #public     #protected     #private } ClassDeclaration -- BodyDeclaration: bodyDeclarations * BodyDeclaration -- Modifier: modifiers * Modifier -- VisibilityKind: visibility BodyDeclaration &lt;|-- FieldDeclaration MethodDeclaration --|&gt; BodyDeclaration FieldDeclaration -- VariableDeclarationFragment: fragments * FieldDeclaration -- TypeAccess: type MethodDeclaration -- TypeAccess: returnType"},{"location":"doc/epl/#syntax","title":"Syntax","text":"<p>The syntax of EPL is an extension of the syntax of the EOL language, which is the core language of Epsilon. As such, any references to expression and statement block in this chapter, refer to EOL expressions and blocks of EOL statements respectively. It is also worth noting that EOL expressions and statements can produce side-effects on models, and therefore, it is the responsibility of the developer to decide which expressions used in the context of EPL patterns should be side-effect free and which not.</p> <p>As illustrated in the figure below, EPL patterns are organised in modules. Each module contains a number of named patterns and optionally, pre and post statement blocks that are executed before and after the pattern matching process, and helper EOL operations. EPL modules can import other EPL and EOL modules to facilitate reuse and modularity.</p> classDiagram class EplModule {     -iterative: Boolean     -maxLoops: Integer } class Pattern {     -name: String     -match: ExecutableBlock&lt;Boolean&gt;     -onMatch: ExecutableBlock&lt;Void&gt;     -noMatch: ExecutableBlock&lt;Void&gt;     -do: ExecutableBlock&lt;Void&gt; } class Role {     -names: String[1..*]     -negative: Boolean     -type: EolType     -guard: ExecutableBlock&lt;Boolean&gt;     -active: ExecutableBlock&lt;Boolean&gt;     -optional: ExecutableBlock&lt;Boolean&gt; } class Cardinality {     -lowerBound: Integer     -upperBound: Integer } EolModule &lt;|-- ErlModule ErlModule &lt;|-- EplModule Pre --|&gt; NamedStatementBlockRule Post --|&gt; NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * EplModule -- Pattern: patterns * Pattern -- Role: roles * Role -- Domain: domain Domain &lt;|-- StaticDomain Domain &lt;|-- DynamicDomain Role -- Cardinality: cardinality <p>In its simplest form a pattern consists of a number of named and typed roles and a match condition. For example, in lines 2-3, the PublicField pattern below, defines four roles (class, field, setter and getter). The match condition of the pattern specifies that for a quartet to be a valid match, the field, setter and getter must all belong to the class (lines 5-7, and that the setter and getter methods must be appropriately named1.</p> <pre><code>pattern PublicField\n    class : ClassDeclaration, field : FieldDeclaration, \n    setter : MethodDeclaration, getter : MethodDeclaration {\n\n    match : class.bodyDeclarations.includes(field) \n        class.bodyDeclarations.includes(setter) and\n        class.bodyDeclarations.includes(getter) and \n        setter.name = \"set\" + field.getName() and\n        (getter.name = \"get\" + field.getName() or\n        getter.name = \"is\" + field.getName()) \n}\n\n@cached\noperation FieldDeclaration getName() {\n    return self.fragments.at(0).name.firstToUpperCase();\n}</code></pre> <p>The implementation of the PublicField pattern above is fully functional but not particularly efficient as the match condition needs to be evaluated <code>#ClassDefinition * #FieldDeclaration * #MethodDeclaration^2</code> times. To enable pattern developers to reduce the search space, each role in an EPL pattern can specify a domain which is an EOL expression that returns a collection of model elements from which the role will draw values.</p> <p>There are two types of domains in EPL: static domains which are computed once for all applications of the pattern, and which are not dependent on the bindings of other roles of the pattern (denoted using the in keyword in terms of the concrete syntax), and dynamic domains which are recomputed every time the candidate values of the role are iterated, and which are dependent on the bindings of other roles (denoted using the from keyword). Beyond a domain, each role can also specify a guard expression that further prunes unnecessary evaluations of the match condition. Using dynamic domains and guards, the PublicField pattern can be expressed in a more efficient way, as illustrated below. To further illustrate the difference between dynamic and static domains, changing from to in in line 4 would trigger a runtime exception as the domain would become static and therefore not able to access bindings of other roles (i.e. class).</p> <pre><code>pattern PublicField\n    class : ClassDeclaration,\n    field : FieldDeclaration\n        from: class.bodyDeclarations,\n    setter : MethodDeclaration\n        from: class.bodyDeclarations\n        guard: setter.name = \"set\" + field.getName(),\n    getter : MethodDeclaration\n        from: class.bodyDeclarations \n        guard : (getter.name = \"get\" + field.getName() or\n                 getter.name = \"is\" + field.getName()) { }</code></pre> <p>The implementation above is significantly more efficient than the previous implementation but can still be improved by further reducing the number of name comparisons of candidate setter and getter methods. To achieve this we can employ memoisation: we create a hash map of method names and methods once before pattern matching (line 2), and use it to identify candidate setters and getters (lines 9 and 12-13).</p> <pre><code>pre {\n    var methodMap = MethodDeclaration.all.mapBy(m|m.name);\n}\npattern PublicField\n    class : ClassDeclaration,\n    field : FieldDeclaration\n        from: class.bodyDeclarations,\n    setter : MethodDeclaration\n        from: getMethods(\"set\" + field.getName()) \n        guard: setter.abstractTypeDeclaration = class,\n    getter : MethodDeclaration\n        from: getMethods(\"get\" + field.getName())\n                .includingAll(getMethods(\"is\" + field.getName())),\n        guard: getter.abstractTypeDeclaration = class {\n}\n\noperation getMethods(name : String) : Sequence(MethodDeclaration) {\n    var methods = methodMap.get(name);\n    if (methods.isDefined()) return methods;\n    else return new Sequence;\n}</code></pre> <p>The sections below discuss the remainder of the syntax of EPL.</p>"},{"location":"doc/epl/#negative-roles","title":"Negative Roles","text":"<p>Pattern roles can be negated using the no keyword. For instance, by adding the no keyword before the setter role in line 8 of the listing above, the pattern will match fields that have getters but no setters (i.e. read-only fields).</p>"},{"location":"doc/epl/#optional-and-active-roles","title":"Optional and Active Roles","text":"<p>Pattern roles can be designated as optional using the optional EOL expression. For example, adding <code>optional: true</code> to the setter role would also match all fields that only have a getter. By adding <code>optional: true</code> to the setter role and <code>optional: setter.isDefined()</code> to the getter role, the pattern would match fields that have at least a setter or a getter. Roles can be completely deactivated depending on the bindings of other roles through the active construct. For example, if the pattern developer prefers to specify separate roles for getX and isX getters, with a preference over getX getters, the pattern can be formulated as illustrated in the listing below so that if a getX getter is found, no attempt is even made to match an isX getter.</p> <pre><code>pattern PublicField\n    class : ClassDeclaration,\n    field : FieldDeclaration ...,\n    setter : MethodDeclaration ...,\n    getGetter : MethodDeclaration ...,\n    isGetter: MethodDeclaration\n        ...\n        active: getGetter.isUndefined() {\n}</code></pre>"},{"location":"doc/epl/#role-cardinality","title":"Role Cardinality","text":"<p>The cardinality of a role (lower and upper bound) can be defined in square brackets following the type of the role. Roles that have a cardinality with an upper bound &gt; 1 are bound to the subset of elements from the domain of the role which also satisfy the guard, if the size of that subset is within the bounds of the role's cardinality. The listing below demonstrates the ClassAndPrivateFields pattern that detects instances of classes and all their private fields. If the cardinality of the field role in line 3 was [1..3] instead of [*], the pattern would only detect classes that own 1 to 3 private fields.</p> <pre><code>pattern ClassAndPrivateFields\n    class : ClassDeclaration,\n    field : FieldDeclaration[*]\n        from: class.bodyDeclarations\n        guard: field.getVisibility() = VisibilityKind#private {\n\n    onmatch { \n        var message : String;\n        message = class.name + \" matches\";\n        message.println();\n    }\n\n    do { \n        // More actions here\n    }\n\n    nomatch : (class.name + \" does not match\").println()\n\n}\noperation FieldDeclaration getVisibility() {\n    if (self.modifier.isDefined()) {\n        return self.modifier.visibility; }\n    else { return null; }\n}</code></pre>"},{"location":"doc/epl/#execution-semantics","title":"Execution Semantics","text":"<p>When an EPL module is executed, all of its pre statement blocks are first executed in order to define and initialise any global variables needed (e.g. the methodMap variable in the listing above or to print diagnostic messages to the user. Subsequently, patterns are executed in the order in which they appear. For each pattern, all combinations that conform to the type and constraints of the roles of the pattern are iterated, and the validity of each combination is evaluated in the match statement block of the pattern. In the absence of a match block, every combination that satisfies the constraints of the roles of the pattern is accepted as a valid instance of the pattern.</p> <p>Immediately after every successful match, the optional onmatch statement block of the pattern is invoked (see lines 7-11 of the listing above) and after every unsuccessful matching attempt, for combinations which however satisfy the constraints specified by the roles of the pattern, the optional nomatch statement block of the pattern (line 17) is executed . When matching of all patterns is complete, the do part (line 13) of each successful match is executed. In the do part, developers can modify the involved models (e.g to perform in-place transformation), without the risk of concurrent list modification errors (which can occur if elements are created/deleted during pattern matching). After pattern matching has been completed, the post statement blocks of the module are executed in order to perform any necessary finalisation actions.</p> <p>An EPL module can be executed in a one-off or iterative mode. In the one-off mode, patterns are only evaluated once, while in the iterative mode, the process is repeated until no more matches have been found or until the maximum number of iterations (specified by the developer) has been reached. The iterative mode is particularly suitable for patterns that perform reduction of the models they are evaluated against.</p>"},{"location":"doc/epl/#pattern-matching-output","title":"Pattern Matching Output","text":"<p>The output of the execution of an EPL module on a set of models is a collection of matches encapsulated in a PatternMatchModel, as illustrated in the figure below. As PatternMatchModel implements the IModel EMC interface, its instances can be accessed from other programs expressed in languages of the Epsilon family.</p> classDiagram class Match {     +bindings: Map&lt;String, Object&gt; } IModel --|&gt; PatternMatchModel PatternMatchModel -- Pattern: patterns * PatternMatchModel -- Match: matches * <p>A PatternMatchModel introduces one model element type for each pattern and one type for each field of each pattern (the name of these types are derived by concatenating the name of the pattern with a camel-case version of the name of the field). Instances of the prior are the matches of the pattern while instances of the latter are elements that have been matched in this particular role. For example, after executing the EPL module above, the produced PatternMatchModel contains 5 types: PublicField, instances of which are all the identified matches of the PublicField pattern, PublicFieldClass, instances of which are all the classes in the input model which have been matched to the class role in instances of the PublicField pattern, and similarly PublicFieldField, PublicFieldSetter and PublicFieldGetter.</p>"},{"location":"doc/epl/#interoperability-with-other-model-management-tasks","title":"Interoperability with Other Model Management Tasks","text":"<p>As a PatternMatchModel is an instance of IModel, after its computation it can be manipulated by other Epsilon programs. For example, the listing below demonstrates running the EPL module and passing its output to the EVL constraints that follow and, if validation is successful, to an ETL transformation where it is used to guide the generation of a UML model.</p> <p>In lines 4-7, the Java model is loaded and is assigned the name <code>Java</code>. Then, in line 9, the Java model is passed on to <code>publicfield.epl</code> for pattern matching. The result of pattern matching, which is an instance of the <code>PatternMatchModel</code> class (and therefore also an instance of <code>IModel</code>) is exported to the global context under the name <code>Patterns</code>. Then, in line 13, both the <code>Patterns</code> and the <code>Java</code> models are passed on to the EVL model validation task which performs validation of the identified pattern matches.</p> <pre><code>&lt;project default=\"main\"&gt;\n&lt;target name=\"main\"&gt;\n\n&lt;epsilon.emf.loadModel name=\"Java\"\nmodelfile=\"org.eclipse.epsilon.eol.engine_java.xmi\" metamodeluri=\"...MoDisco/Java/0.2.incubation/java\"\nread=\"true\" store=\"false\"/&gt;\n\n&lt;epsilon.epl src=\"publicfield.epl\" exportAs=\"Patterns\"&gt;\n&lt;model ref=\"Java\"/&gt;\n&lt;/epsilon.epl&gt; &lt;epsilon.evl src=\"constraints.evl\"&gt; &lt;model ref=\"Patterns\"/&gt;\n&lt;model ref=\"Java\"/&gt;\n&lt;/epsilon.evl&gt; &lt;epsilon.etl src=\"java2uml.etl\"&gt; &lt;model ref=\"Patterns\"/&gt;\n&lt;model ref=\"Java\"/&gt;\n&lt;/epsilon.etl&gt;\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre> <p>Line 1 below defines a set of constraints that will be applied to instances of the PublicField type from the Patterns model. As discussed above, these are all matched instances of the PublicField pattern. Line 4, specifies the condition that needs to be satisfied by instances of the pattern. Notice the self.getter and self.field expressions which return the MethodDeclaration and FieldDeclaration bound to the instance of the pattern. Then, line 5 defines the message that should be produced for instances of PublicField that do not satisfy this constraint.</p> <pre><code>context Patterns!PublicField {\n    guard: self.field.type.isDefined()\n    constraint GetterAndFieldSameType { \n        check : self.getter.returnType.type = self.field.type.type\n        message : \"The getter of \" + self.class.name + \".\"\n            + self.field.fragments.at(0).name +\n            \" does not have the same type as the field itself\"\n    }\n}</code></pre> <p>If validation is successful, both the Java and the Patterns model are passed on to an ETL transformation that transforms the Java model to a UML model, a fragment of which is presented below. The transformation encodes <code>&lt;field, setter, getter&gt;</code> triplets in the Java model as public properties in the UML model. As such, in line 6 of the transformation, the Patterns model is used to check whether field s has been matched under the PublicField pattern, and if so, the next line ignores the field's declared visibility and sets the visibility of the respective UML property to public.</p> <pre><code>rule FieldDeclaration2Property\n    transform s: Java!FieldDeclaration\n    to t: Uml!Property {\n\n    t.name = s.getName();\n    if (s.instanceOf(Patterns!PublicFieldField)) {\n        t.visibility = Uml!VisibilityKind#public;\n    }\n    else {\n        t.visibility = s.toUmlVisibility();\n    }\n    ...\n}</code></pre> <p>As Epsilon provides ANT tasks for all its languages, the same technique can be used to pass the result of pattern matching on to model-to-text transformations, as well as model comparison and model merging programs.</p> <ol> <li> <p>To maintain the running example simple and concise, the pattern does not check aspects such as matching/compatible parameter/return types in the field, setter and getter but the reader should easily be able to envision how this would be supported through additional clauses in the match condition.\u00a0\u21a9</p> </li> </ol>"},{"location":"doc/etl/","title":"The Epsilon Transformation Language (ETL)","text":"<p>The aim of ETL is to contribute model-to-model transformation capabilities to Epsilon. More specifically, ETL can be used to transform an arbitrary number of input models into an arbitrary number of output models of different modelling languages and technologies in a rule-based and modular manner.</p> <p>Try ETL online</p> <p>You can run and fiddle with an ETL transformation that transforms a tree model to a graph model in the online Epsilon Playground.</p>"},{"location":"doc/etl/#abstract-syntax","title":"Abstract Syntax","text":"<p>As illustrated in the figure below, ETL transformations are organized in modules (<code>EtlModule</code>). A module can contain a number of transformation rules (<code>TransformRule</code>). Each rule has a unique name (in the context of the module) and also specifies one <code>source</code> and many <code>target</code> parameters. A transformation rule can also <code>extend</code> a number of other transformation rules and be declared as <code>abstract</code>, <code>primary</code> and/or <code>lazy</code>1. To limit its applicability to a subset of elements that conform to the type of the <code>source</code> parameter, a rule can optionally define a guard which is either an EOL expression or a block of EOL statements. Finally, each rule defines a block of EOL statements (<code>body</code>) where the logic for populating the property values of the target model elements is specified.</p> <p>Besides transformation rules, an ETL module can also optionally contain a number of <code>pre</code> and <code>post</code> named blocks of EOL statements which, as discussed later, are executed before and after the transformation rules respectively. These should not be confused with the pre-/post-condition annotations available for EOL user-defined operations.</p> classDiagram class TransformRule {     -name: String     -abstract: Boolean     -lazy: Boolean     -primary: Boolean     -greedy: Boolean     -type: EolModelElementType     -guard: ExecutableBlock&lt;Boolean&gt;     -body: ExecutableBlock&lt;Void&gt; } class Parameter {     -name: String     -type: EolType  } class NamedStatementBlockRule {     -name: String     -body: StatementBlock } EolModule &lt;|-- ErlModule EtlModule --|&gt; ErlModule Pre --|&gt; NamedStatementBlockRule Post --|&gt; NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * EtlModule -- TransformRule: rules * TransformRule -- Parameter: source TransformRule -- Parameter: targets * TransformRule -- TransformRule: extends *"},{"location":"doc/etl/#concrete-syntax","title":"Concrete Syntax","text":"<p>The concrete syntax of a transformation rule is displayed in the listing below. The optional <code>abstract</code>, <code>lazy</code> and <code>primary</code> attributes of the rule are specified using respective annotations. The name of the rule follows the <code>rule</code> keyword and the <code>source</code> and <code>target</code> parameters are defined after the <code>transform</code> and <code>to</code> keywords. Also, the rule can define an optional comma-separated list of rules it extends after the <code>extends</code> keyword. Inside the curly braces ({}), the rule can optionally specify its <code>guard</code> either as an EOL expression following a colon (:) (for simple guards) or as a block of statements in curly braces (for more complex guards). Finally, the <code>body</code> of the rule is specified as a sequence of EOL statements.</p> <pre><code>(@abstract)?\n(@lazy)?\n(@primary)?\nrule &lt;name&gt;\n    transform &lt;sourceParameterName&gt;:&lt;sourceParameterType&gt;\n    to &lt;targetParameterName&gt;:&lt;targetParameterType&gt;\n        (,&lt;targetParameterName&gt;:&lt;targetParameterType&gt;)*\n    (extends &lt;ruleName&gt; (, &lt;ruleName&gt;*)? {\n\n    (guard (:expression)|({statementBlock}))?\n\n    statement+\n}\n</code></pre> <p><code>Pre</code> and <code>post</code> blocks have a simple syntax that, as presented the listing below, consists of the identifier (<code>pre</code> or <code>post</code>), an optional name and the set of statements to be executed enclosed in curly braces.</p> <pre><code>(pre|post) &lt;name&gt; {\n    statement+\n}\n</code></pre>"},{"location":"doc/etl/#execution-semantics","title":"Execution Semantics","text":""},{"location":"doc/etl/#rule-and-block-overriding","title":"Rule and Block Overriding","text":"<p>Similarly to EOL, an ETL module can import a number of other ETL modules. In this case, the importing ETL module inherits all the rules and pre/post blocks specified in the modules it imports (recursively). If the module specifies a rule or a pre/post block with the same name, the local rule/block overrides the imported one respectively.</p>"},{"location":"doc/etl/#rule-execution-scheduling","title":"Rule Execution Scheduling","text":"<p>When an ETL module is executed, the <code>pre</code> blocks of the module are executed first in the order in which they have been specified.</p> <p>Following that, each non-abstract and non-lazy rule is executed for all the elements on which it is applicable. To be applicable on a particular element, the element must have a type-of relationship with the type defined in the rule's <code>sourceParameter</code> (or a kind-of relationship if the rule is annotated as <code>@greedy</code>) and must also satisfy the <code>guard</code> of the rule (and all the rules it extends). When a rule is executed on an applicable element, the target elements are initially created by instantiating the <code>targetParameters</code> of the rules, and then their contents are populated using the EOL statements of the <code>body</code> of the rule.</p> <p>Finally, when all rules have been executed, the <code>post</code> blocks of the module are executed in the order in which they have been declared.</p>"},{"location":"doc/etl/#source-elements-resolution","title":"Source Elements Resolution","text":"<p>Resolving target elements that have been (or can be) transformed from source elements by other rules is a frequent task in the body of a transformation rule. To automate this task and reduce coupling between rules, ETL contributes the <code>equivalents()</code> and <code>equivalent()</code> built-in operations that automatically resolve source elements to their transformed counterparts in the target models.</p> <p>The <code>equivalents()</code> operation can be invoked on both single source elements and on collections of source elements:</p> <ul> <li> <p>On a single source element, it inspects the established transformation trace (displayed in the figure below) and invokes the applicable rules (if necessary) to calculate the counterparts of the element in the target model.</p> </li> <li> <p>On a collection, it returns a <code>Bag</code> containing <code>Bag</code>s that in turn contain the counterparts of the source elements contained in the collection. </p> </li> </ul> <p>The <code>equivalents()</code> operation can be also invoked with an arbitrary number of rule names as parameters, to invoke and return only the equivalents created by specific rules. Unlike the main execution scheduling scheme discussed above, the <code>equivalents()</code> operation invokes both lazy and non-lazy rules. It is worth noting that lazy rules are computationally expensive and should be used with caution as they can significantly degrade the performance of the overall transformation.</p> <p>With regard to the ordering of the results of the <code>equivalents()</code> operations, the returned elements appear in the respective order of the rules that have created them. An exception to this occurs when one of the rules is declared as <code>primary</code>, in which case its results precede the results of all other rules.</p> classDiagram  class Transformation {     -source: Object     -targets: Object[*] }  class ITransformationStrategy {     +transformModels(context : EtlContext) }  EolContext &lt;|-- EtlContext EtlContext -- TransformationTrace EtlContext -- ITransformationStrategy: strategy TransformationTrace -- Transformation: transformations * Transformation -- TransformRule: rule <p>ETL also provides the convenient <code>equivalent()</code> operation:</p> <ul> <li>When applied to a single element, <code>equivalent()</code> returns only the first element of the respective result that would have been returned by the <code>equivalents()</code> operation discussed above.</li> <li>When applied to a collection, the <code>equivalent()</code> operation returns a flattened version (i.e. a <code>Bag</code> of model elements) of the <code>Bag</code> of <code>Bags</code> that <code>equivalents()</code> would have returned.</li> </ul> <p>As with the <code>equivalents()</code> operation, the <code>equivalent()</code> operation can also be invoked with or without parameters.</p> <p>The semantics of the <code>equivalent()</code> operation are further illustrated through a simple example. In this example, we need to transform a model that conforms to the Tree metamodel displayed below into a model that conforms to the Graph metamodel, also displayed below.</p> classDiagram class Node {     +label: String     +incoming: Edge[*]     +outgoing: Edge[*] } class Edge {     +source: Node     +target: Node } class Tree {     +name: String     +parent: Tree     +children: Tree[*] } Tree -- Tree Node -- Edge Edge -- Node <p>More specifically, we need to transform each <code>Tree</code> element to a <code>Node</code>, and an <code>Edge</code> that connects it with the <code>Node</code> that is equivalent to the tree's <code>parent</code>. This is achieved using the rule below.</p> <pre><code>rule Tree2Node\n    transform t : Tree!Tree\n    to n : Graph!Node {\n\n    n.label = t.label;\n\n    if (t.parent.isDefined()) {\n        var edge = new Graph!Edge;\n        edge.source = n;\n        edge.target = t.parent.equivalent();\n    }\n}</code></pre> <p>In lines 1--3, the <code>Tree2Node</code> rule specifies that it can transform elements of the <code>Tree</code> type in the <code>Tree</code> model into elements of the <code>Node</code> type in the <code>Graph</code> model. In line\u00a05 it specifies that the label of the created Node should be the same as the label of the source Tree. If the parent of the source <code>Tree</code> is defined (line\u00a07), the rule creates a new <code>Edge</code> (line\u00a08) and sets its <code>source</code> property to the created <code>Node</code> (line\u00a09) and its <code>target</code> property to the <code>equivalent</code> <code>Node</code> of the source <code>Tree</code>'s <code>parent</code> (line\u00a010).</p> <p>The Epsilon Playground includes a more comprehensive version of this example, providing comparisons between the various ways to use the <code>equivalent()</code> and <code>equivalents()</code> operations.</p>"},{"location":"doc/etl/#persisting-the-transformation-trace","title":"Persisting the transformation trace","text":"<p>ETL does not provide built-in support for persisting the transformation trace, however, you can access it through <code>System.context.transformationTrace</code> and persist (parts of) it in a format of your choice (e.g. in a <code>post</code> block of your transformation).</p>"},{"location":"doc/etl/#overriding-the-semantics-of-the-eol-special-assignment-operator","title":"Overriding the semantics of the EOL Special Assignment Operator","text":"<p>As discussed above, resolving the equivalent(s) or source model elements in the target model is a recurring task in model transformation. Furthermore, in most cases resolving the equivalent of a model element is immediately followed by assigning/adding the obtained target model elements to the value(s) of a property of another target model element. For example, in line 10 of the listing above, the <code>equivalent</code> obtained is immediately assigned to the <code>target</code> property of the generated <code>Edge</code>. To make transformation specifications more readable, ETL overrides the semantics of the <code>SpecialAssignmentStatement</code> (<code>::=</code> in terms of concrete syntax), to set its left-hand side, not to the element its right-hand side evaluates to, but to its <code>equivalent</code> as calculated using the <code>equivalent()</code> operation discussed above. Using this feature, line 10 of the <code>Tree2Node</code> rule can be rewritten as shown below.</p> <pre><code>edge.target ::= t.parent;\n</code></pre>"},{"location":"doc/etl/#interactive-transformations","title":"Interactive Transformations","text":"<p>Using the user interaction facilities of EOL, an ETL transformation can become interactive by prompting the user for input during its execution. For example in the listing below, we modify the <code>Tree2Node</code> rule by adding a <code>guard</code> part that uses the user-input facilities of EOL (more specifically the <code>UserInput.confirm(String,Boolean)</code> operation) to enable the user select manually at runtime which of the Tree elements need to be transformed to respective Node elements in the target model and which not.</p> <pre><code>rule Tree2Node\n    transform t : Tree!Tree\n    to n : Graph!Node {\n\n    guard : UserInput.confirm\n        (\"Transform tree \" + t.label + \"?\", true)\n\n    n.label = t.label;\n    var target : Graph!Node ::= t.parent;\n    if (target.isDefined()) {\n        var edge = new Graph!Edge;\n        edge.source = n;\n        edge.target = target;\n    }\n}</code></pre>"},{"location":"doc/etl/#additional-resources","title":"Additional Resources","text":"<p>Additional resources about ETL are available here.</p> <ol> <li> <p>The concept of lazy rules was first introduced in ATL\u00a0\u21a9</p> </li> </ol>"},{"location":"doc/eunit/","title":"The Epsilon Unit Testing Framework (EUnit)","text":"<p>EUnit is an unit testing framework specifically designed to test model management tasks, based on EOL and the Ant workflow tasks. It provides assertions for comparing models, files and directories. Tests can be reused with different sets of models and input data, and differences between the expected and actual models can be graphically visualized. This chapter describes how tests are organized and written and shows two examples of how a model-to-model transformation can be tested with EUnit. This chapter ends with a discussion of how EUnit can be extended to support other modelling and model management technologies.</p>"},{"location":"doc/eunit/#common-issues","title":"Common Issues","text":"<p>While each type of model management task does have specific complexity, below is a list of common concerns:</p> <ul> <li> <p>There is usually a large number of models to be handled. Some may be created by hand, some may be generated using hand-written programs, and some may be generated automatically following certain coverage criteria.</p> </li> <li> <p>A single model or set of models may be used in several tasks. For instance, a model may be validated before performing an in-place transformation to assist the user, and later on it may be transformed to another model or merged with a different model. This requires having at least one test for each valid combination of models and sets of tasks.</p> </li> <li> <p>Test oracles are more complex than in traditional unit testing: instead of checking scalar values or simple lists, entire graphs of model objects or file trees may have to be compared. In some cases, complex properties in the generated artifacts may have to be checked.</p> </li> <li> <p>Models and model management tasks may use a wide range of technologies. Models may be based on Ecore, XML files or Java object graphs, among many others. At the same time, tasks may use technologies from different platforms, such as Epsilon, or AMMA. Many of these technologies offer high-level tools for running and debugging the different tasks using several models. However, users wishing to do automated unit testing need to learn low-level implementation details about their modelling and model management technologies. This increases the initial cost of testing these tasks and hampers the adoption of new technologies.</p> </li> <li> <p>Existing testing tools tend to focus on the testing technique itself, and lack integration with external systems. Some tools provide graphical user interfaces, but most do not generate reports which can be consumed by a continuous integration server, for instance.</p> </li> </ul>"},{"location":"doc/eunit/#testing-with-junit","title":"Testing with JUnit","text":"<p>The previous issues are easier to understand with a concrete example. This section shows how a simple transformation between two EMF models in ETL using JUnit 4 would be normally tested, and points out several issues due to JUnit's limitations as a general-purpose unit testing framework for Java programs.</p> <p>For the sake of brevity, only an outline of the JUnit test suite is included. All JUnit test suites are defined as Java classes. This test suite has three methods:</p> <ol> <li>The test setup method (marked with the <code>@Before</code> JUnit annotation) loads the required models by creating and configuring instances of <code>EmfModel</code>. After that, it prepares the transformation by creating and configuring an instance of <code>EtlModule</code>, adding the input and output models to its model repository.</li> <li>The test case itself (marked with <code>@Test</code>) runs the ETL transformation and uses the generic comparison algorithm implemented by EMF Compare to perform the model comparison.</li> <li>The test teardown method (marked with <code>@After</code>) disposes of the models.</li> </ol> <p>Several issues can be identified in each part of the test suite. First, test setup is tightly bound to the technologies used: it depends on the API of the <code>EmfModel</code> and <code>EtlModule</code> classes, which are both part of Epsilon. Later refactorings in these classes may break existing tests.</p> <p>The test case can only be used for a single combination of input and output models. Testing several combinations requires either repeating the same code and therefore making the suite less maintainable, or using parametric testing, which may be wasteful if not all tests need the same combinations of models.</p> <p>Model comparison requires the user to manually select a model comparison engine and integrate it with the test. For comparing EMF models, EMF Compare is easy to use and readily available. However, generic model comparison engines may not be available for some modelling technologies, or may be harder to integrate.</p> <p>Finally, instead of comparing the obtained and expected models, several properties could have been checked in the obtained model. However, querying models through Java code can be quite verbose.</p>"},{"location":"doc/eunit/#selected-approach","title":"Selected Approach","text":"<p>Several approaches could be followed to address these issues. Our first instinct would be to extend JUnit and reuse all the tooling available for it. A custom test runner would simplify setup and teardown, and modelling platforms would integrate their technologies into it. Since Java is very verbose when querying models, the custom runner should run tests in a higher-level language, such as EOL. However, JUnit is very tightly coupled to Java, and this would impose limits on the level of integration we could obtain. For instance, errors in the model management tasks or the EOL tests could not be reported from their original source, but rather from the Java code which invoked them. Another problem with this approach is that new integration code would need to be written for each of the existing platforms.</p> <p>Alternatively, we could add a new language exclusively dedicated to testing to the Epsilon family. Being based on EOL, model querying would be very concise, and with a test runner written from scratch, test execution would be very flexible. However, this would still require all platforms to write new code to integrate with it, and this code would be tightly coupled to Epsilon.</p> <p>As a middle ground, we could decorate EOL to guide its execution through a new test runner, while reusing the Apache Ant tasks already provided by several of the existing platforms, such as AMMA or Epsilon. Like Make, Ant is a tool focused on automating the execution of processes such as program builds. Unlike Make, Ant defines processes using XML buildfiles with sets of interrelated targets. Each target contains in turn a sequence of tasks. Many Ant tasks and Ant-based tools already exist, and it is easy to create a new Ant task.</p> <p>Among these three approaches, EUnit follows the last one. Ant tasks take care of model setup and management, and tests are written in EOL and executed by a new test runner, written from the ground up.</p>"},{"location":"doc/eunit/#test-organization","title":"Test Organization","text":"<p>EUnit has a rich data model: test suites are organized as trees of tests, and each test is divided into many parts which can be extended by the user. This section is dedicated to describing how test suites and tests are organized. The next section indicates how they are written.</p>"},{"location":"doc/eunit/#test-suites","title":"Test Suites","text":"<p>EUnit test suites are organized as trees: inner nodes group related test cases and define data bindings. Leaf nodes define model bindings and run the test cases.</p> <p>Data bindings repeat all test cases with different values in one or more variables. They can implement parametric testing, as in JUnit 4. EUnit can nest several data bindings, running all test cases once for each combination.</p> <p>Model bindings are specific to EUnit: they allow developers to repeat a single test case with different subsets of models. Data and model bindings can be combined. One interesting approach is to set the names of the models to be used in the model binding from the data binding, as a quick way to try several test cases with the same subsets of models.</p> <p>The figure below shows an example of an EUnit test tree: nodes with data bindings are marked with <code>data</code>, and nodes with model bindings are marked with <code>model</code>.</p> graph TD     data1[data&lt;br/&gt;x=1]     data2[data&lt;br/&gt;x=2]     testa1[test A]     testb1[test B]     testa2[test A]     testb2[test B]     modelx1[model X]     modely1[model Y]     modelx2[model X]     modely2[model Y]     root --&gt; data1     root --&gt; data2     data1 --&gt; testa1     data1 --&gt; testb1     data2 --&gt; testa2     data2 --&gt; testb2     testa1 --&gt; modelx1     testa1 --&gt; modely1     testa2 --&gt; modelx2     testa2 --&gt; modely2 <p>EUnit will perform a preorder traversal of this tree, running the following tests:</p> <ol> <li> <p><code>A</code> with <code>x = 1</code> and model X.</p> </li> <li> <p><code>A</code> with <code>x = 1</code> and model Y.</p> </li> <li> <p><code>B</code> with <code>x = 1</code> and both models.</p> </li> <li> <p><code>A</code> with <code>x = 2</code> and model X.</p> </li> <li> <p><code>A</code> with <code>x = 2</code> and model Y.</p> </li> <li> <p><code>B</code> with <code>x = 2</code> and both models.</p> </li> </ol> <p>Optionally, EUnit can filter tests by name, running only <code>A</code> or <code>B</code>. Similarly to JUnit, EUnit logs start and finish times for each node in the tree, so the most expensive test cases can be quickly detected. However, EUnit logs CPU time1 in addition to the usual wallclock time.</p> <p>Parametric testing is not to be confused with theories: both repeat a test case with different values, but results are reported quite differently. While parametric testing produces separate test cases with independent results, theories produce aggregated tests which only pass if the original test case passes for every data point. The figures below illustrate these differences. EUnit does not support theories yet: however, they can be approximated with data bindings.</p> <p>graph TD     data1[data 1]     data2[data 2]     testa1[test 1]     testb1[test 2]     testa2[test 1]     testb2[test 2]     root --&gt; data1     root --&gt; data2     data1 --&gt; testa1     data1 --&gt; testb1     data2 --&gt; testa2     data2 --&gt; testb2 Parametric Testing</p> <p>graph TD     data1[test 1]     data2[test 2]     testa1[data 1]     testb1[data 2]     testa2[data 1]     testb2[data 2]     root --&gt; data1     root --&gt; data2     data1 --&gt; testa1     data1 --&gt; testb1     data2 --&gt; testa2     data2 --&gt; testb2 Theories</p>"},{"location":"doc/eunit/#test-cases","title":"Test Cases","text":"<p>The execution of a test case is divided into the following steps:</p> <ol> <li> <p>Apply the data bindings of its ancestors.</p> </li> <li> <p>Run the model setup sections defined by the user.</p> </li> <li> <p>Apply the model bindings of this node.</p> </li> <li> <p>Run the regular setup sections defined by the user.</p> </li> <li> <p>Run the test case itself.</p> </li> <li> <p>Run the teardown sections defined by the user.</p> </li> <li> <p>Tear down the data bindings and models for this test.</p> </li> </ol> <p>An important difference between JUnit and EUnit is that setup is split into two parts: model setup and regular setup. This split allows users to add code before and after model bindings are applied. Normally, the model setup sections will load all the models needed by the test suite, and the regular setup sections will further prepare the models selected by the model binding. Explicit teardown sections are usually not needed, as models are disposed automatically by EUnit. EUnit includes them for consistency with the xUnit frameworks.</p> <p>Due to its focus on model management, model setup in EUnit is very flexible. Developers can combine several ways to set up models, such as model references, individual Apache Ant tasks, Apache Ant targets or Human-Usable Text Notation (HUTN) fragments.</p> <p>A test case may produce one among several results. <code>SUCCESS</code> is obtained if all assertions passed and no exceptions were thrown. <code>FAILURE</code> is obtained if an assertion failed. <code>ERROR</code> is obtained if an unexpected exception was thrown while running the test. Finally, tests may be <code>SKIPPED</code> by the user.</p>"},{"location":"doc/eunit/#test-specification","title":"Test Specification","text":"<p>In the previous section, we described how test suites and test cases are organized. In this section, we will show how to write them.</p> <p>As discussed before, after evaluating several approaches, we decided to combine the expressive power of EOL and the extensibility of Apache Ant. For this reason, EUnit test suites are split into two files: an Ant buildfile and an EOL script with some special-purpose annotations. The next subsections describe the contents of these two files and revisit the previous example with EUnit.</p>"},{"location":"doc/eunit/#ant-buildfile","title":"Ant Buildfile","text":"<p>EUnit uses standard Ant buildfiles: running EUnit is as simple as using its Ant task. Users may run EUnit more than once in a single Ant launch: the graphical user interface will automatically aggregate the results of all test suites.</p>"},{"location":"doc/eunit/#eunit-invocations","title":"EUnit Invocations","text":"<p>An example invocation of the EUnit Ant task using the most common features is shown in the listing below. Users will normally only use some of these features at a time, though. Optional attributes have been listed between brackets. Some nested elements can be repeated 0+ times (<code>*</code>) or 0-1 times (<code>?</code>). Valid alternatives for an attribute are separated with <code>|</code>.</p> <pre><code>&lt;epsilon.eunit src=\"...\"\n[failOnErrors=\"...\"]\n[package=\"..\"]\n[toDir=\"...\"]\n[report=\"yes|no\"]\n[saveModelDeltas=\"yes|no\"]&gt;\n(&lt;model     ref=\"OldName\" [as=\"NewName\"]/&gt;)*\n  (&lt;uses      ref=\"x\" [as=\"y\"] /&gt;)*\n  (&lt;exports   ref=\"z\" [as=\"w\"] /&gt;)*\n  (&lt;parameter name=\"myparam\" value=\"myvalue\" /&gt;)*\n  (&lt;modelTasks&gt;&lt;!-- Zero or more Ant tasks --&gt;&lt;/modelTasks&gt;)?\n&lt;/epsilon.eunit&gt;\n</code></pre> <p>The EUnit Ant task is based on the Epsilon abstract executable module task, inheriting some useful features. The attribute <code>src</code> points to the path of the EOL file, and the optional attribute <code>failOnErrors</code> can be set to false to prevent EUnit from aborting the Ant launch if a test case fails. EUnit also inherits support for importing and exporting global variables through the <code>&lt;uses&gt;</code> and <code>&lt;exports&gt;</code> elements: the original name is set in <code>ref</code>, and the optional <code>as</code> attribute allows for using a different name. For receiving parameters as name-value piars, the <code>&lt;parameter&gt;</code> element can be used.</p> <p>Model references (using the <code>&lt;model&gt;</code> nested element) are also inherited from the Epsilon abstract executable module task. These allow model management tasks to refer by name to models previously loaded in the Ant buildfile. However, EUnit implicitly reloads the models after each test case. This ensures that test cases are isolated from each other.</p> <p>The optional <code>&lt;modelTasks&gt;</code> nested element contains a sequence of Ant tasks which will be run after reloading the model references and before running the model setup sections in the EOL file. This allows users to run workflows more advanced than simply reloading model references.</p> <p>The EUnit Ant task adds several new features to customize the test result reports and perform more advanced model setup. By default, EUnit generates reports in the XML format of the Ant <code>&lt;junit&gt;</code> task. This format is also used by many other tools, such as the TestNG unit testing framework, the Jenkins continuous integration server or the JUnit Eclipse plug-ins. To suppress these reports, report must be set to no.</p> <p>By default, the XML report is generated in the same directory as the Ant buildfile, but it can be changed with the <code>toDir</code> attribute. Test names in JUnit are formed by its Java package, class and method: EUnit uses the filename of the EOL script as the class and the name of the EOL operation as the method. By default, the package is set to the string \"default\": users are encouraged to customize it with the <code>package</code> attribute.</p> <p>Since v2.4.0, <code>saveModelDeltas</code> can be set to <code>\"yes\"</code> to have EUnit save any detected differences to \"delta\" files in the native representation of the chosen comparator, which will refer to \"frozen\" copies of the models in a <code>eunit-tmp</code> subfolder of the build.</p>"},{"location":"doc/eunit/#helper-targets","title":"Helper Targets","text":"<p>Ant buildfiles for EUnit may include helper targets. These targets can be invoked using from anywhere in the EOL script. Helper targets are quite versatile: called from an EOL model setup section, they allow for reusing model loading fragments between different EUnit test suites. They can also be used to invoke the model management tasks under test. </p>"},{"location":"doc/eunit/#eol-script","title":"EOL script","text":"<p>The Epsilon Object Language script is the second half of the EUnit test suite. EOL annotations are used to tag some of the operations as data binding definitions (<code>@data</code> or <code>@Data</code>), additional model setup sections (<code>@model</code>/<code>@Model</code>), test setup and teardown sections (<code>@setup</code>/<code>@Before</code> and <code>@teardown</code>/<code>@After</code>), and test cases (<code>@test</code>/<code>@Test</code>). Suite setup and teardown sections can also be defined with <code>@suitesetup</code>/<code>@BeforeClass</code> and <code>@suiteteardown</code>/<code>@AfterClass</code> annotations: these operations will be run before and after all tests, respectively.</p>"},{"location":"doc/eunit/#data-bindings","title":"Data bindings","text":"<p>Data bindings repeat all test cases with different values in some variables. To define a data binding, users must define an operation which returns a sequence of elements and is marked with @data variable. All test cases will be repeated once for each element of the returned sequence, setting the specified variable to the corresponding element. Listing 15.2 shows two nested data bindings and a test case which will be run four times: with x=1 and y=5, x=1 and y=6, x=2 and y=5 and finally x=2 and y=6. The example shows how x and y could be used by the setup section to generate an input model for the test. This can be useful if the intent of the test is ensuring that a certain property holds in a class of models, rather than a single model.</p> <pre><code>@data x\noperation firstLevel()  { return 1.to(2); }\n\n@data y\noperation secondLevel() { return 5.to(6); }\n\n@setup\noperation generateModel() { /* generate model using x and y */ }\n\n@test\noperation mytest() { /* test with the generated model */ }</code></pre> <p>Alternatively, if both x and y were to use the same sets of values, we could add two @data annotations to the same operation. For instance, the listing below shows how we could test with 4 cases: x=1 and y=1, x=1 and y=2, x=2 and y=1 and x=2 and y=2.</p> <pre><code>@data x\n@data y\noperation levels()  { return 1.to(2); }\n\n@setup\noperation generateModel() { /* generate model using x and y */ }\n\n@test\noperation mytest() { /* test with the generated model */ }</code></pre>"},{"location":"doc/eunit/#model-bindings","title":"Model bindings","text":"<p>Model bindings repeat a test case with different subsets of models. They can be defined by annotating a test case with <code>$with map</code> or <code>$onlyWith map</code> one or more times, where map is an EOL expression that produces a <code>MAP</code>. For each key-value pair <code>key = value</code>, EUnit will rename the model named <code>value</code> to <code>key</code>. The difference between <code>$with</code> and <code>$onlyWith</code> is how they handle the models not mentioned in the <code>MAP</code>: <code>$with</code> will preserve them as is, and <code>$onlyWith</code> will make them unavailable during the test. <code>$onlyWith</code> is useful for tightly restricting the set of available models in a test and for avoiding ambiguous type references when handling multiple models using the same metamodel.</p> <p>The listing below shows two tests which will be each run twice. The first test uses <code>$with</code>, which preserves models not mentioned in the MAP: the first time, model \"A\" will be the default model and model \"B\" will be the \"Other\" model, and the second time, model \"B\" will be the default model and model \"A\" will be the \"Other\" model. The second test uses two <code>$onlyWith</code> annotations: on the first run, \"A\" will be available as \"Model\" and \"B\" will not unavailable, and on the second run, only \"B\" will be available as \"Model\" and \"A\" will be unavailable.</p> <pre><code>$with Map {\"\" = \"A\", \"Other\" = \"B\"}\n$with Map {\"\" = \"B\", \"Other\" = \"A\"}\n@test\noperation mytest() {\n  /* use the default and Other models, while\n     keeping the rest as is */\n}\n\n$onlyWith Map { \"Model\" = \"A\" }\n$onlyWith Map { \"Model\" = \"B\" }\n@test\noperation mytest2() {\n  // first time: A as 'Model', B is unavailable\n  // second time: B as 'Model', A is unavailable\n}</code></pre>"},{"location":"doc/eunit/#additional-variables-and-built-in-operations","title":"Additional variables and built-in operations","text":"<p>EUnit provides several variables and operations which are useful for testing. These are listed in the table below.</p> Signature Description runTarget(name : String) Runs the specified target of the Ant buildfile which invoked EUnit. exportVariable(name : String) Exports the specified variable, to be used by another executable module. useVariable(name : String) Imports the specified variable, which should have been previously exported by another executable module. loadHutn(name : String, hutn : String) Loads an EMF model with the specified name, by parsing the second argument as an HUTN\u00a0fragment. antProject : org.apache.tools.ant.Project Global variable which refers to the Ant project being executed. This can be used to create and run Ant tasks from inside the EOL code."},{"location":"doc/eunit/#assertions","title":"Assertions","text":"<p>EUnit implements some common assertions for equality and inequality, with special versions for comparing floating-point numbers. EUnit also supports a limited form of exception testing with , which checks that the expression inside it throws an exception. Custom assertions can be defined by the user with the operation, which fails a test with a custom message. The available assertions are shown in the table below.</p> Signature Description assertEqualDirectories(expectedPath : String, obtainedPath : String) Fails the test if the contents of the directory in differ from those of the directory in . Directory comparisons are performed on recursive snapshots of both directories. assertEqualFiles(expectedPath : String, obtainedPath : String) Fails the test if the contents of the file in differ from those of the file in . File comparisons are performed on snapshots of both files. assertEqualFilesIgnoringLineEndings(expectedPath : String, obtainedPath : String) As above, but different line endings will not cause the test to fail. assertEqualModels([msg : String,] expectedModel : String, obtainedModel : String[, options : Map]) Fails the test with the optional message if the model named is not equal to the model named . Model comparisons are performed on snapshots of the resource sets of both models. During EMF comparisons, XMI identifiers are ignored. Additional comparator-specific options can be specified through . assertEquals([msg : String,] expected : Any, obtained : Any) Fails the test with the optional message if the values of and are not equal. assertEquals([msg : String,] expected : Real, obtained : Real,ulps : Integer) Fails the test with the optional message if the values of and differ in more than units of least precision. See this site for details. assertError(expr : Any) Fails the test if no exception is thrown during the evaluation of . assertFalse([msg : String,] cond : Boolean) Fails the test with the optional message if is . It is a negated version of assertTrue. assertLineWithMatch([msg : String,] path : String, regexp : String) Fails the test with the optional message if the file at does not have a line containing a substring matching the regular expression 2. assertMatchingLine([msg : String,] path : String, regexp : String) Fails the test with the optional message if the file at does not have a line that matches the regular expression 3 from start to finish. assertNotEqualDirectories(expectedPath : String, obtainedPath : String) Negated version of assertEqualDirectories. assertNotEqualFiles(expectedPath : String, obtainedPath : String) Negated version of assertEqualFiles. assertNotEqualFilesIgnoringLineEndings(expectedPath : String, obtainedPath : String) Negated version of assertEqualFilesIgnoringLineEndings. assertNotEqualModels([msg : String,] expectedModel : String, obtainedModel : String) Negated version of assertNotEqualModels. assertNotEquals([msg : String,] expected : Any, obtained : Any) Negated version of assertEquals([msg : String,] expected : Any, obtained : Any). assertNotEquals([msg : String,] expected : Real, obtained : Real, ulps : Integer) Negated version of assertEquals([msg : String,] expected : Real, obtained : Real, ulps : Integer). assertTrue([msg : String,] cond : Boolean) Fails the test with the optional message if is . fail(msg : String) Fails a test with the message . <p>The table below lists the available option keys which can be used with the model equality assertions, by comparator.</p> Comparator and Key Usage EMF, \"whitespace\" When set to \"ignore\", differences in EString attribute values due to whitespace will be ignored. Disabled by default. EMF, \"ignoreAttributeValueChanges\" Can contain a collection of strings of the form \"package.class.attribute\". Differences in the values for these attributes will be ignored. However, if the attribute is set on one side and not on the other, the difference will be reported as normal. Empty by default. EMF, \"unorderedMoves\" When set to \"ignore\", differences in the order of the elements within an unordered EReference. Enabled by default. <p>More importantly, EUnit implements specific assertions for comparing models, files and trees of files. Model comparison is not implemented by the assertions themselves: it is an optional service implemented by some EMC drivers. Currently, EMF models will automatically use EMF Compare as their comparison engine. The rest of the EMC drivers do not support comparison yet. The main advantage of having an abstraction layer implement model comparison as a service is that the test case definition is decoupled from the concrete model comparison engine used.</p> <p>Model, file and directory comparisons take a snapshot of their operands before comparing them, so EUnit can show the differences right at the moment when the comparison was performed. This is especially important when some of the models are generated on the fly by the EUnit test suite, or when a test case for code generation may overwrite the results of the previous one.</p> <p>The following figure shows a screenshot of the EUnit graphical user interface. On the left, an Eclipse view shows the results of several EUnit test suites. We can see that the <code>load- models-with-hutn</code> suite failed. The Compare button to the right of \"Failure Trace\" can be pressed to show the differences between the expected and obtained models, as shown on the right side. EUnit implements a pluggable architecture where difference viewers are automatically selected based on the types of the operands. There are difference viewers for EMF models, file trees and a fallback viewer which converts both operands to strings.</p> <p></p>"},{"location":"doc/eunit/#examples","title":"Examples","text":""},{"location":"doc/eunit/#models-and-tasks-in-the-buildfile","title":"Models and Tasks in the Buildfile","text":"<p>After describing the basic syntax, we will show how to use EUnit to test an ETL transformation.</p> <p>The Ant buildfile is shown in the listing below. It has two targets: <code>run-tests</code> (lines 2-19) invokes the EUnit suite, and <code>tree2graph</code> (lines 23-28) is a helper target which transforms model <code>Tree</code> into model <code>Graph</code> using ETL. The <code>&lt;modelTasks&gt;</code> nested element is used to load the input, expected output and output EMF models. <code>Graph</code> is loaded with <code>read</code> set to <code>false</code>: the model will be initially empty, and will be populated by the ETL transformation.</p> <pre><code>&lt;project&gt;\n&lt;target name=\"run-tests\"&gt;\n&lt;epsilon.eunit src=\"test-external.eunit\"&gt;\n&lt;modelTasks&gt;\n&lt;epsilon.emf.loadModel name=\"Tree\"\nmodelfile=\"tree.model\"\nmetamodelfile=\"tree.ecore\"\nread=\"true\" store=\"false\"/&gt;\n&lt;epsilon.emf.loadModel name=\"GraphExpected\"\nmodelfile=\"graph.model\"\nmetamodelfile=\"graph.ecore\"\nread=\"true\" store=\"false\"/&gt;\n&lt;epsilon.emf.loadModel name=\"Graph\"\nmodelfile=\"transformed.model\"\nmetamodelfile=\"graph.ecore\"\nread=\"false\" store=\"false\"/&gt;\n&lt;/modelTasks&gt;\n&lt;/epsilon.eunit&gt;\n&lt;/target&gt;\n&lt;target name=\"tree2graph\"&gt;\n&lt;epsilon.etl src=\"${basedir}/resources/Tree2Graph.etl\"&gt;\n&lt;model ref=\"Tree\"/&gt;\n&lt;model ref=\"Graph\"/&gt;\n&lt;/epsilon.etl&gt;\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre> <p>The EOL script is shown in the listing below: it invokes the helper task (line 3) and checks that the obtained model is equal to the expected model (line 4). Internally, EMC will perform the comparison using EMF Compare.</p> <pre><code>@test\noperation transformationWorksAsExpected() {\n  runTarget(\"tree2graph\");\n  assertEqualModels(\"GraphExpected\", \"Graph\");\n}</code></pre>"},{"location":"doc/eunit/#models-and-tasks-in-the-eol-script","title":"Models and Tasks in the EOL Script","text":"<p>In the previous section, the EOL file is kept very concise because the model setup and model management tasks under test were specified in the Ant buildfile. In this section, we will inline the models and the tasks into the EOL script instead.</p> <p>The Ant buildfile is shown in the listing below. It is now very simple: all it needs to do is run the EOL script. However, since we will parse HUTN in the EOL script, we must make sure the s of the metamodels are registered.</p> <pre><code>&lt;project&gt;\n&lt;target name=\"run-tests\"&gt;\n&lt;epsilon.emf.register file=\"tree.ecore\"/&gt;\n&lt;epsilon.emf.register file=\"graph.ecore\"/&gt;\n&lt;epsilon.eunit src=\"test-inlined.eunit\"/&gt;\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre> <p>The EOL script used is shown below. Instead of loading models through the Ant tasks, the <code>loadHutn</code> operation has been used to load the models. The test itself is almost the same, but instead of running a helper target, it invokes an operation which creates and runs the ETL Ant task through the <code>antProject</code> variable provided by EUnit, taking advantage of the support in EOL for invoking Java code through reflection.</p> <pre><code>@model\noperation loadModels() {\n  loadHutn(\"Tree\", '@Spec {Metamodel {nsUri: \"Tree\" }}\nModel {\n  Tree \"t1\" { label : \"t1\" }\n  Tree \"t2\" {\n    label : \"t2\"\n    parent : Tree \"t1\" \n  }\n}\n');\n\n  loadHutn(\"GraphExpected\", '@Spec {Metamodel {nsUri: \"Graph\"}}\nGraph { nodes :\n  Node \"t1\" {\n    name : \"t1\"\n    outgoing : Edge { source : Node \"t1\" target : Node \"t2\" }\n  },\n  Node \"t2\" {\n    name : \"t2\"\n  }\n}\n');\n\n  loadHutn(\"Graph\", '@Spec {Metamodel {nsUri: \"Graph\"}}');\n}\n\n@test\noperation transformationWorksAsExpected() {\n  runETL();\n  assertEqualModels(\"GraphExpected\", \"Graph\");\n}\n\noperation runETL() {\n  var etlTask := antProject.createTask(\"epsilon.etl\");\n  etlTask.setSrc(new Native('java.io.File')(\n    antProject.getBaseDir(), 'resources/etl/Tree2Graph.etl'));\n  etlTask.createModel().setRef(\"Tree\");\n  etlTask.createModel().setRef(\"Graph\");\n  etlTask.execute();\n}</code></pre>"},{"location":"doc/eunit/#extending-eunit","title":"Extending EUnit","text":"<p>EUnit is based on the Epsilon platform, but it is designed to accommodate other technologies. In this section we will explain several strategies to add support for these technologies to EUnit.</p> <p>EUnit uses the Epsilon Model Connectivity abstraction layer to handle different modelling technologies. Adding support for a different modelling technology only requires implementing another driver for EMC. Depending on the modelling technology, the driver can provide optional services such as model comparison, caching or reflection.</p> <p>EUnit uses Ant as a workflow language: all model management tasks must be exposed through Ant tasks. It is highly encouraged, however, that the Ant task is aware of the EMC model repository linked to the Ant project. Otherwise, users will have to shuffle the models out from and back into the repository between model management tasks. As an example, a helper target for an ATL transformation with the existing Ant tasks needs to:</p> <ol> <li>Save the input model in the EMC model repository to a file, by invoking the <code>&lt;epsilon.storeModel&gt;</code> task.</li> <li>Load the metamodels and the input model with <code>&lt;atl.loadModel&gt;</code>.</li> <li>Run the ATL transformation with <code>&lt;atl.launch&gt;</code>.</li> <li>Save the result of the ATL transformation with <code>&lt;atl.saveModel&gt;</code>.</li> <li>Load it into the EMC model repository with <code>&lt;epsilon.emf.loadModel&gt;</code>.</li> </ol> <p>The listing below shows the Ant buildfile which would be required for running these steps, showing that while EUnit can use the existing ATL tasks as-is, the required helper task is quite longer than the one shown above. Ideally, Ant tasks should be adapted or wrapped to use models directly from the EMC model repository.</p> <pre><code>&lt;project&gt;\n&lt;!-- ... omitted ... --&gt;\n&lt;target name=\"atl\"&gt;\n&lt;!-- Create temporary files for input and output models --&gt;\n&lt;tempfile property=\"atl.temp.srcfile\" /&gt;\n&lt;tempfile property=\"atl.temp.dstfile\" /&gt;\n\n&lt;!-- Save input model to a file --&gt;\n&lt;epsilon.storeModel model=\"Tree\"\ntarget=\"${atl.temp.srcfile}\" /&gt;\n\n&lt;!-- Load the metamodels and the source model --&gt;\n&lt;atl.loadModel name=\"TreeMM\" metamodel=\"MOF\"\npath=\"metamodels/tree.ecore\" /&gt;\n&lt;atl.loadModel name=\"GraphMM\" metamodel=\"MOF\"\npath=\"metamodels/graph.ecore\" /&gt;\n&lt;atl.loadModel name=\"Tree\" metamodel=\"TreeMM\"\npath=\"${atl.temp.srcfile}\" /&gt;\n\n&lt;!-- Run ATL and save the model --&gt;\n&lt;atl.launch path=\"transformation/tree2graph.atl\"&gt;\n&lt;inmodel name=\"IN\"   model=\"Tree\" /&gt;\n&lt;outmodel name=\"OUT\" model=\"Graph\" metamodel=\"GraphMM\" /&gt;\n&lt;/atl.launch&gt;\n&lt;atl.saveModel model=\"Graph\" path=\"${atl.temp.dstfile}\" /&gt;\n\n&lt;!-- Load it back into the EUnit suite --&gt;\n&lt;epsilon.emf.loadModel name=\"Graph\"\nmodelfile=\"${atl.temp.dstfile}\"\nmetamodeluri=\"Graph\"\nread=\"true\" store=\"false\" /&gt;\n\n&lt;!-- Delete temporary files --&gt;\n&lt;delete file=\"${atl.temp.srcfile}\" /&gt;\n&lt;delete file=\"${atl.temp.dstfile}\" /&gt;\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre> <p>Another advantage in making model management tasks EMC-aware is that they can easily \u201cexport\u201d their results as models, making them easier to test. For instance, the EVL Ant task allows for exporting its results as a model by setting the attribute <code>exportAsModel</code> to <code>true</code>. This way, EOL can query the results as any regular model. This is simpler than transforming the validated model to a problem metamodel. The example in the listing below checks that a single warning was produced due to the expected rule (<code>LabelsStartWithT</code>) and the expected model element.</p> <pre><code>@test\noperation valid() {\n  var tree := new Tree!Tree;\n  tree.label := '1n';\n  runTarget('validate-tree');\n  var errors := EVL!EvlUnsatisfiedConstraint.allInstances;\n  assertEquals(1, errors.size);\n  var error := errors.first;\n  assertEquals(tree, error.instance);\n  assertEquals(false, error.constraint.isCritique);\n  assertEquals('LabelsStartWithT', error.constraint.name);\n}</code></pre> <ol> <li> <p>CPU time only measures the time elapsed in the thread used by EUnit, and is more stable with varying system load in single-threaded programs.\u00a0\u21a9</p> </li> <li> <p>See <code>JAVA.UTIL.REGEX.PATTERN</code> for details about the accepted syntax for regular expressions.\u00a0\u21a9</p> </li> <li> <p>See footnote <code>assertLineWithMatch</code> for details about the syntax of the regular expressions.\u00a0\u21a9</p> </li> </ol>"},{"location":"doc/evl/","title":"The Epsilon Validation Language (EVL)","text":"<p>EVL contributes model validation capabilities to Epsilon. More specifically, EVL can be used to specify and evaluate constraints and critiques on models of arbitrary metamodels and modelling technologies, and to produce human-readable error messages and executable quick fixes.</p> <p>Try EVL online</p> <p>You can run and fiddle with EVL constraints that validate a project scheduling model in the online Epsilon Playground.</p>"},{"location":"doc/evl/#abstract-syntax","title":"Abstract Syntax","text":"<p>In EVL, validation specifications are organized in modules (EvlModule). As illustrated in the figure below, EvlModule (indirectly) extends EolModule which means that it can contain user-defined operations and import other EOL library modules and EVL modules. Apart from operations, an EVL module also contains a set of constraints grouped by the context they apply to, and, by extending ErlModule, a number of pre and post blocks.</p> <p>Info</p> <p>As with most languages in Epsilon, EVL uses EOL as its expression language. This page only documents the additional syntax and semantics that EVL provides on top of EOL.</p> classDiagram class Constraint {     -name: String     -guard: ExecutableBlock&lt;Boolean&gt;     -check: ExecutableBlock&lt;Boolean&gt;     -message: ExecutableBlock&lt;String&gt;     -isCritique: boolean } class ConstraintContext {     -type: EolModelElementType     -guard: ExecutableBlock&lt;Boolean&gt; } class NamedStatementBlockRule {     -name: String     -body: StatementBlock } class Fix {     -guard: ExecutableBlock&lt;Boolean&gt;     -title: ExecutableBlock&lt;String&gt;     -body: ExecutableBlock&lt;Void&gt; } EolModule &lt;|-- ErlModule EvlModule --|&gt; ErlModule Pre --|&gt; NamedStatementBlockRule Post --|&gt; NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * EvlModule -- ConstraintContext: contexts * ConstraintContext -- Constraint: constraints * Constraint -- Fix: fixes *"},{"location":"doc/evl/#context","title":"Context","text":"<p>A context specifies the kind of instances on which the contained constraints will be evaluated. Each context can optionally define a guard which limits its applicability to a narrower subset of instances of its specified type. Thus, if the guard fails for a specific instance of the type, none of its contained constraints are evaluated.</p>"},{"location":"doc/evl/#constraint","title":"Constraint","text":"<p>As with OCL, each EVL constraint defines a name and a body (check). However, it can optionally also define a guard which further limits its applicability to a subset of the instances of the type defined by the embracing context. Each constraint can optionally define a message as an ExecutableBlock that should return a String providing a description of the reason(s) for which the constraint has failed on a particular element. A constraint can also optionally define a number of fixes. Finally, as displayed in the figure above, constraint is an abstract class that is used as a super-class for the specific types Constraint and Critique.</p>"},{"location":"doc/evl/#guard","title":"Guard","text":"<p>Guards are used to limit the applicability of constraints. This can be achieved at two levels. At the Context level it limits the applicability of all constraints of the context and at the Constraint level it limits the applicability of a specific constraint.</p>"},{"location":"doc/evl/#fix","title":"Fix","text":"<p>A fix defines a title using an ExecutableBlock instead of a static String to allow users to specify context-aware titles (e.g. Rename class customer to Customer instead of a generic Convert first letter to upper-case). Moreover, the do (body) part is a statement block where the fixing functionality can be defined using EOL. The developer is responsible for ensuring that the actions contained in the fix actually repair the identified inconsistency.</p>"},{"location":"doc/evl/#critique","title":"Critique","text":"<p>Critiques are constraints that are used to capture non-critical issues that do not invalidate the model, but should nevertheless be addressed by the user to enhance the quality of the model.</p>"},{"location":"doc/evl/#pre-and-post","title":"Pre and Post","text":"<p>An EVL module can define a number of named pre and a post blocks that contain EOL statements which are executed before and after evaluating the constraints respectively. These should not be confused with the pre-/post-condition annotations available for EOL user-defined operations.</p>"},{"location":"doc/evl/#concrete-syntax","title":"Concrete Syntax","text":"<p>The following listing demonstrates the concrete sytnax of the context, constraint and fix abstract syntax constructs discussed above.</p> <pre><code>(@lazy)?\ncontext &lt;name&gt; {\n    (guard (:expression)|({statementBlock}))?\n    (constraint)* \n}\n\n((@lazy)?\n(constraint|critique) &lt;name&gt; {\n    (guard (:expression)|({statementBlock}))?\n    (check (:expression)|({statementBlock}))?\n    (message (:expression)|({statementBlock}))? \n    (fix)*\n}\n\nfix {\n    (guard (:expression)|({statementBlock}))?\n    (title (:expression)|({statementBlock}))\n    do {\n        statementBlock\n    } \n}\n</code></pre> <p>Pre and post blocks have a simple syntax that, as presented in the listing below, consists of the identifier (pre or post), an optional name and the set of statements to be executed enclosed in curly braces.</p> <pre><code>(pre|post) &lt;name&gt; {\n    statement+\n}\n</code></pre>"},{"location":"doc/evl/#execution-semantics","title":"Execution Semantics","text":"<p>Having discussed the abstract and concrete syntaxes of EVL, this section provides an informal discussion of the execution semantics of the language. The execution of an EVL module is separated into four phases:</p>"},{"location":"doc/evl/#phase-1","title":"Phase 1","text":"<p>Before any constraint is evaluated, the pre blocks of the module are executed in the order in which they have been specified.</p>"},{"location":"doc/evl/#phase-2","title":"Phase 2","text":"<p>For each non-lazy context with at least one non-lazy constraint, the instances of the meta-class it defines are collected. For each instance, the guard of the context is evaluated. If the guard is satisfied, then for each non-lazy constraint contained in the context the constraint's guard is also evaluated. If the guard of the constraint is satisfied, the body of the constraint is evaluated. In case the body evaluates to false, the message part of the rule is evaluated and the produced message is added along with the instance, the constraint and the available fixes to the ValidationTrace.</p> <p>The execution order of an EVL module follows a top-down depth-first scheme that respects the order in which the contexts and constraints appear in the module. However, the execution order can change in case one of the satisfies, satisfiesOne, satisfiesAll built-in operations, discussed in detail in the sequel, are called.</p>"},{"location":"doc/evl/#phase-3","title":"Phase 3","text":"<p>In this phase, the validation trace is examined for unsatisfied constraints and the user is presented with the message each one has produced. The user can then select one or more of the available fixes to be executed. Execution of fixes is performed in a transactional manner using the respective facilities provided by the model connectivity framework. This is to prevent runtime errors raised during the execution of a fix from compromising the validated model by leaving it in an inconsistent state.</p>"},{"location":"doc/evl/#phase-4","title":"Phase 4","text":"<p>When the user has performed all the necessary fixes or chooses to end Phase 3 explicitly, the post section of the module is executed. There, the user can perform tasks such as serializing the validation trace or producing a summary of the validation process results.</p>"},{"location":"doc/evl/#capturing-dependencies-between-constraints","title":"Capturing Dependencies between Constraints","text":"<p>It is often the case that constraints conceptually depend on each other. To allow users capture such dependencies, EVL provides the satisfies(constraint : String) : Boolean, satisfiesAll(constraints : Sequence(String)) : Boolean and satisfiesOne(constraints : Sequence(String)) : Boolean built-in operations. Using these operations, an constraint can specify in its guard other constraints which need to be satisfied for it to be meaningful to evaluate.</p> <p>When one of these operations is invoked, if the required constraints (either lazy or non-lazy) have been evaluated for the instances on which the operation is invoked, the engine will return their cached results; otherwise it will evaluate them and return their results.</p>"},{"location":"doc/evl/#example","title":"Example","text":"<p>The following is an EVL program demonstrating some of the language features, which validates models confirming to the Movies metamodel shown below. Execution begins from the pre block, which simply computes the average number of actors per Movie and stores it into a global variable, which can be accessed at any point. The ValidActors constraint checks that for every instance of Movie which has more than the average number of actors, all of the actors have valid names. This is achieved through a dependency on the HashValidName invariant declared in the context of Person type. This constraint is marked as lazy, which means it is only executed when invoked by satisfies, so avoiding unnecessary or duplicate invocations. The HasValidName constraint makes use of a helper operation (isPlain()) on Strings. Once all Movie instances have been checked, the execution engine then proceeds to validate all Person instances, which consists of only one non-lazy constraint ValidMovieYears. This checks that all of the movies the actor has played in were released at least 3 years after the actor was born. Finally, the post block is executed, which in this case simply prints some basic information about the model.</p> classDiagram class Movie {     -title: String     -rating: Double     -year: Int } class Person {     -name: String     -birthYear: Int }  Movie -- Person: movies * / persons * <pre><code>pre {\n  var numMovies = Movie.all.size();\n  var numActors = Person.all.size();\n  var apm = numActors / numMovies;\n}\n\ncontext Movie {\n\n  constraint ValidActors {\n    guard : self.persons.size() &gt; apm    \n    check : self.persons.forAll(p | p.satisfies(\"HasValidName\"))\n  }\n}\n\ncontext Person {\n\n  @lazy\n  constraint HasValidName {\n    check : self.name.isPlain()\n  } \n\n  constraint ValidMovieYears {\n    check : self.movies.forAll(m |  m.year + 1 &gt; self.birthYear)\n  }\n}\n\noperation String isPlain() : Boolean {\n  return self.matches(\"[A-Za-z\\\\s]+\");\n}\n\npost {\n  (\"Actors per Movie=\"+apm).println();\n  (\"# Movies=\"+numMovies).println();\n  (\"# Actors=\"+numActors).println();\n}</code></pre>"},{"location":"doc/evl/#additional-resources","title":"Additional Resources","text":"<p>Additional resources about EVL are available here.</p>"},{"location":"doc/ewl/","title":"The Epsilon Wizard Language (EWL)","text":"<p>There are two types of model-to-model transformations: mapping and update transformations. Mapping transformations typically transform a source model into a set of target models expressed in (potentially) different modelling languages by creating zero or more model elements in the target models for each model element of the source model. By contrast, update transformations perform in-place modifications in the source model itself. They can be further classified into two subcategories: transformations in the small and in the large. Update transformations in the large apply to sets of model elements calculated using well-defined rules in a batch manner. An example of this category of transformations is a transformation that automatically adds accessor and mutator operations for all attributes in a UML model. On the other hand, update transformations in the small are applied in a user-driven manner on model elements that have been explicitly selected by the user. An example of this kind of transformations is a transformation that renames a user-specified UML class and all its incoming associations consistently.</p> <p>In Epsilon, mapping transformations can be specified using ETL, and update transformations in the large can be implemented either using the model modification features of EOL or using an ETL transformation in which the source and target models are the same model. By contrast, update transformations in the small cannot be effectively addressed by any of the languages presented so far.</p> <p>The following section discusses the importance of update transformations in the small and motivates the definition of a task-specific language (Epsilon Wizard Language (EWL)) that provides tailored and effective support for defining and executing update transformations on models of diverse metamodels.</p>"},{"location":"doc/ewl/#motivation","title":"Motivation","text":"<p>Constructing and refactoring models is undoubtedly a mentally intensive process. However, during modelling, recurring patterns of model update activities typically appear. As an example, when renaming a class in a UML class diagram, the user also needs to manually update the names of association ends that link to the renamed class. Thus, when renaming a class from Chapter to Section, all associations ends that point to the class and are named chapter or chapters should be also renamed to section and sections respectively. As another example, when a modeller needs to refactor a UML class into a singleton [@Larman], they need to go through a number of well-defined, but trivial, steps such as attaching a stereotype (<code>&lt;&lt;singleton&gt;&gt;</code>), defining a static instance attribute and adding a static getInstance() method that returns the unique instance of the singleton.</p> <p>It is generally accepted that performing repetitive tasks manually is both counter-productive and error-prone. On the other hand, failing to complete such tasks correctly and precisely compromises the consistency, and thus the quality, of the models. In Model Driven Engineering, this is particularly important since models are increasingly used to automatically produce (parts of) working systems.</p>"},{"location":"doc/ewl/#automating-the-construction-and-refactoring-process","title":"Automating the Construction and Refactoring Process","text":"<p>Contemporary modelling tools provide built-in transformations (wizards) for automating common repetitive tasks. However, according to the architecture of the designed system and the specific problem domain, additional repetitive tasks typically appear, which cannot be addressed by the pre-conceived built-in wizards of a modelling tool. To address the automation problem in its general case, users must be able to easily define update transformations (wizards) that are tailored to their specific needs.</p> <p>To an extent, this can be achieved via the extensible architecture that state-of-the-art modelling tools often provide which enables users to add functionality to the tool via scripts or application code using the implementation language of the tool. Nevertheless, the majority of modelling tools provide an API through which they expose an edited model, which requires significant effort to learn and use. Also, since each API is proprietary, such scripts and extensions are not portable to other tools. Finally, API scripting languages and third-generation languages such as Java and C++ are not particularly suitable for model navigation and modification.</p> <p>Furthermore, existing languages for mapping transformations, such as QVT, ATL and ETL, cannot be used as-is for this purpose, because these languages have been designed to operate in a batch manner without human involvement in the process. By contrast, as discussed above, the task of constructing and refactoring models is inherently user-driven.</p>"},{"location":"doc/ewl/#update-transformations-in-the-small","title":"Update Transformations in the Small","text":"<p>Update transformations are actions that automatically create, update or delete model elements based on a selection of existing elements in the model and information obtained otherwise (e.g. through user input), in a user-driven fashion. In this section, such actions are referred to as wizards instead of rules to reduce confusion between them and rules of mapping transformation languages. In the following sections, the desirable characteristics of wizards are elaborated informally.</p>"},{"location":"doc/ewl/#structure-of-wizards","title":"Structure of Wizards","text":"<p>In its simplest form, a wizard only needs to define the actions it will perform when it is applied to a selection of model elements. The structure of such a wizard that transforms a UML class into a singleton is shown using pseudo-code in the listing below.</p> <pre><code>do :\n    attach the singleton stereotype\n    create the instance attribute\n    create the getInstance method\n</code></pre> <p>Since not all wizards apply to all types of elements in the model, each wizard needs to specify the types of elements to which it applies. For example, the wizard of the listing above, which automatically transforms a class into a singleton, applies only when the selected model element is a class. The simplest approach to ensuring that the wizard will only be applied on classes is to enclose its body in an if condition as shown in the listing below.</p> <pre><code>do : \n    if (selected element is a class) {\n        attach the singleton stereotype\n        create the instance attribute\n        create the getInstance method\n    }\n</code></pre> <p>A more modular approach is to separate this condition from the body of the wizard. This is shown in the listing below where the condition of the wizard is specified as a separate guard stating that the wizard applies only to elements of type Class. The latter is preferable since it enables filtering out wizards that are not applicable to the current selection of elements by evaluating only their guard parts and rejecting those that return false. Thus, at any time, the user can be provided with only the wizards that are applicable to the current selection of elements. Filtering out irrelevant wizards reduces confusion and enhances usability, particularly as the list of specified wizards grows.</p> <pre><code>guard : selected element is a class\ndo : \n    attach the singleton stereotype\n    create the instance attribute\n    create the getInstance method\n</code></pre> <p>To enhance usability, a wizard also needs to define a short human-readable description of its functionality. To achieve this, another field named title has been added. There are two options for defining the title of a wizard: the first is to use a static string and the second to use a dynamic expression. The latter is preferable since it enables definition of context-aware titles.</p> <pre><code>guard : selected element is a class\ntitle : Convert class &lt;class-name&gt; into a singleton\ndo : \n    attach the singleton stereotype\n    create the instance attribute\n    create the getInstance method\n</code></pre>"},{"location":"doc/ewl/#capabilities-of-wizards","title":"Capabilities of Wizards","text":"<p>The guard and title parts of a wizard need to be expressed using a language that provides model querying and navigation facilities. Moreover, the do part also requires model modification capabilities to implement the transformation. To achieve complex transformations, it is essential that the user can provide additional information. For instance, to implement a wizard that addresses the class renaming scenario, the information provided by the selected class does not suffice; the user must also provide the new name of the class. Therefore, EWL must also provide mechanisms for capturing user input.</p>"},{"location":"doc/ewl/#abstract-syntax","title":"Abstract Syntax","text":"<p>Since EWL is built atop Epsilon, its abstract and concrete syntax need only to define the concepts that are relevant to the task it addresses; they can reuse lower-level constructs from EOL. A graphical overview of the abstract syntax of the language is provided in the figure below.</p> <p>The basic concept of the EWL abstract syntax is a Wizard. A wizard defines a name, a guard part, a title part and a $do$ part. Wizards are organized in Modules. The name of a wizard acts as an identifier and must be unique in the context of a module. The guard and title parts of a wizard are of type ExpressionOrStatementBlock, inherited from EOL. An ExpressionOrStatementBlock is either a single EOL expression or a block of EOL statements that include one or more return statements. This construct allows users to express simple declarative calculations as single expressions and complex calculations as blocks of imperative statements. Finally, the do part of the wizard is a block of EOL statements that specify the effects of the wizard when applied to a compatible selection of model elements.</p> <p></p>"},{"location":"doc/ewl/#concrete-syntax","title":"Concrete Syntax","text":"<p>The following listing presents the concrete syntax of EWL wizards.</p> <pre><code>wizard &lt;name&gt; {\n    (guard (:expression)|({statementBlock}))?\n    (title (:expression)|({statementBlock}))? \n    do {\n        statementBlock\n    } \n}\n</code></pre>"},{"location":"doc/ewl/#execution-semantics","title":"Execution Semantics","text":"<p>The process of executing EWL wizards is inherently user-driven and as such it depends on the environment in which they are used. In general, each time the selection of model elements changes (i.e. the user selects or deselects a model element in the modelling tool), the guards of all wizards are evaluated. If the guard of a wizard is satisfied, the title part is also evaluated and the wizard is added to a list of applicable wizards. Then, the user can select a wizard and execute its do part to perform the intended transformation.</p> <p>In EWL, variables defined and initialized in the guard part of the wizard can be accessed both by the title and the do parts. In this way, results of calculations performed in the guard part can be re-used, instead of re-calculated in the subsequent parts. The practicality of this approach is discussed in more detail in the examples that follow. Also, the execution of the do part of each wizard is performed in a transactional mode by exploiting the transaction capabilities of the underlying model connectivity framework, so that possible logical errors in the do part of a wizard do not leave the edited model in an inconsistent state.</p>"},{"location":"doc/ewl/#examples","title":"Examples","text":"<p>This section presents three concrete examples of EWL wizards for refactoring UML 1.4 models. The aim of this section is not to provide complete implementations that address all the sub-cases of each scenario but to provide enhanced understanding of the concrete syntax, the features and the capabilities of EWL to the reader. Moreover, it should be stressed again that although the examples in this section are based on UML models, by building on Epsilon, EWL can be used to capture wizards for diverse modelling languages and technologies.</p>"},{"location":"doc/ewl/#converting-a-class-into-a-singleton","title":"Converting a Class into a Singleton","text":"<p>The singleton pattern is applied when there is a class for which only one instance can exist at a time. In terms of UML, a singleton is a class stereotyped with the <code>&lt;&lt;singleton&gt;&gt;</code> stereotype, and it defines a static attribute named <code>instance</code> which holds the value of the unique instance. It also defines a static <code>getInstance()</code> operation that returns that unique instance. Wizard <code>ClassToSingleton</code>, presented below, simplifies the process of converting a class into a singleton by adding the proper stereotype, attribute and operation to it automatically.</p> <pre><code>wizard ClassToSingleton {\n\n    // The wizard applies when a class is selected\n    guard : self.isTypeOf(Class)\n\n    title : \"Convert \" + self.name + \" to a singleton\"\n\n    do {\n        // Create the getInstance() operation \n        var gi : new Operation; \n        gi.owner = self; \n        gi.name = \"getInstance\"; \n        gi.visibility = VisibilityKind#vk_public; \n        gi.ownerScope = ScopeKind#sk_classifier; \n\n        // Create the return parameter of the operation \n        var ret : new Parameter; \n        ret.type = self; \n        ret.kind = ParameterDirectionKind#pdk_return; \n        gi.parameter = Sequence{ret}; \n\n        // Create the instance field \n        var ins : new Attribute; \n        ins.name = \"instance\"; \n        ins.type = self; \n        ins.visibility = VisibilityKind#vk_private; \n        ins.ownerScope = ScopeKind#sk_classifier; \n        ins.owner = self; \n\n        // Attach the &lt;&lt;singleton&gt;&gt; stereotype \n        self.attachStereotype(\"singleton\");\n    }\n}\n\n// Attaches a stereotype with the specified name\n// to the Model Element on which it is invoked\noperation ModelElement attachStereotype(name : String) {\n        var stereotype : Stereotype;\n\n        // Try to find an existing stereotype with this name\n        stereotype = Stereotype.allInstances.selectOne(s|s.name = name);\n\n        // If there is no existing stereotype\n        // with that name, create one\n        if (not stereotype.isDefined()){\n            stereotype = Stereotype.createInstance();\n            stereotype.name = name;\n            stereotype.namespace = self.namespace;\n        }\n\n        // Attach the stereotype to the model element\n        self.stereotype.add(stereotype);\n}\n</code></pre> <p>The <code>guard</code> part of the wizard specifies that it is only applicable when the selection is a single UML class. The <code>title</code> part specifies a context-aware title that informs the user of the functionality of the wizard and the <code>do</code> part implements the functionality by adding the <code>getInstance</code> operation (lines 10-14), the <code>instance</code> attribute (lines 23-28) and the <code>&lt;&lt;singleton&gt;&gt;</code> stereotype (line 31). </p> <p>The stereotype is added via a call to the <code>attachStereotype()</code> operation. Attaching a stereotype is a very common action when refactoring UML models, particularly where UML profiles are involved, and therefore to avoid duplication, this reusable operation that checks for an existing stereotype, creates it if it does not already exists, and attaches it to the model element on which it is invoked has been specified.</p> <p>An extended version of this wizard could also check for existing association ends that link to the class and for which the upper-bound of their multiplicity is greater than one and either disallow the wizard from executing on such classes (in the <code>guard</code> part) or update the upper-bound of their multiplicities to one (in the <code>do</code> part). However, the aim of this section is not to implement complete wizards that address all sub-cases but to provide a better  understanding of the concrete syntax and the features of EWL. This principle also applies to the examples presented in the sequel.</p>"},{"location":"doc/ewl/#renaming-a-class","title":"Renaming a Class","text":"<p>The most widely used convention for naming attributes and association ends of a given class is to use a lower-case version of the name of the class as the name of the attribute or the association end. For instance, the two ends of a one-to-many association that links classes <code>Book</code> and <code>Chapter</code> are most likely to be named <code>book</code> and <code>chapters</code> respectively. When renaming a class (e.g. from <code>Chapter</code> to <code>Section</code>) the user must then manually traverse the model to find all attributes and association ends of this type and update their names (i.e. from <code>chapter</code> or <code>bookChapter</code> to <code>section</code> and <code>bookSection</code> respectively). This can be a daunting process especially in the context of large models. Wizard <code>RenameClass</code> presented in the listing below automates this process.</p> <pre><code>wizard RenameClass {\n\n    // The wizard applies when a Class is selected\n    guard : self.isKindOf(Class)\n\n    title : \"Rename class \" + self.name\n\n    do {\n        var newName : String;\n\n        // Prompt the user for the new name of the class\n        newName = UserInput.prompt(\"New name for class \" + self.name);\n        if (newName.isDefined()) {\n            var affectedElements : Sequence;\n\n            // Collect the AssociationEnds and Attributes\n            // that are affected by the rename\n            affectedElements.addAll(\n                AssociationEnd.allInstances.select(ae|ae.participant=self));\n            affectedElements.addAll(\n                Attribute.allInstances.select(a|a.type = self));\n\n            var oldNameToLower : String;\n            oldNameToLower = self.name.firstToLowerCase();\n            var newNameToLower : String;\n            newNameToLower = newName.firstToLowerCase();\n\n            // Update the names of the affected AssociationEnds\n            // and Attributes\n            for (ae in affectedElements) {\n                ae.replaceInName(oldNameToLower, newNameToLower);\n                ae.replaceInName(self.name, newName);\n            }\n            self.name = newName;\n        }\n    }\n\n}\n\n// Renames the ModelElement on which it is invoked\noperation ModelElement replaceInName\n    (oldString : String, newString : String) {\n\n    if (oldString.isSubstringOf(self.name)) {\n        // Calculate the new name\n        var newName : String;\n        newName = self.name.replace(oldString, newString);\n\n        // Prompt the user for confirmation of the rename\n        if (UserInput.confirm\n            (\"Rename \" + self.name + \" to \" + newName + \"?\")) {\n            // Perform the rename\n            self.name = newName;\n        }\n    }\n}\n</code></pre> <p>As with the <code>ClassToSingleton</code> wizard, the <code>guard</code> part of <code>RenameClass</code> specifies that the wizard is applicable only when the selection is a simple class and the title provides a context-aware description of the functionality of the wizard.</p> <p>The information provided by the selected class itself does not suffice in the case of renaming since the new name of the class is not specified anywhere in the existing model. In EWL, and in all languages that build on EOL, user input can be obtained using the built-in <code>UserInput</code> facility. Thus, in line 12 the user is prompted for the new name of the class using the <code>UserInput.prompt()</code> operation. Then, all the association ends and attributes that refer to the class are collected in the <code>affectedElements</code> sequence (lines 14-21). Using the <code>replaceInName</code> operation (lines 31 and 32), the name of each one is examined for a substring of the upper-case or the lower-case version of the old name of the class. In case the check returns true, the user is prompted to confirm (line 48) that the feature needs to be renamed. This further highlights the importance of user input for implementing update transformations with fine-grained user control.</p>"},{"location":"doc/ewl/#moving-model-elements-into-a-different-package","title":"Moving Model Elements into a Different Package","text":"<p>A common refactoring when modelling in UML is to move model elements, particularly Classes, between different packages. When moving a pair of classes from one package to another, the associations that connect them must also be moved to the target package. To automate this process, the listing below presents the <code>MoveToPackage</code> wizard.</p> <pre><code>wizard MoveToPackage {\n\n    // The wizard applies when a Collection of\n    // elements, including at least one Package\n    // is selected\n    guard { \n        var moveTo : Package;\n        if (self.isKindOf(Collection)) {\n            moveTo = self.select(e|e.isKindOf(Package)).last();\n        }\n        return moveTo.isDefined();\n    }\n\n    title : \"Move \" + (self.size()-1) + \" elements to \" + moveTo.name\n\n    do {\n        // Move the selected Model Elements to the\n        // target package\n        for (me in self.excluding(moveTo)) {\n            me.namespace = moveTo;\n        }\n\n        // Move the Associations connecting any\n        // selected Classes to the target package\n        for (a in Association.allInstances) {\n            if (a.connection.forAll(c|self.includes(c.participant))){\n                a.namespace = moveTo;\n            }\n        }\n    }\n\n}\n</code></pre> <p>The wizard applies when more than one element is selected and at least one of the elements is a Package. If more than one package is selected, the last one is considered as the target package to which the rest of the selected elements will be moved. This is specified in the guard part of the wizard.</p> <p>To reduce user confusion in identifying the package to which the elements will be moved, the name of the target package appears in the title of the wizard. This example shows the importance of the decision to express the title as a dynamically calculated expression (as opposed to a static string). It is worth noting that in the title part of the wizard (line 14), the moveTo variable declared in the guard (line 7) is referenced. Through experimenting with a number of wizards, it has been noticed that in complex wizards repeated calculations need to be performed in the guard, title and do parts of the wizard. To eliminate this duplication, the scope of variables defined in the guard part has been extended so that they are also accessible from the title and do part of the wizard.</p>"},{"location":"doc/flock/","title":"Epsilon Flock for Model Migration","text":"<p>The aim of Epsilon Flock is to contribute model migration capabilities to Epsilon. Model migration is the process of updating models in response to metamodel changes. This section discusses the motivation for implementing Flock, introduces its syntax and execution semantics, and demonstrates the use of Flock with an example. Flock can be used to update models to a new version of their metamodel, or even to move from one modelling technology to another (e.g., from XML to EMF).</p> <p>To illustrate the challenges of model migration, we use the example of metamodel evolution below. In the top figure, a <code>Component</code> comprises other <code>Component</code>s, <code>Connector</code>s and <code>Port</code>s. A <code>Connector</code> joins two <code>Port</code>s. <code>Connector</code>s are unidirectional, and hence define <code>to</code> and <code>from</code> references to <code>Port</code>. The original metamodel allows a <code>Connector</code> to start and end at the same <code>Port</code>, and the metamodel was evolved to prevent this, as shown in the bottom figure. <code>Port</code> was made abstract, and split into two subtypes, <code>InputPort</code> and <code>OutputPort</code>. The references between <code>Connector</code> and (the subtypes of) <code>Port</code> were renamed for consistency with the names of the subtypes.</p> classDiagram class Component {     +subcomponents: Component[*]     +connectors: Connector[*]     +ports: Port[*] } class Port {     +name: String     +outgoing: Connector     +incoming: Connector } class Connector {     +name: String     +from: Port     +to: Port } Component *-- Connector: connectors * Component *-- Component Component *-- Port: ports * Connector -- Port: from Port -- Connector: to classDiagram class Component {     +subcomponents: Component[*]     +connectors: Connector[*]     +ports: Port[*] } class Port {     +name: String     +outgoing: Connector     +incoming: Connector } class Connector {     +name: String     +in: InPort     +out: OutPort } class InputPort {     +connector: Connector } class OutputPort {     +connector: Connector } Component *-- Connector: connectors * Component *-- Component Component *-- Port: ports * InputPort --|&gt; Port: in OutputPort --|&gt; Port: out Connector -- InputPort Connector -- OutputPort <p>Some models that conform to the original metamodel do not conform to the evolved metamodel. Specifically, models might not conform to the evolved metamodel because:</p> <ol> <li> <p>They contain instances of <code>Port</code>, which is an abstract class in the evolved metamodel.</p> </li> <li> <p>They contain instances of <code>Connector</code> that specify values for the features <code>to</code> and <code>from</code>, which are not defined for the <code>Connector</code> type in the evolved metamodel.</p> </li> <li> <p>They contain instances of <code>Connector</code> that do not specify a value for the <code>in</code> and <code>out</code> features, which are mandatory for the <code>Connector</code> type in the evolved metamodel.</p> </li> </ol> <p>Model migration can be achieved with a general-purpose model-to-model transformation using a language such as ETL. However, this typically involves writing a large amount of repetitive and redundant code. Flock reduces the amount of repetitive and redundant code needed to specify model migration by automatically copying from the original to the migrated model all of the model elements that conform to the evolved metamodel as described below.</p> classDiagram class GuardedConstruct {     -guard: ExecutableBlock&lt;Boolean&gt; } class Deletion {     -originalType: String     -strict: Boolean     -cascade: Boolean } class Retyping {     -originalType: String     -strict: Boolean     -evolvedType: String } class PackageRetyping {     -originalType: String     -evolvedType: String } class PackageDeletion {     -originalType: String } class MigrateRule {     -originalType: String     -strict: Boolean     -ignoredFeatures: String[*]     -body: ExecutableBlock&lt;Void&gt; } FlockModule -- TypeMappingConstruct: typeMappings * Deletion --|&gt; TypeMappingConstruct TypeMappingConstruct &lt;|-- Retyping TypeMappingConstruct &lt;|-- PackageDeletion TypeMappingConstruct &lt;|-- PackageRetyping MigrationRule --|&gt; GuardedConstruct GuardedConstruct &lt;|-- TypeMappingConstruct FlockModule -- MigrateRule: rules * EolModule &lt;|-- ErlModule ErlModule &lt;|-- FlockModule Pre --|&gt; NamedStatementBlockRule Post --|&gt; NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post *"},{"location":"doc/flock/#abstract-syntax","title":"Abstract Syntax","text":"<p>As illustrated in the figure above, Flock migration strategies are organised into individual modules (<code>FlockModule</code>). Flock modules inherit from EOL language constructs for specifying user-defined operations and for importing other (EOL and Flock) modules. Like the other rule-based of Epsilon, Flock modules may comprise any number of pre (post) blocks, which are executed before (after) all other constructs. Flock modules comprise any number of type mappings (<code>TypeMapping</code>) and rules (<code>Rule</code>). Type mappings operate on metamodel types (<code>Retyping</code> and <code>Deletion</code>) or on metamodel packages (<code>PackageRetyping</code> and <code>PackageDeletion</code>). Type mappings are applied to a type in the original metamodel (<code>originalType</code>) or to a package in the original metamodel (<code>originalPackage</code>) . Additionally, <code>Retyping</code>s apply to an evolved metamodel type (<code>evolvedType</code>) or package (<code>evolvedPackage</code>). Each rule has an original metamodel type (<code>originalType</code>), a <code>body</code> comprising a block of EOL statements, and zero or more <code>ignoredFeatures</code>. Type mappings and rules can optionally specify a <code>guard</code>, which is either an EOL statement or a block of EOL statements. Type mappings that operate on metamodel types and rules can be marked as <code>strict</code>.</p>"},{"location":"doc/flock/#concrete-syntax","title":"Concrete Syntax","text":"<p>The listing below demonstrates the concrete syntax of the Flock language constructs. All of the constructs begin with keyword(s) (<code>retype</code>, <code>retype package</code> <code>delete</code>, <code>delete package</code> or <code>migrate</code>), followed by the original metamodel type or package. Additionally, type mappings that operate on metamodel types and rules can be annotated with the <code>strict</code> modifier. The <code>delete</code> construct can be annotated with a <code>cascade</code> modifier. All constructs can have guards, which are specified using the <code>when</code> keyword.</p> <p>Migrate rules can specify a list of features that conservative copy will ignore (<code>ignoring</code>), and a <code>body</code> containing a sequence of at least one EOL statement. Note that a migrate rule must have a list of ignored features, or a body, or both.</p> <pre><code>(@strict)?\nretype &lt;originalType&gt; to &lt;evolvedType&gt;\n(when (:&lt;eolExpression&gt;)|({&lt;eolStatement&gt;+}))? \n\nretype package &lt;originalPackage&gt; to &lt;evolvedPackage&gt;\n(when (:&lt;eolExpression&gt;)|({&lt;eolStatement&gt;+}))? \n\n(@strict)?\n(@cascade)?\ndelete &lt;originalType&gt;\n(when (:&lt;eolExpression&gt;)|({&lt;eolStatement&gt;+}))?\n\ndelete package &lt;originalPackage&gt;\n(when (:&lt;eolExpression&gt;)|({&lt;eolStatement&gt;+}))?\n\n(@strict)?\nmigrate &lt;originalType&gt;\n(ignoring &lt;featureList&gt;)?\n(when (:&lt;eolExpression&gt;)|({&lt;eolStatement&gt;+}))? {\n    &lt;eolStatement&gt;+\n}\n</code></pre> <p>Pre and post blocks have a simple syntax that, as presented below, consists of the identifier (pre or post), an optional name and the set of statements to be executed enclosed in curly braces.</p> <pre><code>(pre|post) &lt;name&gt; {\n    statement+\n}\n</code></pre>"},{"location":"doc/flock/#execution-semantics","title":"Execution Semantics","text":"<p>The execution semantics of a Flock module are now described. Note that the Epsilon Model Connectivity (EMC) layer, which Flock uses to access and manipulate models supports a range of modelling technologies, and identifies types by name. Consequently, the term type is used to mean \"the name of an element of a metamodel\" in the following discussion. For example, <code>Component</code>, <code>Connector</code> and <code>InputPort</code> are three of the types defined in the evolved metamodel.</p> <p>Execution of a Flock module occurs in six phases:</p> <ol> <li> <p>Any pre blocks are executed.</p> </li> <li> <p>Type mapping constructs (retypings and deletions) are processed to identify the way in which original and evolved metamodel types are to be related.</p> </li> <li> <p>Migrate rules are inspected to build sets of ignored properties.</p> </li> <li> <p>The information determined in steps 2 and 3 is used as input a copying algorithm, which creates an (equivalent) element in the migrated model for each element of the original model, and copies values from original to equivalent model elements.</p> </li> <li> <p>Migrate rules are executed on each pair of original and (equivalent) migrated model elements.</p> </li> <li> <p>Any post blocks are executed.</p> </li> </ol> <p>In phases 2-5, language constructs are executed only when they are applicable. The applicability of the Flock language constructs (retyping, deletion or migrate rule) is determined from their type and guard. For a language construct <code>c</code> to be applicable to an original model element <code>o</code>, <code>o</code> must instantiate either the original type of <code>c</code> or one of the subtypes of the original type of <code>c</code>; and <code>o</code> must satisfy the guard of <code>c</code>. For language constructs that have been annotated as strict, type-checking is more restrictive: <code>o</code> must instantiate the original type of <code>c</code> (and not one its subtypes). In other words, the applicability of strict constructs is determined with EOL's <code>isTypeOf</code> operation and the applicability of non-strict constructs is determined with EOL's <code>isKindOf</code> operation. For language constructs that have been annotated with cascade, type-checking is less restrictive: <code>o</code> must be contained in another model element (either directly or indirectly) to which the construct is applicable. Similarly, for language constructs that operate on packages (i.e. package retyping and package deletions), type-checking is less restrictive: <code>o</code> must be contained in a package with the same name as the original package of <code>c</code>.</p> <p>Phases 2-4 of execution implement a copying algorithm which has been termed conservative copy and is discussed thoroughly elsewhere. Essentially, conservative copy will do the following for each element of the original model, <code>o</code>:</p> <ol> <li> <p>Do nothing when <code>o</code> instantiates a type that cannot be instantiated in the evolved metamodel (e.g., because the type of <code>o</code> is now abstract or no longer exists). Example: instances of <code>Port</code> in the original metamodel are not copied because <code>Port</code> has become abstract.</p> </li> <li> <p>Fully copy <code>o</code> to produce <code>m</code> in the migrated model when <code>o</code> instantiate a type that has not been at all affected by metamodel evolution. Example: instances of <code>Component</code> in the original metamodel are fully copied because neither <code>Component</code> nor any of its features have been changed.</p> </li> <li> <p>Partially copy <code>o</code> to produce <code>m</code> in the migrated model when <code>o</code> instantiates a type with one or more features that have been affected by metamodel evolution. Example: instances of <code>Connector</code> in the original metamodel are partially copied because the <code>from</code> and <code>to</code> features have been renamed. Note that in a partial copy only the features that have not been affected by metamodel evolution are copied (e.g., the <code>name</code>s of <code>Connector</code>s).</p> </li> </ol> <p>In phase 5, migrate rules are applied. These rules specify the problem-specific migration logic and might, for example, create migrated model elements for original model elements that were skipped or partially copied by the copying algorithm described above. The Flock engine makes available two variables (<code>original</code> and <code>migrated</code>) for use in the body of any migration rule. These variables are used to refer to the particular elements of the original and migrated models to which the rule is currently being applied. In addition, Flock defines an <code>equivalent()</code> operation that can be called on any original model element and returns the equivalent migrated model element (or <code>null</code>). The <code>equivalent()</code> operation is used to access elements of the migrated model that cannot be accessed via the <code>migrated</code> variable due to metamodel evolution. Flock rules often contain statements of the form: <code>original.x.equivalent()</code> where <code>x</code> is a feature that has been removed from the evolved metamodel.</p> <p>Finally, we should consider the order in which Flock schedules language constructs: a construct that appears earlier (higher) in the source file has priority. This is important because only one type mapping (retypings and deletions) is applied per original model element, and because this implies that migrate rules are applied from top-to-bottom. This ordering is consistent with the other languages of the Epsilon platform.</p>"},{"location":"doc/flock/#example","title":"Example","text":"<p>Flock is now demonstrated using the example of model migration introduced above. Recall that the metamodel evolution  involves splitting the <code>Port</code> type to form the <code>InputPort</code> and <code>OutputPort</code> types. Below is a high-level design for migrating models from the original to the evolved metamodel.</p> <ul> <li> <p>For every instance, p, of <code>Port</code> in the original model: </p> <ul> <li> <p>If there exists in the original model a <code>Connector</code>, c, that specifies p as the value for its <code>from</code> feature:</p> <ul> <li>Create a new instance, <code>i</code>, of <code>InputPort</code> in the migrated model. </li> <li>Set c as the <code>connector</code> of <code>i</code>. </li> <li>Add c to the <code>ports</code> reference of the <code>Component</code> that contains c.</li> </ul> </li> <li> <p>If there exists in the original model a <code>Connector</code>, c, that specifies p as the value for its <code>to</code> feature: </p> <ul> <li>Create a new instance of <code>OutputPort</code> in the migrated model. </li> <li>Set c as the <code>connector</code> of i. </li> <li>Add c to the <code>ports</code> reference of the <code>Component</code> that contains c.</li> </ul> </li> </ul> </li> <li> <p>And nothing else changes.</p> </li> </ul> <p>The Flock migration strategy that implements this design is shown below. Three type mappings constructs (on lines 1-4) are used to control the way in which instances of <code>Port</code> are migrated. For example, line 3 specifies that instances of <code>Port</code> that are referenced via the <code>from</code> feature of a <code>Connector</code> are retyped, becoming <code>InputPort</code>s. Instances of <code>Connector</code> are migrated using the rule on lines 6-9, which specifies the way in which the <code>from</code> and <code>to</code> features have evolved to form the <code>in</code> and <code>out</code> features.</p> <pre><code>delete Port when: not (original.isInput() xor original.isOutput())\n\nretype Port to InputPort  when: original.isInput()\nretype Port to OutputPort when: original.isOutput()\n\nmigrate Connector {\n    migrated.`in` = original.from.equivalent();\n    migrated.out = original.`to`.equivalent();\n}\n\noperation Original!Port isInput() : Boolean {\n    return Original!Connector.all.exists(c|c.from == self);\n}\n\noperation Original!Port isOutput() : Boolean {\n    return Original!Connector.all.exists(c|c.`to` == self);\n}</code></pre> <p>Note that metamodel elements that have not been affected by the metamodel evolution, such as <code>Component</code>s, are migrated automatically. Explicit copying code would be needed to achieve this with a general purpose model-to-model transformation language.</p>"},{"location":"doc/flock/#limitations-and-scope","title":"Limitations and Scope","text":"<p>Although Flock has been shown to much more concise than general purpose model-to-model transformation languages for specifying model migration, Flock does not provide some of the features commonly available in general-purpose model-to-model transformation language. This section discusses the limitations of Flock and its intended scope with respect to other tools for model migration.</p>"},{"location":"doc/flock/#limitations","title":"Limitations","text":"<p>Firstly, Flock does not support rule inheritance, and re-use of migration logic is instead achieved by exploiting the inheritance hierarchy of the original metamodel. The form of re-use provided by Flock is less general than rule-inheritance, but has proved sufficient for existing use-cases.</p> <p>Secondly, Flock does not provide language constructs for controlling the order in which rules are scheduled (other than the ordering of the rules in the program file). ATL, for example, includes constructs that allow users to specify that rules are scheduled explicitly (lazy rules) or in a memoised manner (unique rules). We anticipate that scheduling constructs might be necessary for larger migration strategies, but have not yet encountered situations in which they have been required.</p> <p>Thirdly, Flock is tailored for applying migration to a single original and a single migrated model. Although further models can be accessed by a Flock migration strategy, they cannot be used as the source or target of the conservative copy algorithm. By contrast, some general-purpose model transformation languages can access and manipulate any number of models.</p> <p>Fourthly, Flock can only operate on models loaded with EMC drivers that implement the IReflectiveModel interface  (such as the EMF driver), as its conservative copy algorithm needs additional information to what Epsilon's IModel interface provides. </p> <p>Finally, Flock has been tailored to the model migration problem. In other words, we believe that Flock is well-suited to specifying model transformations between two metamodels that are very similar. For metamodel evolution in which the original metamodel undergoes significant and large-scale revision, a general-purpose transformation might be more suitable than Flock for specifying model migration.</p>"},{"location":"doc/flock/#scope","title":"Scope","text":"<p>Flock is typically used as a manual specification approach in which model migration strategies are written by hand. As such, we believe that Flock provides a flexible and concise way to specify migration, and is a foundation for further tools that seek to automate the metamodel evolution and model migration processes. There are approaches to model migration that encompass both the metamodel evolution and model migration processes, seeking to automatically derive model migration strategies (e.g., Edapt. These approaches provide more automation but at the cost of flexibility: for example, you might be restricted to using a tool-specific editor to perform model migration, or to using only EMF.</p> <p>A more thorough discussion of the design decisions and execution semantics of Flock can be found in a SoSyM journal article. Flock has been compared with other model migration tools and languages in a MoDELS paper.</p>"},{"location":"doc/flock/#additional-resources","title":"Additional Resources","text":"<ul> <li>Executing a Flock migration transformation from Java: Shows how to run Flock to migrate an EMF-based model from a headless Java application.</li> </ul>"},{"location":"doc/hutn/","title":"Human Usable Textual Notation","text":"<p>HUTN is an OMG standard for storing models in a human understandable format. In a sense it is a human-oriented alternative to XMI; it has a C-like style which uses curly braces instead of the verbose XML start and end-element tags. Epsilon provides an implementation of HUTN which has been realized using ETL for model-to-model transformation, EGL for generating model-to-text transformations, and EVL for checking the consistency of HUTN models.</p>"},{"location":"doc/hutn/#features","title":"Features","text":"<ul> <li>Write models using a text editor</li> <li>Generic-syntax: no need to specify parser</li> <li>Error markers highlighting inconsistencies</li> <li>Resilient to metamodel changes</li> <li>Built-in HUTN-&gt;XMI and XMI-&gt;HUTN transformations</li> <li>Automated builder (HUTN-&gt;XMI)</li> </ul>"},{"location":"doc/hutn/#examples","title":"Examples","text":"<ul> <li>Article: Using the Human-Usable Textual Notation (HUTN) in Epsilon</li> <li>Article: Using HUTN for T2M transformation -   Article: New in HUTN 0.7.1</li> <li>Article: Managing Inconsistent Models with HUTN</li> </ul>"},{"location":"doc/hutn/#reference","title":"Reference","text":"<p>The OMG provides a complete specification of the HUTN syntax.</p>"},{"location":"doc/workflow/","title":"Orchestration Workflow","text":"<p>In practice, model management activities are seldom carried out in isolation; instead, they are often combined together to form complex workflows. Therefore, in addition to task-specific languages for individual activities (model-to-text transformatino, model validation etc), Epsilon provides a set of Apache ANT tasks for assembling multi-step automated build processes.</p> <p>Running Epsilon's ANT tasks</p> <p>Epsilon's ANT tasks can run both within Eclipse and headless, and from Maven and Gradle builds too. When running an ANT workflow that involves Epsilon tasks in Eclipse, please make sure you select the <code>Run in the same JRE as the workspace</code> option under the <code>JRE</code> tab of your launch configuration.</p>"},{"location":"doc/workflow/#motivation","title":"Motivation","text":"<p>As a motivating example, a workflow that consists of both model management tasks (1-4, 6) and mainstream software development tasks (5, 7) is displayed below.</p> <ol> <li>Load a UML model</li> <li>Validate it</li> <li>Transform it into a Database Schema model</li> <li>Generate Java code from the UML model</li> <li>Compile the Java code</li> <li>Generate SQL statements from the Database model</li> <li>Run the SQL statements in a Database Management System (DBMS)</li> </ol> <p>In the above workflow, if the validation step (2) fails, the entire process should be aborted and the identified errors should be reported to the user. This example demonstrates that to be of practical use, a task orchestration framework needs to be able to coordinate both model management and mainstream development tasks and provide mechanisms for establishing dependencies between different tasks.</p> <p>This page discusses such a framework for orchestrating modular model management tasks implemented using languages of the Epsilon platform. As the problem of task coordination is common in software development, many technical solutions have been already proposed and are widely used by software practitioners. In this context, designing a new general-purpose workflow management solution was deemed inappropriate. Therefore, the task orchestration solution discussed here has been designed as an extension to the robust and widely used ANT framework. A brief overview of ANT as well as a discussion on the choice to design the orchestration workflow of Epsilon atop it is provided below.</p>"},{"location":"doc/workflow/#the-ant-tool","title":"The ANT Tool","text":"<p>ANT, named so because it is a little thing that can be used to build big things, is a robust and widely-used framework for composing automated workflows from small reusable activities. The most important advantages of ANT, compared to traditional build tools such as gnumake, is that it is platform independent and easily extensible. Platform independence is achieved by building atop Java, and extensibility is realized through a lightweight binding mechanism that enables developers to contribute custom tasks using well defined interfaces and extension points.</p> <p>This section provides a brief discussion of the structure and concrete syntax of ANT workflows, as well as the extensibility mechanisms that ANT provides to enable users contribute custom tasks.</p>"},{"location":"doc/workflow/#structure","title":"Structure","text":"<p>In ANT, each workflow is captured as a <code>project</code>. A simplified illustration of the structure of an ANT project is displayed in the figure below. Each ANT project consists of a number of <code>targets</code>. The one specified as the <code>default</code> is executed automatically when the project is executed. Each <code>target</code> contains a number of <code>tasks</code> and <code>depends</code> on other targets that must be executed before it. An ANT task is responsible for a distinct activity and can either succeed or fail. Exemplar activities implemented by ANT tasks include file system management, compiler invocation, version management and remote artefact deployment.</p> classDiagram class Project {   -targets: Target[*]   -default: Target   -properties: Property[*] } class Task {   -typeName: String   -name: String   -attributes: Attribute[*] } class Attribute {   -name: String   -value: String } class Target {   -name: String   -tasks: Task[*]   -depends: Target[*] } class HashMap {   +put(key: String, object: Object)   +get(key: String): Object } Project -- Property: properties * Project -- Target: targets * Target -- Project: default Property --|&gt; Task Task -- Attribute: attributes * Task -- Target: tasks * Target -- Target: depends * Project -- HashMap: references *"},{"location":"doc/workflow/#concrete-syntax","title":"Concrete Syntax","text":"<p>In terms of concrete syntax, ANT provides an XML-based syntax. In the listing below, an exemplar ANT project that compiles a set of Java files is illustrated. The project contains one target (<code>main</code>) which is also set to be the <code>default</code> target. The <code>main</code> target contains one <code>javac</code> task that specifies attributes such as <code>srcdir</code>, <code>destdir</code> and <code>classpath</code>, which define that the Java compiler will compile a set of Java files contained into the <code>src</code> directory into classes that should be placed in the <code>build</code> directory using <code>dependencies.jar</code> as an external library.</p> <pre><code>&lt;project default=\"main\"&gt;\n&lt;target name=\"main\"/&gt;\n&lt;javac srcdir=\"${src}\"\ndestdir=\"${build}\"\nclasspath=\"dependencies.jar\"\ndebug=\"on\"\nsource=\"1.4\"/&gt;\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"doc/workflow/#extending-ant","title":"Extending ANT","text":"<p>Binding between the XML tags that describe the tasks and the actual implementations of the tasks is achieved through a light-weight mechanism at two levels. First, the tag (in the example above, <code>javac</code>) is resolved to a Java class that extends the <code>org.apache.ant.Task</code> abstract class (in the case of <code>javac</code>, the class is <code>org.apache.tools.ant.taskdefs.Javac</code>) via a configuration file. Then, the attributes of the tasks (e.g. <code>srcdir</code>) are set using the reflective features that Java provides. Finally, the <code>execute()</code> method of the task is invoked to perform the actual job.</p> <p>ANT also supports more advanced features including nested XML elements and <code>filesets</code>, however providing a complete discussion is beyond the scope of this page.</p>"},{"location":"doc/workflow/#integration-challenges","title":"Integration Challenges","text":"<p>A simple approach to extending ANT with support for model management tasks would be to implement one standalone task for each language in Epsilon. However, such an approach demonstrates a number of integration and performance shortcomings which are discussed below.</p> <p>Since models are typically serialized in the file system, before a task is executed, the models it needs to access/modify must be parsed and loaded in memory. In the absence of a more elaborate framework, each model management task would have to take responsibility for loading and storing the models it operates on. Also, in most workflows, more than one task operates on the same models sequentially, and needlessly loading/storing the same models many times in the context of the same workflow is an expensive operation both time and memory-wise, particularly as the size of models increases.</p> <p>Another weakness of this primitive approach is limited inter-task communication. In the absence of a communication framework that allows model management tasks to exchange information with each other, it is often the case that many tasks end up performing the same (potentially expensive) queries on models. By contrast, an inter-task communication framework would enable time and resource intensive calculations to be performed once and their results to be communicated to all interested subsequent tasks.</p> <p>Having discussed ANT, Epsilon and the challenges their integration poses, the following sections presents the design of a solution that enables developers to invoke model management tasks in the context of ANT workflows. The solution consists of a core framework that addresses the challenges discussed above, a set of specific tasks, each of which implements a distinct model management activity, and a set of tasks that enable developers to initiate and manage transactions on models using the respective facilities provided by Epsilon's model connectivity layer.</p>"},{"location":"doc/workflow/#framework-design-and-core-tasks","title":"Framework Design and Core Tasks","text":"<p>The role of the core framework, illustrated below, is to provide model loading and storing facilities as well as runtime communication facilities to the individual model management tasks that build atop it. This section provides a detailed discussion of the components it consists of.</p> classDiagram class Task {   -name: String   -type: String } class VariableNestedElement {   -ref: String   -as: String   -optional: String   -ant: boolean } class EpsilonTask {   -profile: Boolean   +getProjectRepository(): ModelRepository   +getProjectContext(): IEolContext } class ExecutableModuleTask {   -src: String   -code: String   -models: ModelNestedElement[*]   -exports: ExportNestedElement[*]   -uses: UsesNestedElement[*] } class ModelNestedElement {   -ref: String   -as: String   -optional: String } Task &lt;|-- EpsilonTask EpsilonTask &lt;|-- ExecutableModuleTask ExecutableModuleTask *-- ModelNestedElement: models * ExecutableModuleTask *-- UsesNestedElement: uses * ExecutableModuleTask *-- ExportsNestedElement: exports * ExportsNestedElement --|&gt; VariableNestedElement UsesNestedElement --|&gt; VariableNestedElement classDiagram class LoadModelTask {   -name: String   -type: String   -aliases: String   -parameters: ParameterNestedElement[*] } class ParameterNestedElement {   -name: String   -value: String   -file: String } class StoreModelTask {   -model: String   -target: String } class DisposeModelTask {   -model: String } class StartTransactionTask {   -name: String   -models: String } class CommitTransactionTask {   -name: String } class RollbackTransactionTask {   -name: String } EpsilonTask &lt;|-- CommitTransactionTask EpsilonTask &lt;|-- StartTransactionTask RollbackTransactionTask --|&gt; EpsilonTask EpsilonTask &lt;|-- LoadModelTask StoreModelTask --|&gt; EpsilonTask DisposeModelTask --|&gt; EpsilonTask DisposeModelsTask --|&gt; EpsilonTask LoadModelTask *-- ParameterNestedElement: parameters *"},{"location":"doc/workflow/#the-epsilontask-task","title":"The EpsilonTask task","text":"<p>An ANT task can access the project in which it is contained by invoking the <code>Task.getProject()</code> method. To facilitate sharing of arbitrary information between tasks, ANT projects provide two convenience methods, namely <code>addReference(String key, Object ref)</code> and <code>getReference(String key) : Object</code>. The former is used to add key-value pairs, which are then accessible using the latter from other tasks of the project.</p> <p>To avoid loading models multiple times and to enable on-the-fly management of models from different Epsilon modules without needing to store and re-load the models after each task, a reference to a project-wide model repository has been added to the current ANT project using the <code>addReference</code> method discussed above. In this way, all the subclasses of the abstract <code>EpsilonTask</code> can invoke the <code>getProjectRepository()</code> method to access the project model repository.</p> <p>Also, to support a variable sharing mechanism that enables inter-task communication, the same technique has been employed; a shared context, accessible by all Epsilon tasks via the <code>getProjectContext()</code> method, has been added. Through this mechanism, model management tasks can export variables to the project context (e.g. traces or lists containing results of expensive queries) which other tasks can then reuse.</p> <p><code>EpsilonTask</code> also specifies a <code>profile</code> attribute that defines if the execution of the task must be profiled using the profiling features provided by Epsilon. Profiling is a particularly important aspect of workflow execution, especially where model management languages are involved. The main reason is that model management languages tend to provide convenient features which can however be computationally expensive (such as the <code>allInstances()</code> EOL built-in feature that returns all the instances of a specific metaclass in the model) and when used more often than really needed, can significantly degrade the overall performance.</p> <p>The workflow leverages the model-transaction services provided by the model connectivity framework of Epsilon by providing three tasks for managing transactions in the context of workflows.</p>"},{"location":"doc/workflow/#model-loading-tasks","title":"Model Loading Tasks","text":"<p>The <code>LoadModelTask (epsilon.loadModel)</code> loads a model from an arbitrary location (e.g. file-system, database) and adds it to the project repository so that subsequent Epsilon tasks can query or modify it. Since Epsilon supports many modelling technologies (e.g. EMF, MDR, XML), the <code>LoadModelTask</code> defines only three generic attributes. The <code>name</code> attribute specifies the name of the model in the project repository. The <code>type</code> attribute specifies the modelling technology with which the model is captured and is used to resolve the technology-specific model loading functionality. Finally, the <code>aliases</code> attribute defines a comma-separated list of alternative names by which the model can be accessed in the model repository.</p> <p>The rest of the information needed to load a model is implementation-specific and is therefore provided through <code>parameter</code> nested elements, each one defining a pair of <code>name</code>-<code>value</code> attributes. As an example, a task for loading an EMF model that has a file-based ECore metamodel is displayed below.</p> <pre><code>&lt;epsilon.loadModel name=\"Tree1\" type=\"EMF\"&gt;\n&lt;parameter name=\"modelFile\" value=\"TreeInstance.ecore\"/&gt;\n&lt;parameter name=\"metamodelFile\" path=\"Tree.ecore\"/&gt;\n&lt;parameter name=\"isMetamodelFileBased\" value=\"true\"/&gt;\n&lt;parameter name=\"readOnLoad\" value=\"true\"/&gt;\n&lt;/epsilon.loadModel&gt;\n</code></pre> <p><code>LoadEmfModelTask</code> is a specialised version of <code>LoadModelTask</code> only for EMF models. While the <code>type</code> attribute is no longer available, the task still supports the <code>name</code> and <code>aliases</code> attributes. In addition, some of the values which had to be provided through <code>parameter</code> nested elements can now be set using regular attributes, such as <code>modelFile</code>, <code>modelUri</code>, <code>metamodelFile</code> (which implicitly indicates that the metamodel is file-based), <code>metamodelUri</code>, <code>reuseUnmodifiedMetamodelFile</code> (which can be set to \"false\" to avoid reusing file-based metamodels that have not been modified since the last time they were loaded), <code>read</code> (equivalent to <code>readOnLoad</code>) and <code>store</code> (equivalent to <code>storeOnDisposal</code>). The listing\u00a0below shows the equivalent fragment required to produce the same result as in the listing above.</p> <pre><code>&lt;epsilon.emf.loadModel name=\"Tree1\"\nmodelFile=\"TreeInstance.ecore\"\nmetamodelFile=\"Tree.ecore\" /&gt;\n</code></pre>"},{"location":"doc/workflow/#model-storing-task","title":"Model Storing Task","text":"<p>The <code>StoreModelTask (epsilon.storeModel)</code> is used to store a model residing in the project repository. The <code>StoreModelTask</code> defines three attributes:</p> <ul> <li> <p><code>model</code> (required): name of the model to be stored.</p> </li> <li> <p><code>targetUri</code> (optional): URI where the model will be stored (e.g. \"file:/path/to/destination\").</p> </li> <li> <p><code>target</code> (optional): file path where the model will be stored (e.g. \"file.xmi\").</p> </li> </ul> <p><code>targetUri</code> takes precedence over <code>target</code>. If neither is defined, then the model is stored in the location from which it was originally loaded.</p>"},{"location":"doc/workflow/#model-disposal-tasks","title":"Model Disposal Tasks","text":"<p>When a model is no longer required by tasks of the workflow, it can be disposed using the <code>epsilon.disposeModel</code> task. The task provides the <code>model</code> attribute that defines the name of the model to be disposed. Also, the attribute-less <code>epsilon.disposeModels</code> task is provided that disposes all the models in the project model repository. This task is typically invoked when the model management part of the workflow has finished.</p>"},{"location":"doc/workflow/#the-starttransaction-task","title":"The StartTransaction Task","text":"<p>The <code>epsilon.startTransaction</code> task defines a <code>name</code> attribute that identifies the transaction. It also optionally defines a comma-separated list of model names (<code>models</code>) that the transaction will manage. If the <code>models</code> attribute is not specified, the transaction involves all the models contained in the common project model repository.</p>"},{"location":"doc/workflow/#the-committransaction-and-rollbacktransaction-tasks","title":"The CommitTransaction and RollbackTransaction Tasks","text":"<p>The <code>epsilon.commitTransaction</code> and <code>epsilon.rollbackTransaction</code> tasks define a <code>name</code> attribute through which the transaction to be committed/rolled-back is located in the project's active transactions. If several active transactions with the same name exist the more recent one is selected.</p> <p>The example below demonstrates an exemplar usage of the <code>epsilon.startTransaction</code> and <code>epsilon.rollbackTransaction</code> tasks. In this example, two empty models Tree1 and Tree2 are loaded in lines 1,2. Then, the EOL task of line 4 queries the models and prints the number of instances of the <code>Tree</code> metaclass in each one of them (which is 0 for both). Then, in line 13, a transaction named T1 is started on model Tree1. The EOL task of line 15, creates a new instance of Tree in both Tree1 and Tree2 and prints the number of instances of Tree in the two models (which is 1 for both models). Then, in line 26, the T1 transaction is rolled-back and any changes done in its context to model Tree1 (but not Tree2) are undone. Therefore, the EOL task of line 28, which prints the number of instances of Tree in both models, prints 0 for Tree1 but 1 for Tree2.</p> <pre><code>&lt;epsilon.loadModel name=\"Tree1\" type=\"EMF\"&gt;...&lt;/epsilon.loadModel&gt;\n&lt;epsilon.loadModel name=\"Tree2\" type=\"EMF\"&gt;...&lt;/epsilon.loadModel&gt;\n\n&lt;epsilon.eol&gt;\n&lt;![CDATA[\n    Tree1!Tree.allInstances.size().println(); // prints 0\n    Tree2!Tree.allInstances.size().println(); // prints 0\n    ]]&gt;\n&lt;model ref=\"Tree1\"/&gt;\n&lt;model ref=\"Tree2\"/&gt;\n&lt;/epsilon.eol&gt;\n\n&lt;epsilon.startTransaction name=\"T1\" models=\"Tree1\"/&gt;\n\n&lt;epsilon.eol&gt;\n&lt;![CDATA[\n    var t1 : new Tree1!Tree;\n    Tree1!Tree.allInstances.size().println(); // prints 1\n    var t2 : new Tree2!Tree;\n    Tree2!Tree.allInstances.size().println(); // prints 1\n    ]]&gt;\n&lt;model ref=\"Tree1\"/&gt;\n&lt;model ref=\"Tree2\"/&gt;\n&lt;/epsilon.eol&gt;\n\n&lt;epsilon.rollbackTransaction name=\"T1\"/&gt;\n\n&lt;epsilon.eol&gt;\n&lt;![CDATA[\n    Tree1!Tree.allInstances.size().println(); // prints 0\n    Tree2!Tree.allInstances.size().println(); // prints 1\n    ]]&gt;\n&lt;model ref=\"Tree1\"/&gt;\n&lt;model ref=\"Tree2\"/&gt;\n&lt;/epsilon.eol&gt;\n</code></pre> classDiagram class ExecutableModuleTask {   -src: String } class EmlTask {   -useMatchTrace: String   -exportTransformationTrace: String   -exportMergeTrace: String } class EtlTask {   -exportTransformationTrace: String } class EglTask {   -target: String } class EclTask {   -exportMatchTrace: String   -useMatchTrace: String } class EvlTask {   -failOnErrors: Boolean   -failOnWarnings: Boolean   -exportConstraintTrace: String } ExecutableModuleTask &lt;|-- EclTask ExecutableModuleTask &lt;|-- EvlTask ExecutableModuleTask &lt;|-- EglTask EmlTask --|&gt; ExecutableModuleTask EtlTask --|&gt; ExecutableModuleTask EolTask --|&gt; ExecutableModuleTask"},{"location":"doc/workflow/#the-abstract-executable-module-task","title":"The Abstract Executable Module Task","text":"<p>This task is the base of all the model management tasks presented in the following section. Its aim is to encapsulate the commonalities of Epsilon tasks in order to reduce duplication among them. As already discussed, in Epsilon, specifications of model management tasks are organized in executable modules. While modules can be stored anywhere, in the case of the workflow it is assumed that they are either stored as separate files in the file-system or they are provided inline within the worfklow. Thus, this abstract task defines an <code>src</code> attribute that specifies the path of the source file in which the Epsilon module is stored, but also supports inline specification of the source of the module. The two alternatives are demonstrated in the listings below.</p> <pre><code>&lt;project default=\"main\"&gt;\n&lt;target name=\"main\"&gt;\n&lt;epsilon.eol src=\"HelloWorld.eol\"/&gt;\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre> <pre><code>&lt;project default=\"main\"&gt;\n&lt;target name=\"main\"&gt;\n&lt;epsilon.eol&gt;\n&lt;![CDATA[\n                \"Hello world\".println();\n            ]]&gt;\n&lt;/epsilon.eol&gt;\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre> <p>Optionally, users can enable debugging for the module to be run by setting the <code>debug</code> attribute to <code>true</code>. An example is shown below. If the module reaches a breakpoint, users will be able to run the code step by step and inspect the stack trace and its variables.</p> <pre><code>&lt;project default=\"main\"&gt;\n&lt;target name=\"main\"&gt;\n&lt;epsilon.eol src=\"HelloWorld.eol\" debug=\"true\"/&gt;\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre> <p>The task also defines the following nested elements:</p>"},{"location":"doc/workflow/#0n-model-nested-elements","title":"0..n model nested elements","text":"<p>Through the <code>model</code> nested elements, each task can define which of the models, loaded in the project repository it needs to access. Each <code>model</code> element defines three attributes. The <code>ref</code> attribute specifies the name of the model that the task needs to access, the <code>as</code> attribute defines the name by which the model will be accessible in the context of the task, and the <code>aliases</code> defines a comma-delimited sequence of aliases for the model in the context of the task.</p>"},{"location":"doc/workflow/#0n-parameter-nested-elements","title":"0..n parameter nested elements","text":"<p>The <code>parameter</code> nested elements enable users to communicate String parameters to tasks. Each <code>parameter</code> element defines a <code>name</code> and a <code>value</code> attribute. Before executing the module, each <code>parameter</code> element is transformed into a String variable with the respective name and value which is then made accessible to the module.</p>"},{"location":"doc/workflow/#0n-exports-nested-elements","title":"0..n exports nested elements","text":"<p>To facilitate low-level integration between different Epsilon tasks, each task can export a number of variables to the project context, so that subsequent tasks can access them later. Each <code>export</code> nested element defines the three attributes. The <code>ref</code> attribute specifies the name of the variable to be exported, the <code>as</code> string attribute defines the name by which the variable is stored in the project context and the <code>optional</code> boolean attribute specifies whether the variable is mandatory. If <code>optional</code> is set to <code>false</code> and the module does not specify such a variable, an ANT <code>BuildException</code> is raised. If the <code>ant</code> attribute is set to true, the variable is exported as an ANT variable, as shown below.</p> <pre><code>&lt;project default=\"main\"&gt;\n&lt;target name=\"main\"&gt;\n&lt;epsilon.eol&gt;\nvar x = 1;\n      &lt;exports ref=\"x\" ant=\"true\"/&gt;\n&lt;/epsilon.eol&gt;\n&lt;echo&gt;${x}&lt;/echo&gt; &lt;!-- Prints  1 --&gt;\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"doc/workflow/#0n-uses-nested-elements","title":"0..n uses nested elements","text":"<p>The <code>uses</code> nested elements enable tasks to import variables exported by previous Epsilon tasks. Each use element supports three attributes. The <code>ref</code> attribute specifies the name of the variable to be used. If there is no variable with this name in the project context, the ANT project properties are queried. This enables Epsilon modules to access ANT parameters (e.g. provided using command-line arguments). The <code>as</code> attribute specifies the name by which the variable is accessible in the context of the task. Finally, the <code>optional</code> boolean parameter specifies if the variable must exist in the project context.</p> <p>To better illustrate the runtime communication mechanism, a minimal example is provided below. In  the first listing, <code>Exporter.eol</code> defines a String variable named <code>x</code> and assigns a value to it. The workflow below specifies that after executing <code>Exporter.eol</code>, it must export a variable named <code>x</code> with the new name <code>y</code> to the project context. Finally, it defines that before executing <code>User.eol</code>, it must query the project context for a variable named <code>y</code> and in case this is available, add the variable to the module's context and then execute it. Thus, the result of executing the workflow is <code>Some String</code> printed in the output console.</p> <pre><code>// Exporter.eol\nvar x : String = \"Some string\";</code></pre> <pre><code>// User.eol\nz.println();</code></pre> <pre><code>&lt;epsilon.eol src=\"Exporter.eol\"&gt;\n&lt;exports ref=\"x\" as=\"y\"/&gt;\n&lt;/epsilon.eol&gt;\n\n&lt;epsilon.eol src=\"User.eol\"&gt;\n&lt;uses ref=\"y\" as=\"z\"/&gt;\n&lt;/epsilon.eol&gt;\n</code></pre>"},{"location":"doc/workflow/#model-management-tasks","title":"Model Management Tasks","text":"<p>Having discussed the core framework, this section presents the model management tasks that have been implemented atop it, using languages of the Epsilon platform.</p>"},{"location":"doc/workflow/#generic-model-management-task","title":"Generic Model Management Task","text":"<p>The <code>epsilon.eol</code> task executes an EOL module, defined using the <code>src</code> attribute on the models that are specified using the <code>model</code> nested elements.</p>"},{"location":"doc/workflow/#model-validation-task","title":"Model Validation Task","text":"<p>The <code>epsilon.evl</code> task executes an EVL module, defined using the <code>src</code> attribute on the models that are specified using the <code>model</code> nested elements. In addition to the attributes defined by the ExecutableModuleTask, this task also provides the following attributes:</p> <ul> <li> <p><code>failOnErrors</code> : Errors are the results of unsatisfied constraints. Setting the value of this attribute to <code>true</code> (default is <code>false</code>) causes a <code>BuildException</code> to be raised if one or more errors are identified during the validation process.</p> </li> <li> <p><code>failOnWarnings</code> : Similarly to errors, warnings are the results of unsatisfied critiques. Setting the value of this attribute to <code>true</code> (default is also <code>false</code>) causes a <code>BuildException</code> to be raised if one or more warnings are identified during the validation process.</p> </li> <li> <p><code>exportConstraintTrace</code> : This attribute enables developers to export the internal constraint trace constructed during model validation to the project context so that it can be later accessed by other tasks - which could for example attempt to automatically repair the identified inconsistencies.</p> </li> <li> <p><code>exportAsModel</code> : Setting the value of this attribute causes the task to export the results of the validation as a new in-memory Java model with the specified name in the project repository. The exported model is essentially a wrapper for all the unsatisfied constraints identified by EVL.</p> </li> </ul>"},{"location":"doc/workflow/#model-to-model-transformation-task","title":"Model-to-Model Transformation Task","text":"<p>The <code>epsilon.etl</code> task executes an ETL module, defined using the <code>src</code> attribute to transform between the models that are specified using the <code>model</code> nested elements. In addition to the attributes defined by the ExecutableModuleTask, this task also provides the <code>exportTransformationTrace</code> attribute that enables the developer to export the internal transformation trace to the project context. In this way this trace can be reused by subsequent tasks; for example another task can serialize it in the form of a separate traceability model.</p>"},{"location":"doc/workflow/#model-comparison-task","title":"Model Comparison Task","text":"<p>The <code>epsilon.ecl</code> task executes an ECL module, defined using the <code>src</code> attribute to establish matches between elements of the models that are specified using the <code>model</code> nested elements. In addition to the attributes defined by <code>ExecutableModuleTask</code>, this task also provides the <code>exportMatchTrace</code> attribute that enables users to export the match-trace calculated during the comparison as a named variable to the project context so that subsequent tasks can reuse it. For example, as discussed in the sequel, an EML model merging task can use it as a means of identifying correspondences on which to perform merging. In another example, the match-trace can be stored by a subsequent EOL task in the form of an stand-alone weaving model.</p>"},{"location":"doc/workflow/#model-merging-task","title":"Model Merging Task","text":"<p>The <code>epsilon.eml</code> task executes an EML module, defined using the <code>src</code> attribute on the models that are specified using the <code>model</code> nested elements. In addition to the attributes defined by the ExecutableModuleTask, this task also provides the following attributes:</p> <ul> <li> <p><code>useMatchTrace</code> : To merge a set of models, an EML module needs an established match-trace between elements of the models. The <code>useMatchTrace</code> attribute enables the EML task to use a match-trace exported by a preceding ECL task (using its <code>exportMatchTrace</code> attribute).</p> </li> <li> <p><code>exportMergeTrace, exportTransformationTrace</code> : Similarly to ETL, through these attributes an EML task can export the internal traces calculated during merging for subsequent tasks to use.</p> </li> </ul>"},{"location":"doc/workflow/#model-to-text-transformation-task","title":"Model-to-Text Transformation Task","text":"<p>To support model to text transformations, <code>EglTask (epsilon.egl)</code> task is provided that executes an Epsilon Generation Language (EGL) module. In addition to the attributes defined by <code>ExecutableModuleTask</code>, <code>EglTask</code> also defines the following attributes:</p> <ul> <li> <p><code>target</code> : Defines a file in which all of the generated text will be stored.</p> </li> <li> <p><code>templateFactoryType</code> : Defines the Java class that will be instantiated to provide a <code>TemplateFactory</code> for the EGL program. The specified class must be on the classpath and must subtype <code>EglTemplateFactory</code>.</p> </li> </ul> <p><code>EglTask</code> may nest any number of <code>formatter</code> elements. The <code>formatter</code> nested element has the following attributes:</p> <ul> <li><code>implementation</code> (required) : Defines the Java class that will be instantiated to provide a <code>Formatter</code> for the EGL program. The specified class must be on the classpath and must subtype <code>Formatter</code>.</li> </ul>"},{"location":"doc/workflow/#model-migration-task","title":"Model Migration Task","text":"<p>To support model migration, <code>FlockTask (epsilon.flock)</code> is provided for executing an Epsilon Flock module. In addition to the attributes defined by <code>ExecutableModuleTask</code>, <code>FlockTask</code> also defines the following mandatory attributes:</p> <ul> <li> <p><code>originalModel</code> : Specifies which of the currently loaded models should be used as the source of the model migration.</p> </li> <li> <p><code>migratedModel</code> : Specifies which of the currently loaded models should be used as the target of the model migration.</p> </li> </ul> <p><code>&lt;model&gt;</code> nested elements still required</p> <p>Please note that <code>originalModel</code> and <code>migratedModel</code> refer to models specified using <code>&lt;model&gt;</code> nested elements under <code>epsilon.flock</code>.</p>"},{"location":"doc/workflow/#pattern-matching-task","title":"Pattern Matching Task","text":"<p>The <code>epsilon.epl</code> task executes an EPL module, defined using the <code>src</code> attribute to perform pattern matching on the models that are specified using the <code>model</code> nested elements. In addition to the attributes defined by the ExecutableModuleTask, this task also provides the following attributes.</p> <ul> <li> <p><code>repeatWhileMatches</code>: A boolean specifying whether the pattern matching process should continue to execute for as long as matches are found.</p> </li> <li> <p><code>maxLoops</code>: An integer specifying the maximum number of pattern matching iterations.</p> </li> <li> <p><code>exportAs</code>: The name under which the computed pattern match model should be made available to other Epsilon tasks of the workflow.</p> </li> </ul>"},{"location":"doc/workflow/#model-generation-task","title":"Model Generation Task","text":"<p>The <code>epsilon.emg</code> tasks extends the <code>epsilon.epl</code> task and executes an EMG model generator. In addition to EPL's attributes, the task also provides the following attribute.</p> <ul> <li><code>seed</code> (optional): A long specifying the seed to drive the random number generator that underpins the random aspects of model generation. If a seed is not specified, a random seed will be used and the generator will (likely) produce a different model every time it is executed. Fixing the seed produces repeatable results across executions.</li> </ul>"},{"location":"doc/workflow/#dataset-extraction-task","title":"Dataset Extraction Task","text":"<p>The <code>epsilon.pinset</code> task executes a Pinset module specified using the <code>src</code> attribute to generate CSV datasets from models. It also provides the following attribute.</p> <ul> <li><code>outputFolder</code> (optional): A path specifying the folder where the CSV files will be generated. If not provided, the CSVs will be created in the same folder where the <code>.pinset</code> source file resides.</li> </ul>"},{"location":"doc/workflow/#java-class-static-method-execution-task","title":"Java Class Static Method Execution Task","text":"<p>The <code>epsilon.java.executeStaticMethod</code> task executes a parameter-less static method, defined using the <code>method</code> attribute, of a Java class, defined using the <code>javaClass</code> attribute. This task can be useful for setting up the infrastructure of Xtext-based languages.</p>"},{"location":"doc/workflow/#for-task","title":"For Task","text":"<p>The <code>epsilon.for</code> task iterates over the files in a fileset and executes its nested tasks. An example that uses <code>epsilon.for</code> to run an EOL program on XML files contained in a folder called <code>loop</code> is show below.</p> <pre><code>&lt;project default=\"main\"&gt;\n&lt;target name=\"main\"&gt;\n\n&lt;!-- Load t1.xml once as Ta --&gt;\n&lt;epsilon.xml.loadModel name=\"Ta\" file=\"t1.xml\"/&gt;\n\n&lt;!-- For every XML file in the loop directory --&gt;\n&lt;epsilon.for&gt;\n&lt;fileset dir=\"loop\" includes=\"*.xml\"/&gt;\n\n&lt;!-- Load the file as Tb --&gt;\n&lt;epsilon.xml.loadModel name=\"Tb\" file=\"loop/${it}\"/&gt;\n\n&lt;!-- Run an EOL program on Ta and Tb --&gt;\n&lt;epsilon.eol&gt;\nTa!t_tree.all.a_name.println();\n                Tb!t_tree.all.a_name.println();\n                &lt;model ref=\"Ta\"/&gt;\n&lt;model ref=\"Tb\"/&gt;   &lt;/epsilon.eol&gt;\n\n&lt;!-- Dispose of Tb --&gt;\n&lt;epsilon.disposeModel model=\"Tb\"/&gt;\n&lt;/epsilon.for&gt;\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre> <p>The complete source code for this example is in Epsilon's Git repo.</p>"},{"location":"doc/workflow/#additional-resources","title":"Additional Resources","text":"<p>Additional resources about the Epsilon ANT tasks are available here.</p>"},{"location":"doc/articles/","title":"Articles","text":"<p>This page links to more than 80 articles on various aspects of Epsilon. Should you find that an article is outdated, please let us know.</p>"},{"location":"doc/articles/#epsilon-object-language","title":"Epsilon Object Language","text":"<ul> <li>EOL syntax updates: This article summarizes changes in the EOL concrete syntax over time.</li> <li>Extended Properties: This article demonstrates the extended properties mechanism in EOL (and by inheritance, in all languages in Epsilon).</li> <li>Call Java from Epsilon: This article demonstrates how to create Java objects, access their properties and call their methods from Epsilon languages.</li> <li>Running Epsilon from Java: This article demonstrates how to parse and execute Epsilon programs and load models from headless Java applications.</li> <li>Running Epsilon Programs on POJOs: This article demonstrates how to run EOL programs and EGL templates on plain-old Java objects (POJOs).</li> <li>Call Java functional interfaces from Epsilon: This article demonstrates how to call native methods which take functions as their parameter, using lambdas and streams directly from Epsilon using EOL syntax.</li> <li>Profiling Epsilon Programs: This article demonstrates how to profile Epsilon programs using the platform's built-in profiling tools.</li> <li>EOL Interpreter View: This article demonstrates an Eclipse view for running EOL scripts against selected model elements in EMF-based editors.</li> <li>Epsilon Debugger: Demonstrates how to use the Eclipse-based step-by-step debugging support in the Epsilon languages.</li> </ul>"},{"location":"doc/articles/#epsilon-validation-language","title":"Epsilon Validation Language","text":"<ul> <li>EVL-GMF Integration: This article demonstrates evaluating EVL constraints from within a GMF-based editor.</li> <li>EVL-EMF Validation Integration: This article demonstrates contributing EVL constraints to EMF's validation framework.</li> <li>Parallel Execution: This article explains how to use the parallel module implementations for EOL and rule-based languages like EVL.</li> </ul>"},{"location":"doc/articles/#epsilon-generation-language","title":"Epsilon Generation Language","text":"<ul> <li>Code Generation Tutorial with EGL: This article demonstrates using EGL templates to generate HTML files from an XML document.</li> <li>Running Epsilon Programs on POJOs: This article demonstrates how to run EOL programs and EGL templates on plain-old Java objects (POJOs).</li> <li>Using template operations in EGL: This article demonstrates template operations for writing re-usable code in EGL (the model-to-text language of Epsilon).</li> <li>EGL as a server-side language: This article demonstrates using EGL (the model-to-text language of Epsilon) in Tomcat to produce HTML pages from EMF models on the fly.</li> <li>Co-ordinating EGL templates with EGX: This article demonstrates how to parameterize EGL templates and execute them multiple times to produce multiple files.</li> <li>Re-using EGL templates: This article demonstrates how to invoke other EGL templates and direct their output to calling EGL template.</li> <li>EGL Patch Templates: This article demonstrates how to patch existing files with EGL.</li> </ul>"},{"location":"doc/articles/#epsilon-transformation-language","title":"Epsilon Transformation Language","text":"<ul> <li>XML to EMF Transformation: This article shows how to transform an XML document into an EMF model using the Epsilon Transformation Language and Epsilon's XML driver</li> </ul>"},{"location":"doc/articles/#epsilon-and-emf-models","title":"Epsilon and EMF models","text":"<ul> <li>Emfatic language reference: Emfatic is a language designed to represent EMF Ecore models in a textual form.  This article details the syntax of Emfatic and the mapping between Emfatic declarations and the corresponding Ecore constructs.</li> <li>Reflective EMF tutorial: This tutorial demonstrates how to create an EMF Ecore metamodel and a sample model that conforms to it reflectively (i.e. without generating any code).</li> <li>Epsilon and EMF: Frequently-asked questions related to querying and modifying EMF-based models with Epsilon.</li> <li>The EMF EPackage Registry View: This article demonstrates the EPackage Registry view which allows developers to inspect the contents of the registered EMF EPackages.</li> <li>Exeed annotation reference: This article lists the annotations you can use on your metamodels to customize the look of the Exeed model editor.</li> <li>Inspecting EMF models with Exeed: This article demonstrates how you can use Exeed to inspect the structure of your EMF models.</li> <li>Working with custom EMF resources: This article demonstrates how you can work with custom EMF resources in Epsilon.</li> <li>Parsing XML documents as EMF models with Flexmi: This article demonstrates how you can use Flexmi to parse XML documents in a fuzzy manner as instances of Ecore metamodels.</li> <li>Modularity Mechanisms in Flexmi: This article demonstrates how you can break down Flexmi models over multiple files and use templates to capture complex reusable structures in your models.</li> <li>Connecting to CDO repositories: This article shows how to connect to an Eclipse Connected Data Objects model repository from Epsilon.</li> <li>Using Epsilon for Ecore Validation, Setting and Invocation Delegation: This shows how to use Epsilon in an Ecore model to provide Invocation and Setting delegation with EOL and Validation Delegation with EVL.</li> </ul>"},{"location":"doc/articles/#epsilon-and-uml-models","title":"Epsilon and UML models","text":"<ul> <li>Managing Profiled UML Models in Epsilon: This article shows how to create and query profiled Eclipse UML models using Epsilon's core language.</li> </ul>"},{"location":"doc/articles/#epsilon-and-simulink-models","title":"Epsilon and Simulink models","text":"<ul> <li>Scripting Simulink models using Epsilon: In this article we demonstrate how you can query and modify Simulink models in Epsilon.</li> <li>Managing Matlab Simulink/Stateflow models from Epsilon: This tutorial shows you how to manipulate Simulink and Stateflow blocks from within Epsilon.</li> </ul>"},{"location":"doc/articles/#epsilon-and-other-types-of-models","title":"Epsilon and other types of models","text":"<ul> <li>Scripting XML documents using Epsilon: In this article we demonstrate how you can create, query and modify plain standalone XML documents (i.e. no XSD/DTD needed) in Epsilon programs using the PlainXML driver.</li> <li>Scripting XML documents that conform to an XSD schema using Epsilon: In this article we demonstrate how you can create, query and modify XML documents backed by an XSD schema in Epsilon.</li> <li>Scripting YAML documents using Epsilon: This article demonstrates how you can query and modify YAML documents with Epsilon programs using the YAML driver.</li> <li>Scripting JSON documents using Epsilon: This article shows how you can create, query and modify JSON documents with Epsilon programs using the JSON driver.</li> <li>Scripting CSV files using Epsilon: This article demonstrates how you can query CSV files with Epsilon programs using the CSV driver.</li> <li>Scripting Excel spreadsheets using Epsilon: In this article we demonstrate how you can create, query and modify Excel spreadsheets in Epsilon programs.</li> <li>Scripting HTML documents using Epsilon: In this article we demonstrate how you can create, query and modify HTML documents in Epsilon programs using the HTML driver.</li> <li>Scripting BibTeX files using Epsilon: In this article we demonstrate how you can query a list of references stored in BibTeX files with Epsilon programs using the BibTeX driver.</li> <li>Treating Java code as a model in Epsilon: In this article we demonstrate how Epsilon languages can query Java code as if it were a model, using a driver that builds on the Eclipse Java Development Tools.</li> </ul>"},{"location":"doc/articles/#eugenia","title":"Eugenia","text":""},{"location":"doc/articles/#fundamentals","title":"Fundamentals","text":"<ul> <li>Eugenia GMF Tutorial: This article provides a guide to using Eugenia for developing GMF editors, as well as its complete list of features and supported annotations.</li> <li>Customizing an editor generated with Eugenia: This article demonstrates Eugenia's polishing transformations, which can be used to customize GMF editors in a systematic and reproducible way.</li> <li>Applying source code patches to an editor generated with Eugenia: This article demonstrates Eugenia's patch generation and application functionality, which can be used to customize the Java source code generated by GMF in a systematic and reproducible way.</li> <li>Eugenia: Automated Invocation with Ant: This article demonstrates how to run Eugenia from Ant, and some of the additional features offered through the Ant task.</li> </ul>"},{"location":"doc/articles/#recipes","title":"Recipes","text":"<ul> <li>Eugenia: Nodes with images instead of shapes: This article shows how to create nodes in your GMF editor that are represented with images (png, jpg etc.) instead of the standard GMF shapes (rectangle, ellipse etc.)</li> <li>Eugenia: Nodes with images defined at run-time: This article addresses the case where the end-user needs to set an image for each node at runtime.</li> <li>Eugenia: Nodes with a centred layout: This article shows how to create nodes in your GMF editor whose contents are centred both vertically and horizontally.</li> <li>Eugenia: Phantom nodes in GMF editors: This article demonstrates how to define GMF phantom nodes in Eugenia.</li> </ul>"},{"location":"doc/articles/#picto","title":"Picto","text":"<ul> <li>Visualising Models with Picto: Picto is an Eclipse view for visualising models via model-to-text transformation to SVG/HTML. The article introduces Picto and shows the tool in action.</li> <li>Drill-Down Sequence Diagrams with Picto: This article demonstrates using Picto and its PlantUML integration to generate drill-down sequence diagrams from models conforming to a minimal EMF-based sequence diagram language.</li> <li>Visualising Models with Picto and Sirius: This article demonstrates using Picto to produce dynamic web-based views (pie and bar charts) from Sirius-based models.</li> <li>Visualising Xtext models with Picto: This article shows how Picto can be used to produce graphical views from Xtext-based models.</li> <li>Table visualisations with Picto and Pinset: This article shows how to create table views in Picto that render static CSV files or those generated with a Pinset transformation.</li> <li>Embedding Picto views in static Markdown or HTML documents: This article shows how to embed Picto views to create Markdown or HTML-based model reports.</li> </ul>"},{"location":"doc/articles/#workflow-ant-tasks","title":"Workflow (ANT Tasks)","text":"<ul> <li>Running Epsilon's ANT Tasks from Command Line: This article shows how to run Epsilon's ANT tasks from command line or in the context of a CI build.</li> </ul>"},{"location":"doc/articles/#development-environments","title":"Development Environments","text":"<ul> <li>VS Code: This article provides an overview of how you can edit and run Epsilon programs in the VS Code IDE.</li> <li>Sublime: This repository provides a package that adds Epsilon syntax highlighting capabilities to the Sublime editor.</li> </ul>"},{"location":"doc/articles/#human-usable-textual-notation","title":"Human-Usable Textual Notation","text":"<ul> <li>Using the Human-Usable Textual Notation (HUTN) in Epsilon: This article demonstrates how to specify models using a textual notation.</li> <li>Customising Epsilon HUTN documents with configuration: This article demonstrates how to customise Epsilon HUTN documents with a configuration model.</li> <li>Compliance of Epsilon HUTN to the OMG HUTN Standard: This article summarises the similarities and differences between the Epsilon HUTN implementation and the OMG HUTN standard.</li> </ul>"},{"location":"doc/articles/#teaching-material","title":"Teaching Material","text":"<ul> <li>MDE Exercises: This article provides a number of exercises which enable you to test your knowledge on MDE, EMF and Epsilon.</li> <li>Epsilon Playground: The Epsilon Playground is a web application for fiddling with metamodelling, modelling and automated model management using Emfatic, Flexmi and Epsilon's languages.</li> </ul>"},{"location":"doc/articles/#technical-support","title":"Technical Support","text":"<ul> <li>Troubleshooting: A list of common issues that (particularly new) users of Epsilon tend to run into.</li> <li>Constructing a helpful minimal example: From time to time, you may run into a problem when using Epsilon or find a bug. This article describes how to construct a minimal example that we can use to reproduce the problem on our machine.</li> </ul>"},{"location":"doc/articles/#extending-epsilon","title":"Extending Epsilon","text":"<ul> <li>Developing a new Epsilon Language: This article demonstrates how to develop a new language on top of Epsilon.</li> <li>Developing a new EMC Driver: This article demonstrates how to develop a new driver for Epsilon's Model Connectivity layer (EMC).</li> <li>Monitoring and Instrumenting Epsilon Programs: This article demonstrates how Epsilon interpreters provide support for hooking into the execution of model management programs.</li> </ul>"},{"location":"doc/articles/#installation","title":"Installation","text":"<ul> <li>Working with Epsilon 1.x: This article contains instructions for installing legacy versions of Epsilon prior to 2.0.</li> <li>Setting up Eclipse for Epsilon development: This article explains how to easily set up and configure an Eclipse IDE for contributing to Epsilon.</li> </ul>"},{"location":"doc/articles/#epsilon-developers","title":"Epsilon Developers","text":"<ul> <li>Running Epsilon from source: This article demonstrates how to run Epsilon from source in your machine.</li> <li>Call for User Stories: This is a kind request to all Epsilon Users.</li> <li>Manage the Epsilon website locally: This article demonstrates how to manage the Epsilon website in your machine.</li> <li>Epsilon development principles: These are the guiding principles used by the developers of Epsilon.</li> <li>Managing the target platform: This article outlines how to manage the target platform that Epsilon is built against.</li> <li>Adding new plugins: This article outlines the process of adding new plugins to the main Epsilon repository.</li> <li>Preparing the macOS distribution: This article outlines the process of signing the Eclipse macOS distribution.</li> <li>Publishing to the EpsilonLabs Updatesite: This article outlines the process for publishing a plugin (EMC driver/language/tool) from the EpsilonLabs Github organisation to the EpsilonLabs updatesite.</li> <li>Releasing a new version of Epsilon: This article lists all the tasks required for releasing a version of Epsilon.</li> <li>Releasing a new version to Maven Central: This article outlines how to release a new version of the Epsilon standalone artifacts to Maven Central.</li> </ul>"},{"location":"doc/articles/cdo-emc/","title":"Connecting to CDO repositories","text":"<p>Since version 2.5.0, Epsilon includes an EMC driver to connect to an Eclipse CDO model repository. Although CDO is EMF-based, and its model resources work relatively the same as standard EMF resources, accessing some of its additional features (e.g. branching and prefetching) requires using a specific model driver.</p>"},{"location":"doc/articles/cdo-emc/#prerequisites","title":"Prerequisites","text":"<p>When installing Epsilon, ensure that the \"Epsilon CDO Model Support\" feature in the \"Epsilon CDO Integration\" group is selected.</p> <p>If you are using the Epsilon launch configurations from Eclipse, you will also need the \"Epsilon CDO Model Support Developer Tools Feature\" in order to add CDO models.</p>"},{"location":"doc/articles/cdo-emc/#how-to-use-from-eclipse","title":"How to use from Eclipse","text":"<p>From an Epsilon launch confgiuration, go to the \"Models\" tab and click on \"Add...\". Tick the \"Show all model types\" box, to make \"CDO Model\" appear. Select \"CDO Model\" and click on OK.</p> <p>You will find the following options:</p> <ul> <li>Identification: this group works the same as any other model.</li> <li>Repository access: this group indicates how to locate the model.<ul> <li>URL: this is the same URL as that shown in the \"CDO Repositories\" view, removing the name of the repository (e.g. <code>jvm://local</code> for a JVM-only local repository).</li> <li>Repository: this is the name of the repository (same string that you entered from \"Repository name\" in CDO during creation). For instance, <code>repo</code>.</li> <li>Branch: this can be left empty if using the main branch, or you can enter the full path to the branch in question. Note that <code>branch1</code> created off from the main branch should be entered as <code>MAIN/branch1</code>, rather than as just <code>branch1</code>. (If you make a mistake, the driver will list the paths to all available branches.)</li> <li>Path: this is the absolute path (starting with <code>/</code>) to the relevant model resource in your CDO repository (e.g. <code>/model</code>).</li> <li>Create if missing: if ticked, the driver will automatically create the model resource if it does not exist yet in your repository.</li> </ul> </li> <li>Prefetching: this section controls CDO's options for automatically prefetching elements from the model, to reduce the number of roundtrips done over the network.<ul> <li>Initial collection prefetch size: when first fetching a collection, how many elements to fetch in advance. 0 means \"do not fetch any objects until the lists are accessed\".</li> <li>Collection resolving chunk size: how many elements to fetch in one chunk when needed.</li> <li>Revision prefetch size: when accessing revisions, how many revisions to fetch per chunk.</li> <li>Use CDO model-based feature analyzer: if enabled, CDO will track which features are being traversed and prefetch those in later accesses of objects of the same EClass.</li> </ul> </li> <li>Load/Store Options:<ul> <li>Due to the fact that CDO works like a database rather than like a file-based model (where you can immediately connect to it and access its entire contents), the \"Read on load\" option is not used by the driver.</li> <li>The \"Store on disposal\" option is honored, however. If ticked, the driver will commit a new revision when the model is disposed. If left unticked, the driver will discard the transaction without committing anything to the repository.</li> </ul> </li> </ul> <p>For an example with step-by-step instructions, please consult this project on Github.</p>"},{"location":"doc/articles/cdo-emc/#how-to-use-from-java","title":"How to use from Java","text":"<p>You will need to create a new instance of the <code>CDOModel</code> class, and use setter methods to configure it appropriately. The setter methods match the options listed above.</p> <p>For concrete examples, please consult the JUnit tests for the driver.</p>"},{"location":"doc/articles/debugger/","title":"Epsilon Debugger","text":"<p>All Epsilon languages include interactive Eclipse-based debuggers. The debugger for the Epsilon Object Language is demonstrated in the screencast below.</p> <p>Since 2.6.0, you can debug Epsilon scripts which run from outside an Eclipse launch configuration (e.g. embedded in a Java program or executed from the command line), using the Epsilon Debug Adapter Protocol server and a DAP client.</p> <p>The <code>examples.eol.dap</code> project on GitHub shows several examples of how to do this, and further information on various use cases is listed below.</p>"},{"location":"doc/articles/debugger/#debugging-epsilon-scripts-embedded-in-java-programs","title":"Debugging Epsilon scripts embedded in Java programs","text":"<p>If you are running your Epsilon script from a Java program, you can wrap your module in an <code>EpsilonDebugServer</code> class provided by Epsilon and debug it through a DAP client of your choice. The video below gives an overview of the Debug Adapter Protocol, and explains the design and general use of the debug adapter for Epsilon.</p>"},{"location":"doc/articles/debugger/#importing-the-epsilondebugserver-into-your-program","title":"Importing the EpsilonDebugServer into your program","text":"<p>If you are developing a regular Java program, you will need to add a dependency to the <code>org.eclipse.epsilon.eol.dap</code> Maven artifact of your chosen Epsilon release. More information on the stable and interim Epsilon Maven artifacts is available from our download page.</p> <p>If you are developing an Eclipse plug-in, you will need to declare a dependency on the <code>org.eclipse.epsilon.eol.dap</code> plugin.</p>"},{"location":"doc/articles/debugger/#wrapping-your-module-with-the-epsilondebugserver","title":"Wrapping your module with the EpsilonDebugServer","text":"<p>The next step is to replace your regular <code>module.execute()</code> call with code that uses the debug server. For instance, if you have this code:</p> <pre><code>Object result = module.execute();\n</code></pre> <p>You can replace it with:</p> <pre><code>EpsilonDebugServer server = new EpsilonDebugServer(module, port);\nserver.run();\nObject result = server.getResult().get();\n</code></pre> <ul> <li>The first line wraps the module with Epsilon's DAP server and indicates that it will listen on a certain port (it can be a port of your choosing, or 0 to pick any available port).</li> <li>The second line starts the server and blocks until the script has completed its execution: the server will automatically shut down once the script has completed its execution.</li> <li>The third line retrieves the result of <code>module.execute()</code>: it will also rethrow any exceptions produced by <code>module.execute()</code>.</li> </ul> <p>The script will not start its execution until a DAP client connects to it, to allow you to set any necessary breakpoints.</p> <p>The next step is to connect to the DAP server with your DAP client of choice. Several options are discussed in the DAP client section.</p>"},{"location":"doc/articles/debugger/#mapping-module-uris-to-your-ide-files","title":"Mapping module URIs to your IDE files","text":"<p>If your Epsilon scripts are being loaded from URIs rather than regular files, you will need to tell the <code>EpsilonDebugServer</code> how to map those module URIs to the files with your breakpoints. Here is a simplified excerpt from the <code>DebugClasspathBasedEOL</code> example, which shows how to do this:</p> <pre><code>EolModule module = new EolModule();\nURI classpathUri = DebugClasspathBasedEOL.class.getResource(\"your.eol\").toURI();\nmodule.parse(classpathUri);\n\nEpsilonDebugServer server = new EpsilonDebugServer(module, 4040);\nserver.getDebugAdapter().getUriToPathMappings().put(\nclasspathUri,\nPaths.get(\"src/path/to/your.eol\"));\n\nserver.run();\n</code></pre> <p>A debugging session would work like this:</p> <ul> <li>From your DAP client, you would set some breakpoints in <code>your.eol</code>.</li> <li>Run the above code, leaving the script waiting for a DAP connection.</li> <li>Connect with your DAP client, which will send the breakpoints in <code>src/path/to/your.eol</code> file.</li> <li>The DAP server will map the <code>src/path/to/your.eol</code> breakpoints to your parsed module.</li> <li>The DAP server will start the execution of your script.</li> <li>The script will reach one of the breakpoints and stop execution.</li> <li>The server will map the location that we stopped in to <code>src/path/to/your.eol</code> file and report it to your DAP client.</li> <li>Your DAP client will then highlight the relevant line and allow you to inspect variables and control execution.</li> </ul>"},{"location":"doc/articles/debugger/#debugging-epsilon-scripts-running-from-ant-workflows","title":"Debugging Epsilon scripts running from Ant workflows","text":"<p>If you need to debug your Epsilon script that you are running from the command line (e.g. Ant or Gradle), you will need to use the Debug Adapter Protocol support available from Epsilon 2.6.0. To do so, set the <code>debug</code> and <code>debugPort</code> attributes in your Ant task, like this:</p> <pre><code>&lt;epsilon.eol ... debug=\"true\" debugPort=\"4040\"/&gt;\n</code></pre> <p>When executed, this task will start a DAP server listening on TCP port 4040. It wait for a connection from a DAP client, and then start the script.</p> <p>Epsilon includes an example of an Ant buildfile that uses DAP for debugging. There is also an example of a Gradle script.</p>"},{"location":"doc/articles/debugger/#debug-adapter-protocol-clients-tested-with-epsilon","title":"Debug Adapter Protocol clients tested with Epsilon","text":"<p>After the <code>EpsilonDebugServer</code> has started and is waiting for a DAP connection, you should be able to connect to it with a DAP client of your choice. This section details two DAP clients that have been tested with the Epsilon DAP server.</p>"},{"location":"doc/articles/debugger/#eclipse-lsp4e","title":"Eclipse LSP4E","text":"<p>To use this client, install it from its official repository. You will need the \"Debug Adapter client for Eclipse IDE\" feature.</p> <p>Set your breakpoints as usual. Once the DAP server is running and waiting for connections (as shown in the terminal with the \"Started Epsilon debug server\" text), start a \"Remote Epsilon Program\" debug configuration that attaches to the relevant port in <code>localhost</code>:</p> <p></p> <p>Once LSP4E connects to the DAP server, the script will start running. After hitting a breakpoint, you will be prompted to switch to the Debug perspective, as usual:</p> <p></p>"},{"location":"doc/articles/debugger/#microsoft-visual-studio-code","title":"Microsoft Visual Studio Code","text":"<p>Recent versions of the VS Code support in Epsilon include support for the Epsilon DAP server. Epsilon includes an example Gradle project with VS Code configuration files that you can use as a starting point. The rest of the section breaks down some of these details.</p>"},{"location":"doc/articles/debugger/#starting-the-dap-server","title":"Starting the DAP server","text":"<p>First, you will need to add the <code>debug</code> and <code>debugPort</code> attributes to the Ant tasks being executed from your Gradle script:</p> <pre><code>task runHello {\ndependsOn tasks.setupEpsilonTasks\ndoLast {\nant.'epsilon.eol'(src: '01-hello.eol', debug: true, debugPort: 4040)\n}\n}\n</code></pre> <p>Note how the Epsilon task is wrapped in a <code>doLast</code> block, to ensure it only runs when we explicitly run the task, and not on Gradle's configure phase. When the task is run, execution will suspend until a DAP client (VS Code in this case) connects to the DAP server.</p>"},{"location":"doc/articles/debugger/#creating-and-launching-a-debug-configuration","title":"Creating and launching a debug configuration","text":"<p>You will then need to add a launch configuration to your <code>launch.json</code> file. Based on the above example, you would need something like:</p> <pre><code>{\n\"type\": \"epsilon\",\n\"request\": \"attach\",\n\"name\": \"Debug 01-hello\",\n\"port\": 4040\n}\n</code></pre> <p>Set breakpoints as usual. Launch the above configuration, and you should be able to hit breakpoints, control execution, and inspect variables as usual:</p> <p></p>"},{"location":"doc/articles/debugger/#single-click-launching-and-debugging","title":"Single-click launching and debugging","text":"<p>The above approach requires separately launching your Gradle task, and your debug configuration. You can configure VS Code to launch the Gradle task for you, by using a <code>preLaunchTask</code>.</p> <p>First, open the Command Palette as usual (Ctrl+Shift+P in Windows/Linux, or \"View - Command Palette...\" from the menus), and select \"Tasks: Configure Task\":</p> <p></p> <p>Select the \"Gradle: ...\" task corresponding to the Gradle task to be executed:</p> <p></p> <p>This add a rather verbose block to your <code>tasks.json</code> file:</p> <pre><code>{\n\"type\": \"gradle\",\n\"id\": \"...\",\n\"script\": \"runHello\",\n\"description\": \"\",\n\"group\": \"other\",\n\"project\": \"org.eclipse.epsilon.examples.eol.dap\",\n\"buildFile\": \".../org.eclipse.epsilon/examples/org.eclipse.epsilon.examples.eol.dap/epsilon/build.gradle\",\n\"rootProject\": \"org.eclipse.epsilon.examples.eol.dap\",\n\"projectFolder\": \".../org.eclipse.epsilon/examples/org.eclipse.epsilon.examples.eol.dap/epsilon\",\n\"workspaceFolder\": \".../org.eclipse.epsilon/examples/org.eclipse.epsilon.examples.eol.dap/epsilon\",\n\"args\": \"\",\n\"javaDebug\": false,\n\"problemMatcher\": [\n\"$gradle\"\n],\n\"label\": \"gradle: runHello\"\n}\n</code></pre> <p>This JSON block needs a number of changes before it can be used:</p> <ul> <li>Remove the unnecessary <code>id</code>, <code>description</code>, <code>project</code>, and <code>rootProject</code> fields.</li> <li>Use <code>${workspaceFolder}</code> to shorten the values of <code>buildFile</code>, <code>projectFolder</code>, and <code>workspaceFolder</code>.</li> <li>Change <code>args</code> to <code>\"--info\"</code>: we need the INFO log messages to detect when the DAP server has started.</li> <li>Add the <code>\"$epsilon-debug\"</code> problem matcher, which will detect when the DAP server has started.</li> <li>Optionally, change the label to <code>\"epsilonDebug: runHello\"</code>, to distinguish it from a normal Gradle task execution.</li> <li>Add an <code>\"isBackground\": true</code> setting, to mark it as a background task. Otherwise, debugging will never start as VS Code will indefinitely wait for this task to complete, rather than read the INFO messages to detect when the DAP server has started.</li> </ul> <p>You should end up with something like the following:</p> <pre><code>{\n\"type\": \"gradle\",\n\"script\": \"runHello\",\n\"group\": \"other\",\n\"buildFile\": \"${workspaceFolder}/build.gradle\",\n\"workspaceFolder\": \"${workspaceFolder}\",\n\"projectFolder\": \"${workspaceFolder}\",\n\"args\": \"--info\",\n\"problemMatcher\": [\n\"$gradle\",\n\"$epsilon-debug\"\n],\n\"label\": \"epsilonDebug: hello\",\n\"isBackground\": true\n}\n</code></pre> <p>Now that the task has been set up, you can return to your <code>launch.json</code> file, and use the task as your <code>preLaunchTask</code>:</p> <pre><code>{\n\"type\": \"epsilon\",\n\"request\": \"attach\",\n\"name\": \"Debug 01-hello\",\n\"port\": 4040,\n\"preLaunchTask\": \"epsilonDebug: hello\"\n}\n</code></pre> <p>After these steps, launching <code>Debug 01-hello</code> should run the Gradle task, wait until the DAP server is started, and then start the debugging session as usual.</p>"},{"location":"doc/articles/egl-patch/","title":"EGL Patch Templates","text":"<p>A patch file (also called a patch for short) is a text file that consists of a list of differences and is produced, usually, by running the related the <code>diff</code> program with the original and updated file as arguments. The differences follow the diff format. A patch processor can read a patch file and use the contents as a set of instructions. By following those instructions, a target file can be modified to match the changes in the patch file.</p> <p>Although patches are usually created using a diff tool, it is also possible to write them manually and then use the patch processor to modify a file. This is the approach we provide via EGL patch rules.</p>"},{"location":"doc/articles/egl-patch/#egl-diff-format","title":"EGL Diff Format","text":"<p>In EGL we support a custom diff format. </p> <ul> <li>A line starting with <code>+</code> represents the addition of a line, i.e. this line will be added to the file.</li> <li>A line starting with <code>-</code> represents the deletion of a line, i.e, this line will be removed from the file.</li> <li>A line containing only <code>...</code> indicates a block of lines to keep, i.e. all lines until the next diff/match will be kept.</li> <li>A line containing only <code>---</code> indicates a block of lines to remove, i.e. all lines until the next diff/match will be removed.</li> <li>A line with no diff information is used as a match and will be kept.</li> </ul>"},{"location":"doc/articles/egl-patch/#egl-diff-processor","title":"EGL Diff Processor","text":"<p>The EGl diff processor uses un-diffed lines to match sections of the file and then uses any diff entries till the next un-diffed lines to modify (add/remove/keep) the file. Deletions will also be used to match locations. All additions before a deletion/un-diff will be inserted before the deleted/un-diffed line. All additions after a deletion/un-diff will be inserted after the deleted/un-diffed line.</p>"},{"location":"doc/articles/egl-patch/#example-templates","title":"Example Templates","text":"<p>In this example we want to insert getters in a Java class file. </p> getters.egl <pre><code>[%for (a in c.eAllAttributes.excludingAll(c.eAttributes)) {%]\n+\n+   /**\n+    * @generated\n+    */\n+   @Override\n+   public [%=a.eType.instanceTypeName%] get[%=a.name.ftuc()%]() {\n+       if ([%=a.name%] == null) {\n+           return prototype.get[%=a.name.ftuc()%]();\n+       }\n+       else return [%=a.name%];\n+   }\n[%}%]\n-} //[%=c.name%]Impl\n+} //[%=c.name%]Impl (Patched)</code></pre> <ul> <li>There are no un-diffed lines in the template.</li> <li>There is one deletion: <code>-} //[%=c.name%]Impl</code>, thus the processor would match the closing bracket of the Java class commented with the Java class name.</li> <li>The for loop would generate a getter for each attribute and insert it before the closing bracket location.</li> <li>The closing bracket and comment are removed</li> <li>A new closing bracket with the modified comment is added.</li> </ul> <p>In this other example, we want to modify the toString method of a Java class.</p> toString.egl <pre><code>    public String toString() {\n        ---\n+       return \"[%=c.name%]\";\n    }</code></pre> <ul> <li>The <code>public String toString() {</code> line would be used to match the toString method.</li> <li>The <code>---</code> indicates that all the lines in the method, until the closing bracket (which is the next matched line) should be removed.</li> <li>The new method implementation is added, which will return the class name.</li> </ul>"},{"location":"doc/articles/egl-patch/#using-patch-egl-templates","title":"Using patch EGL templates","text":"<p>To use EGL templates with diff lines they must be invoked from an EGX rule annotated with <code>@patch</code>. The example EGL templates above would be invoked like this:</p> <pre><code>@patch\nrule EClass2Getters \n    transform c : EClass {\n\n    guard : c.eAnnotations.exists(a|a.source = \"instance\")\n\n    template : \"getters.egl\"\n\n    target : \"src/\" + c.eContainer().name + \"/impl/\" + c.name + \"Impl.java\"\n}\n\n@patch\nrule EClass2ToString \n    transform c : EClass {\n\n    template : \"toString.egl\"\n\n    target : \"src/\" + c.eContainer().name + \"/impl/\" + c.name + \"Impl.java\"\n}</code></pre>"},{"location":"doc/articles/epsilon-pojos/","title":"Running Epsilon Programs on POJOs","text":"<p>Epsilon's languages can be used to query and modify plain-old Java objects (POJOs). The following Maven-based example demonstrates setting up a <code>Project</code> object with two <code>Task</code>s, and passing it to an EOL program (<code>return project.tasks.size();</code>) to query.</p> EOLExample.javaProject.javaTask.javapom.xml <pre><code>package org.eclipse.epsilon.examples.pojos;\n\nimport org.eclipse.epsilon.eol.EolModule;\nimport org.eclipse.epsilon.eol.execute.context.Variable;\n\npublic class EOLExample {\n\npublic static void main(String[] args) throws Exception {\n\n// Set up the project POJO (plain-old Java object)\nProject project = new Project();\n\nTask analysis = new Task();\nanalysis.setName(\"Analysis\");\nanalysis.setDuration(3);\nproject.getTasks().add(analysis);\n\nTask design = new Task();\ndesign.setName(\"Design\");\ndesign.setDuration(6);\nproject.getTasks().add(design);\n\n// Parse the EOL program to run on the POJO\nEolModule module = new EolModule();\nmodule.parse(\"return project.tasks.size();\");\n\n// Make the POJO available to the EOL program\nmodule.getContext().getFrameStack().put(Variable.createReadOnlyVariable(\"project\", project));\n\n// Execute the EOL program and print its output\nObject result = module.execute();\n\nSystem.out.println(\"Result: \" + result);\n}\n}\n</code></pre> <pre><code>package org.eclipse.epsilon.examples.pojos;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Project {\n\nprotected String name;\nprotected List&lt;Task&gt; tasks = new ArrayList&lt;&gt;();\n\npublic List&lt;Task&gt; getTasks() {\nreturn tasks;\n}\n\npublic String getName() {\nreturn name;\n}\n\npublic void setName(String name) {\nthis.name = name;\n}\n}\n</code></pre> <pre><code>package org.eclipse.epsilon.examples.pojos;\n\npublic class Task {\n\nprotected String name;\nprotected int duration;\n\npublic String getName() {\nreturn name;\n}\n\npublic void setName(String name) {\nthis.name = name;\n}\n\npublic int getDuration() {\nreturn duration;\n}\n\npublic void setDuration(int duration) {\nthis.duration = duration;\n}\n}\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\nxmlns=\"http://maven.apache.org/POM/4.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;\n&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;examples.pojos&lt;/artifactId&gt;\n&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n\n&lt;properties&gt;\n&lt;epsilon.version&gt;2.5.0&lt;/epsilon.version&gt;\n&lt;epsilon.scope&gt;compile&lt;/epsilon.scope&gt;\n&lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n&lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n&lt;/properties&gt;\n\n&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.eol.engine&lt;/artifactId&gt;\n&lt;version&gt;${epsilon.version}&lt;/version&gt;\n&lt;scope&gt;${epsilon.scope}&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.egl.engine&lt;/artifactId&gt;\n&lt;version&gt;${epsilon.version}&lt;/version&gt;\n&lt;scope&gt;${epsilon.scope}&lt;/scope&gt;\n&lt;/dependency&gt;       &lt;/dependencies&gt;\n\n&lt;/project&gt;\n</code></pre>"},{"location":"doc/articles/epsilon-pojos/#running-an-egl-template-against-the-pojo","title":"Running an EGL Template against the POJO","text":"<p>The example below demonstrates processing the same POJO using Epsilon's template language (EGL), to generate text from it.</p> EGLExample.javaProject.javaTask.javapom.xml <pre><code>package org.eclipse.epsilon.examples.pojos;\n\nimport org.eclipse.epsilon.egl.EglModule;\nimport org.eclipse.epsilon.eol.execute.context.Variable;\n\npublic class EGLExample {\npublic static void main(String[] args) throws Exception {\n\n// Set up the project POJO (plain-old Java object)\nProject project = new Project();\n\nTask analysis = new Task();\nanalysis.setName(\"Analysis\");\nanalysis.setDuration(3);\nproject.getTasks().add(analysis);\n\nTask design = new Task();\ndesign.setName(\"Design\");\ndesign.setDuration(6);\nproject.getTasks().add(design);\n\n// Parse the EGL template to run on the POJO\nEglModule module = new EglModule();\nmodule.parse(\n\"[%for (task in project.tasks){%]\\n\" +\n\"- Task: [%=task.name%] ([%=task.duration%] months)\\n\" +\n\"[%}%]\"\n);\n\n// Make the project POJO available to the EGL template\nmodule.getContext().getFrameStack().put(Variable.createReadOnlyVariable(\"project\", project));\n\n// Execute the EGL template and print its output\nObject result = module.execute();\n\nSystem.out.println(\"Result\");\nSystem.out.println(result);\n}\n}\n</code></pre> <pre><code>package org.eclipse.epsilon.examples.pojos;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Project {\n\nprotected String name;\nprotected List&lt;Task&gt; tasks = new ArrayList&lt;&gt;();\n\npublic List&lt;Task&gt; getTasks() {\nreturn tasks;\n}\n\npublic String getName() {\nreturn name;\n}\n\npublic void setName(String name) {\nthis.name = name;\n}\n}\n</code></pre> <pre><code>package org.eclipse.epsilon.examples.pojos;\n\npublic class Task {\n\nprotected String name;\nprotected int duration;\n\npublic String getName() {\nreturn name;\n}\n\npublic void setName(String name) {\nthis.name = name;\n}\n\npublic int getDuration() {\nreturn duration;\n}\n\npublic void setDuration(int duration) {\nthis.duration = duration;\n}\n}\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\nxmlns=\"http://maven.apache.org/POM/4.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;\n&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;examples.pojos&lt;/artifactId&gt;\n&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n\n&lt;properties&gt;\n&lt;epsilon.version&gt;2.5.0&lt;/epsilon.version&gt;\n&lt;epsilon.scope&gt;compile&lt;/epsilon.scope&gt;\n&lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n&lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n&lt;/properties&gt;\n\n&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.eol.engine&lt;/artifactId&gt;\n&lt;version&gt;${epsilon.version}&lt;/version&gt;\n&lt;scope&gt;${epsilon.scope}&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.egl.engine&lt;/artifactId&gt;\n&lt;version&gt;${epsilon.version}&lt;/version&gt;\n&lt;scope&gt;${epsilon.scope}&lt;/scope&gt;\n&lt;/dependency&gt;       &lt;/dependencies&gt;\n\n&lt;/project&gt;\n</code></pre> <p>The complete source of the example is on GitHub.</p>"},{"location":"doc/articles/evl-emf-integration/","title":"EVL-EMF Validation Integration","text":"<p>The Eclipse Modeling Framework (EMF) provides an extensible model validation service via the EValidator API. The API allows contributing additional validators for Ecore metamodels via the <code>EValidator.Registry</code> class. In this way, you can provide additional validation constraints for metamodels that will be invoked when models conforming to these metamodels are validated by EMF (e.g. through the <code>Model</code> \u2192 <code>Right-click</code> \u2192 <code>Validate</code> menu in EMF's built-in reflective).</p>"},{"location":"doc/articles/evl-emf-integration/#the-evlvalidator-class","title":"The EvlValidator Class","text":"<p>Epsilon provides an implementation of EMF's <code>EValidator</code> interface (<code>EvlValidator</code>) that can execute EVL constraints against EMF models.</p>"},{"location":"doc/articles/evl-emf-integration/#registering-evl-constraints","title":"Registering EVL Constraints","text":"<p>There are two ways to register your EVL constraints for an Ecore metamodel (<code>EPackage</code>): programmatically or via an extension point.</p>"},{"location":"doc/articles/evl-emf-integration/#programmatically","title":"Programmatically","text":"<p>For this you need to create a new instance of an <code>EvlValidator</code> and then add it to the <code>EValidatorRegistry</code>. Note that if there are existing validators registered for the metamodel, you should not remove/overwrite them; instead you should combine them in a <code>CompositeEValidator</code>.</p> <p>The following snippet outlines the general idea (you need to make your own provisions if you need to validate multiple <code>EPackages</code> with the same validator (e.g. use the <code>EvlValidator#addAdditionalPackage</code> method)).</p> <pre><code>// Assuming you have generated the metamodel code\nEPackage ePackage = YourPackage.eINSTANCE;\n\n// Pass a model name if your script uses it\n// Pass a valid bundle ID as it used for reporting (if not in a plugin use your project name or similar)\nEvlValidator evlValidator = new EvlValidator(\nevlScriptURI, modelName, ePackage.nsUri(), bundleId);\n\nEValidator existingValidator = EValidator.Registry.INSTANCE.getEValidator(ePackage);\nif (existingValidator instanceof CompositeEValidator) {\n((CompositeEValidator) existingValidator).getDelegates().add(evlValidator);\n} else {\nif (existingValidator == null) {\nexistingValidator = EObjectValidator.INSTANCE;\n}\nCompositeEValidator newValidator = new CompositeEValidator();\nnewValidator.getDelegates().add(existingValidator);\nnewValidator.getDelegates().add(evlValidator);\nEValidator.Registry.INSTANCE.put(ePackage, newValidator);\n}\n</code></pre>"},{"location":"doc/articles/evl-emf-integration/#via-the-extension-point","title":"Via the Extension Point","text":"<p>Epsilon provides the <code>org.eclipse.epsilon.evl.emf.validation</code> extension point for registering EVL constraints against <code>EPackages</code> in Eclipse. The extension point will handle the <code>EvlValidator</code> instantiation and registration for you.</p> <pre><code>&lt;plugin&gt;\n...\n   &lt;extension\npoint=\"org.eclipse.epsilon.evl.emf.validation\"&gt;\n&lt;constraintsBinding\ncompose=\"true\"\nconstraints=\"src/test.evl\"\nnamespaceURI=\"http://your.package.uri\"\nvalidator=\"my.project.evl.EvlExtendedValidator\"&gt;\n&lt;additionalNamespaceURI\nnamespaceURI=\"http://some.other.pacakge.uri\"&gt;\n&lt;/additionalNamespaceURI&gt;\n&lt;/constraintsBinding&gt;\n&lt;/extension&gt;\n&lt;/plugin&gt;\n</code></pre> <p>We recommend setting the <code>compose</code> attribute to <code>true</code>, else you will overwrite existing validators. You can also specify additional metamodels to be accessed by this validator using the <code>additionalNamespaceURI</code> entries. Note that you can also provide your own validator implementation. If omitted, the default <code>EvlValidator</code> will be used (should be sufficient for most cases).</p>"},{"location":"doc/articles/evl-emf-integration/#runtime-adjustments","title":"Runtime Adjustments","text":"<p>Note</p> <p>The following adjustments are only possible if you control invocation of the validation, i.e. you are calling it programatically and not via the EMF/Eclipse right-click menu.</p> <p>There are three important runtime aspects to be taken into consideration when using the EVL-EMF integration.</p>"},{"location":"doc/articles/evl-emf-integration/#error-dialogs","title":"Error Dialogs","text":"<p>Within Eclipse, Epsilon reports errors via Eclipse's JFace <code>MessageDialog</code> API. This is appropriate when checking constraints via the <code>Model</code> \u2192 <code>Right-click</code> \u2192 <code>Validate</code> menu in EMF's built-in tree-based editor, but can be cumbersome when the validation is integrated into other parts of your UI. To disable error reporting via message dialogs you can use use the EvlValidator#setShowErrorDialog function. You can either call this on you instance or override the <code>isShowErrorDialog()</code> if you extend the <code>EvlValidator</code> class.</p>"},{"location":"doc/articles/evl-emf-integration/#logging","title":"Logging","text":"<p>Epsilon logs errors in the console. As with the dialogs, this can be enabled/disabled. For this, you can use use the EvlValidator#setLogErrors method. Similarly, the <code>isLogErrors()</code> can be overridden.</p> <p>Tip</p> <p>The dialogs are part of the logging, so disabling logging will disable the dialogs too.</p>"},{"location":"doc/articles/evl-emf-integration/#validation-progress-and-cancellation","title":"Validation progress and cancellation","text":"<p>Within Eclipse it is important to allow uses to cancel a running validation. To do so, we need to pass an <code>IProgressMonitor</code> to the EvlValidator. For this, you need to provide your own Diagnostician.</p> <pre><code>public class MyDiagnostician extends Diagnostician {\n\npublic Diagnostic validate(EObject eObject, IProgressMonitor monitor) {\nBasicDiagnostic diagnostics = createDefaultDiagnostic(eObject);\nvalidate(eObject, diagnostics, createDefaultContext(monitor), monitor);\nreturn diagnostics;\n}\n\n// Overload the Diagnostician implementation to inject the monitor into the context\npublic Map&lt;Object, Object&gt; createDefaultContext(IProgressMonitor monitor) {\nfinal Map&lt;Object, Object&gt; defaultContext = super.createDefaultContext();\ndefaultContext.put(EvlValidator.VALIDATION_MONITOR, monitor);\nreturn defaultContext;\n}\n}\n</code></pre> <p>And then in your code (e.g. command handler):</p> <pre><code>@Override\npublic void run(IProgressMonitor monitor) throws CoreException {\nmyDgnstc = new MyDiagnostician();\nDiagnostic dgnstc = rnblDgnstc.validate(model.getContents().get(0), monitor);\n...\n</code></pre> <p>The extended diagnostician can also be used to configure any <code>EvlValidators</code> provided via extension points, e.g. to disable logging or dialogs. In this case we assume that all <code>EvlValidators</code> are within <code>CompositeEValidators</code> (adjust if not using them). This implementation uses a brute force approach; ideally you should search for a specific <code>EPackage</code> instead.</p> <pre><code>public class MyDiagnostician extends Diagnostician {\n\npublic MyDiagnostician() {\nsuper();\nfor(Object validator : eValidatorRegistry.values()) {\nif (validator instanceof CompositeEValidator) {\nCompositeEValidator cmpsVal = (CompositeEValidator) validator;\nfindEvlValidators(cmpsVal);\n}\n}\n}\n\npublic Diagnostic validate(EObject eObject, IProgressMonitor monitor) {\nBasicDiagnostic diagnostics = createDefaultDiagnostic(eObject);\nvalidate(eObject, diagnostics, createDefaultContext(monitor), monitor);\nreturn diagnostics;\n}\n\n// Overload the Diagnostician implementation to inject the monitor into the context\npublic Map&lt;Object, Object&gt; createDefaultContext(IProgressMonitor monitor) {\nfinal Map&lt;Object, Object&gt; defaultContext = super.createDefaultContext();\ndefaultContext.put(EvlValidator.VALIDATION_MONITOR, monitor);\nreturn defaultContext;\n}\n\n/**\n     * Find all {@link EVlValidator}s and configure them.\n     * @param cmpsVal\n     * @return\n     */\nprivate void findEvlValidators(CompositeEValidator cmpsVal) {\nfor (EValidator nstdVal : cmpsVal.getDelegates()) {\nif (nstdVal instanceof EVlValidator) {\nEVlValidator evlVal = (EVlValidator) nstdVal;\nevlVal.setShowErrorDialog(false);\n// Other settings or hook error listeners\n// evlVal.addValidationProblemListener(this);\n}\n}\n}\n}\n</code></pre>"},{"location":"doc/articles/run-epsilon-from-java/","title":"Running Epsilon from Java","text":"<p>While Epsilon's development tools are based on Eclipse, its runtime is not, and can be used from any (headless) Java application. For example, the back-end of the Epsilon Playground is a headless, server-less Java application that runs on Google's Cloud Platform.</p> <p>Did you know that ...</p> <p>Contrary to popular belief, EMF is not tightly coupled to the Eclipse IDE either, and can also be embedded in any Java application by importing a couple of dependencies from Maven Central.</p>"},{"location":"doc/articles/run-epsilon-from-java/#dependencies","title":"Dependencies","text":"<p>Epsilon libraries are available on MavenCentral. Below is a fragment of a Maven <code>pom.xml</code> file, where we declare dependencies to the execution engine of Epsilon's core expression language and on Epsilon's driver for EMF-based models. As the EMF driver has a dependency on EMF, we don't need to declare a dependency to the EMF libraries on MavenCentral; Maven will fetch these automatically for us.</p> <pre><code>&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.emc.emf&lt;/artifactId&gt;\n&lt;version&gt;2.2.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.eol.engine&lt;/artifactId&gt;\n&lt;version&gt;2.2.0&lt;/version&gt;\n&lt;/dependency&gt;\n...\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"doc/articles/run-epsilon-from-java/#parsing-and-executing-epsilon-programs","title":"Parsing and Executing Epsilon Programs","text":"<p>Having declared a dependency to the EOL engine, parsing and executing an EOL program is as simple as that.</p> <pre><code>EolModule module = new EolModule();\nmodule.parse(new File(\"program.eol\"));\nmodule.execute();\n</code></pre> <p>Tip</p> <p>By replacing <code>EolModule</code> with <code>EtlModule</code>, <code>EvlModule</code> etc. you can parse and execute ETL transformations, EVL validation constraints etc. EGL deviates from this pattern and if you wish to execute a single template you should use the <code>EglTemplateFactoryModuleAdapter</code> class.</p>"},{"location":"doc/articles/run-epsilon-from-java/#loading-models","title":"Loading Models","text":"<p>Most of your Epsilon programs will need to run against models of some sort. To run an EOL program against a model (<code>model.xmi</code>) that conforms to a file-based Ecore metamodel (<code>metamodel.ecore</code>), you can extend the code above as follows.</p> <pre><code>// Loads the EMF model\nEmfModel model = new EmfModel();\nmodel.setMetamodelFile(\"metamodel.ecore\");\nmodel.setModelFile(\"model.xmi\");\n// Set the name by which the model will be\n// referred to in the program. Useful if\n// the program manages more than one models\nmodel.setName(\"M\");\n// Read the contents of the model from disk\n// when the model is loaded. Set to false\n// to ignore existing model contents (e.g.\n// if the model is the target of a \n// model-to-text transformation)\nmodel.setReadOnLoad(true);\n// Save any changes made to the model\n// when it is disposed\nmodel.setStoredOnDisposal(true);\nmodel.load();\n\n// Parses and executes the EOL program\nEolModule module = new EolModule();\nmodule.parse(new File(\"program.eol\"));\n// Makes the model accessible from the program\nmodule.getContext().getModelRepository().addModel(model);\nmodule.execute();\n\n// Saves any changes to the model\n// and unloads it from memory\n// Use model.getContext().\n//   getModelRepository().dispose() \n// instead if multiple models are involved\nmodel.dispose();\n</code></pre>"},{"location":"doc/articles/run-epsilon-from-java/#adding-variables","title":"Adding Variables","text":"<p>You can add variables to your Epsilon program and provide their values from Java as shown below.</p> <pre><code>EolModule module = new EolModule();\nmodule.parse(\"s.println();\");\nmodule.getContext().getFrameStack().put(Variable.\ncreateReadOnlyVariable(\"s\", \"Hello World\"));\nmodule.execute();\n</code></pre>"},{"location":"doc/articles/run-epsilon-from-java/#using-tools-contributed-by-plugins","title":"Using Tools Contributed by Plugins","text":"<p>To use tools contributed by other plugins in a standalone Java setup within Eclipse you'll need to add the following line of code.</p> <pre><code>context.getNativeTypeDelegates().\nadd(new ExtensionPointToolNativeTypeDelegate());\n</code></pre>"},{"location":"doc/articles/run-epsilon-from-java/#analysing-epsilon-programs","title":"Analysing Epsilon Programs","text":"<p>Epsilon programs do not have an Ecore-based metamodel, but you can query and analyse them through Epsilon's Java API as shown below.</p> <pre><code>// Parse an ETL transformation\nEtlModule m = new EtlModule();\nm.parse(\"rule A2B transform a : In!A to b : Out!B { b.name = a.name; }\");\n\n// Get the first rule of the transformation\nTransformationRule a2b = m.getTransformationRules().get(0);\n// Print its name\nSystem.out.println(a2b.getName());\n\n// Get the body of the A2B rule\nStatementBlock body = (StatementBlock) a2b.getBody().getBody();\n// Print the number of statements it contains\nSystem.out.println(body.getStatements().size());\n</code></pre> <p>As of version 2.3, Epsilon programs can also be analysed using visitors. As an example, see the <code>EolUnparser</code> class which recursively visits the contents of an <code>EolModule</code> and pretty-prints it. To implement your own analyser, you will need to implement the <code>IEolVisitor</code> interface for EOL, or the respective <code>IE*lVisitor</code> interfaces for other Epsilon-based languages. Using a combination of <code>E*lUnparser</code> and your custom visitor, you can easily rewrite Epsilon programs too.</p> <pre><code>EolModule module = new EolModule();\nmodule.parse(\"'Hello world'.println();\");\n\nEolUnparser unparser = new EolUnparser();\n// Prints \"Hello world\".println();\nSystem.out.println(unparser.unparse(module));\n</code></pre>"},{"location":"doc/articles/run-epsilon-from-java/#debugging-epsilon-programs","title":"Debugging Epsilon Programs","text":"<p>To debug Epsilon programs being executed from a Java program, read these instructions.</p>"},{"location":"doc/articles/run-epsilon-from-java/#more-examples","title":"More Examples","text":"<p>In Epsilon's Git repository, there are two example projects that show how to run Epsilon from Java, and the ANT Epsilon tasks in a headless environment (i.e. from command line).</p>"},{"location":"doc/articles/xml-to-emf/","title":"XML to EMF Transformation with ETL","text":"<p>This example shows how to transform an XML document into an EMF model using the Epsilon Transformation Language and Epsilon's XML driver. We start with our source XML file (<code>tree.xml</code>), which is shown below:</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;tree name=\"t1\"&gt;\n&lt;tree name=\"t2\"/&gt;\n&lt;tree name=\"t3\"&gt;\n&lt;tree name=\"t4\"/&gt;\n&lt;/tree&gt;\n&lt;/tree&gt;\n</code></pre> <p>The Ecore metamodel (expressed in Emfatic) to which our target EMF model will conform to is shown below:</p> <pre><code>package tree;\n\nclass Tree {\n    attr String label;\n    ref Tree#children parent;\n    val Tree[*]#parent children;\n}</code></pre> <p>Finally, our ETL transformation (<code>xml2emf.etl</code>) is in the listing below:</p> <pre><code>rule XmlTree2EmfTree\n    transform s : Xml!t_tree\n    to t : Emf!Tree {\n\n    t.label = s.a_name;\n    t.children ::= s.c_tree;\n\n}</code></pre> <p>The transformation consists of one rule which transforms every tree element in the XML document (<code>Xml!t_tree</code>) into an instance of the Tree class of our Ecore metamodel above. The rule sets the <code>label</code> of the latter to the <code>name</code> of the former, and the <code>children</code> of the latter, to the equivalent model elements produced by the <code>tree</code> child elements of the former.</p> <p>To run the transformation:</p> <ul> <li>Right-click on <code>tree.emf</code> or <code>tree.ecore</code> and select <code>Register EPackages</code></li> <li>Right-click on <code>xml2emf.launch</code> and select <code>Run As</code> \u2192 <code>xml2emf</code></li> </ul> <p>Once the transformation has executed you can open <code>tree.model</code> to inspect the EMF model it has produced with the reflective tree-based editor. The complete source code of the example is available here.</p>"},{"location":"doc/articles/adding-new-plugins/","title":"Adding new plugins","text":"<p>This article outlines the process of adding new plugins to the main Epsilon repository.</p> <ul> <li>Move them to the Epsilon repository. Plugins, features, tests and examples should be placed under the respective directories in the repository. </li> <li>Add <code>pom.xml</code> files similar to the ones we already have for each plugin, but changing the <code>&lt;artifactId&gt;</code> to the Eclipse plugin name. </li> <li>If you want its tests to be run from Hudson as plug-in tests, add them to the <code>EpsilonHudsonPluggedInTestSuite</code> in <code>org.eclipse.epsilon.test</code>. </li> <li>Define a feature for the new plugins (feature project in features/, as usual, but with its own POM) and add it to the <code>site.xml</code> in the <code>org.eclipse.epsilon.updatesite.interim</code> project. </li> <li>Change the <code>plugins/pom.xml</code>, <code>tests/pom.xml</code> and <code>features/pom.xml</code> so they mention the new projects in their <code>&lt;modules&gt;</code> section. </li> <li>If you want a specific standalone JAR for this, you\\'ll need to update the <code>jarmodel.xml</code>, rerun the <code>jarmodel2mvn.launch</code> launch config, and then mention the new Maven assembly descriptor in the <code>org.eclipse.epsilon.standalone/pom.xml</code> file. There's a readme.txt file in that folder that explains the process. </li> <li>Update <code>org.eclipse.epsilon/standalone/org.eclipse.epsilon.standalone/pom.xml</code> with the details of the new plugins.</li> </ul>"},{"location":"doc/articles/bibtex/","title":"Scripting BibTeX files using Epsilon","text":"<p>In this article we demonstrate how you can query list of references stored in BibTeX files in Epsilon programs using the BibTeX EMC driver. All the examples in this article demonstrate using EOL to script BibTeX files. However, it's worth stressing that BibTeX files are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models - XML or EMF-based -, or to text), compare and merge your BibTeX files.</p>"},{"location":"doc/articles/bibtex/#querying-a-bibtex-file","title":"Querying a BibTeX file","text":"<p>We use the following <code>eclipse.bib</code> as a base for demonstrating the EOL syntax for querying BibTeX files.</p> <pre><code>@book{steinberg09emf,\nauthor    = {Steinberg, D. and Budinsky, F. and Paternostro, M. and Merks, E.},\ntitle     = {{EMF}: {E}clipse {M}odeling {F}ramework},\nyear      = {2008},\npublisher = {Addison-Wesley Professional},\naddress   = {Boston, Massachusetts}\n}\n\n@inproceedings{gronback06gmf,\nauthor    = {Gronback, R.},\ntitle     = {Introduction to the {Eclipse Graphical Modeling Framework}},\nbooktitle = {Proc. EclipseCon},\nyear      = {2006},\naddress   = {Santa Clara, California}\n}\n\n@article{brooks86nosilverbullet,\nauthor    = {Brooks Jr., F.P.},\ntitle     = {No Silver Bullet - Essence and Accidents of Software Engineering},\njournal   = {IEEE Computer},\nvolume    = {20},\nnumber    = {4},\nyear      = {1987},\npages     = {10-19},\n}\n</code></pre>"},{"location":"doc/articles/bibtex/#how-can-i-access-all-publications","title":"How can I access all publications?","text":"<p>Presuming that we have specified the name <code>MyPubs</code> when loading the BibTeX file as a model, the <code>allContents</code> method can be used to access all of the entries in the BibTeX file:</p> <pre><code>// Get all publications\nvar publications = MyPubs.allContents();</code></pre>"},{"location":"doc/articles/bibtex/#how-can-i-access-a-publication","title":"How can I access a publication?","text":"<p>Publications (entries) in a BibTeX file can be accessed by type:</p> <pre><code>// Get all @book elements\nvar books = Book.all;\n\n// Get a random book\nvar b = Book.all.random();</code></pre> <p>Note that the BibTeX driver recognises only those types defined in your BibTeX file. For example, attempting to call <code>Phdthesis.all</code> will result in an error for the BibTeX file shown above, as that BibTeX file contains no <code>@phdthesis</code> entries.</p>"},{"location":"doc/articles/bibtex/#how-can-i-access-and-change-the-properties-of-a-particular-publication","title":"How can I access and change the properties of a particular publication?","text":"<p>Properties are accessed via the dot notation:</p> <pre><code>// Get a random book\nvar b = Book.all.random();\n\n// Get the title of the random book\nvar t = b.title;\n\n// Get the Amazon rating of the random book\nvar a = b.amazonRating;</code></pre> <p>Note that the empty string is returned when accessing a property that does not exist (such as the amazonRating property in the example above).</p> <p>Properties can be changed using an assignment statement:</p> <pre><code>// Get a random book\nvar b = Book.all.random();\n\n// Get the title of the random book\nb.title = \"On the Criteria To Be Used in Decomposing Systems into Modules\"</code></pre> <p>Note that the current version of the BibTeX driver does not support saving changes to disk. Any changes made to properties are volatile (and persist only during the duration of the Epsilon program's execution).</p>"},{"location":"doc/articles/bibtex/#adding-a-bibtex-file-to-your-launch-configuration","title":"Adding a BibTeX file to your launch configuration","text":"<p>To add a BibTeX file to your Epsilon launch configuration, you need to select \"Show all model types\" and then choose \"BibTeX model\" from the list of available model types.</p> <p></p> <p>Then you can configure the details of your BibTeX (name, file etc.) in the screen that pops up.</p> <p></p>"},{"location":"doc/articles/bibtex/#unsupported-features","title":"Unsupported features","text":"<p>The current version of the BibTeX driver for Epsilon is not yet a complete implementation. In particular, the following features are not yet supported:</p> <ul> <li>Storing changes to BibTeX models to disk.</li> <li>Deleting entries from a BibTeX file.</li> </ul> <p>Please file an enhancement request if you require -- or can provide a patch for -- these features.</p>"},{"location":"doc/articles/call-for-user-stories/","title":"Call for User Stories","text":"<p>Over the last few years we've been delighted to see the Epsilon community grow and expand. We'd like to take the opportunity to thank you all for your feedback and contributions, and if it's not too much of a hassle, we'd like to ask for your help one more time.</p> <p>Epsilon is developed and maintained by members of staff at the University of York (UK) and University of Cadiz (Spain). In the context of the UK Research Excellence Framework 2014, we (the York people) need to prepare a portfolio that demonstrates the impact of our research (for some definition of impact).</p> <p>In this direction it'd be really appreciated if you spare a few minutes to write a few sentences on what you're using Epsilon for in your company/research group and why it's cool, and share them with us at epsilon.devs@gmail.com.</p> <p>All responses, no matter how short or seemingly trivial, would be very helpful for us, and will be rewarded accordingly next time we meet. Of course, no user story will be made publicly available without your explicit consent.</p> <p>In case you'd like an example, we recently received the following statement from Jendrik Johannes, a founder of DevBoost. Our thanks to Jendrik for his statement and for kindly allowing us to use it here.</p> <p>\"We used Eugenia in a project where we developed a graphical editor for a client as an extension for their existing tool for modeling wind farms. The client already used a model as the basis for the tool and thus it was a matter of minutes to generate a prototype of the editor with Eugenia. This gave us the possibility to discuss the clients requirements directly on a working prototype which later on also served as the basis for the actual implementation. Using Eugenia, we implemented the prototype within a week - a task that usually takes a month.\"</p> <p>[Jendrik Johannes, founder of DevBoost]</p>"},{"location":"doc/articles/call-java-from-epsilon/","title":"Call Java from Epsilon","text":"<p>Model management languages such as those provided by Epsilon are by design not general purpose languages. Therefore, there are features that such languages do not support inherently (mainly because such features are typically not needed in the context of model management). However, there are cases where a feature that is not built-in may be necessary for a specific task. </p> <p>To address such issues and enable developers to implement non-standard functionality, Epsilon supports the Tool concept. A tool is a normal Java class that (optionally) conforms to a specific interface (<code>org.eclipse.epsilon.eol.tools.ITool</code>) and which can be instantiated and accessed from the context of an EOL (or any other EOL-based language such as EML, ETL, EVL etc) program. After instantiation, EOL can be used to invoke methods and access properties of the object. In this article we show how to create and declare a new tool (<code>org.eclipse.epsilon.examples.tools.SampleTool</code>), and then use it from an EOL program.</p>"},{"location":"doc/articles/call-java-from-epsilon/#create-the-tool","title":"Create the tool","text":"<p>The first step is to create a new plugin project named <code>org.eclipse.epsilon.examples.tools</code>. Then create a class named <code>SampleTool</code> with the following content.</p> <pre><code>package org.eclipse.epsilon.examples.tools;\n\npublic class SampleTool {\n\nprotected String name;\n\npublic void setName(String name) {\nthis.name = name;\n}\n\npublic String getName() {\nreturn name;\n}\n\npublic String sayHello() {\nreturn \"Hello \" + name;\n}\n\n}\n</code></pre>"},{"location":"doc/articles/call-java-from-epsilon/#declare-the-tool","title":"Declare the tool","text":"<ul> <li>Add <code>org.eclipse.epsilon.common.dt</code> to the dependencies of your plugin</li> <li>Create an extension to the <code>org.eclipse.epsilon.common.dt.tool</code> extension point</li> <li>Set the class to <code>org.eclipse.epsilon.examples.tools.SampleTool</code></li> <li>Set the name to <code>SampleTool</code></li> <li>Add <code>org.eclipse.epsilon.examples.tools</code> to the exported packages list in the Runtime tab</li> </ul>"},{"location":"doc/articles/call-java-from-epsilon/#invoke-the-tool","title":"Invoke the tool","text":"<p>To invoke the tool you have two options: You can either run a new Eclipse instance, or export the plugin and place it in the <code>dropins</code> folder of your installation. Then you can invoke the tool using the following EOL program.</p> <pre><code>var sampleTool = \n  new Native(\"org.eclipse.epsilon.examples.tools.SampleTool\");\nsampleTool.name = \"George\";\nsampleTool.sayHello().println(); // Prints Hello George</code></pre>"},{"location":"doc/articles/call-java-from-epsilon/#standalone-setup","title":"Standalone setup","text":"<p>To use tools contributed via extensions in a standalone Java setup within Eclipse you'll need to add the following line of code.</p> <pre><code>context.getNativeTypeDelegates().\nadd(new ExtensionPointToolNativeTypeDelegate());\n</code></pre> <p>You can get the source code of this example here.</p>"},{"location":"doc/articles/code-generation-tutorial-egl/","title":"Code Generation Tutorial with EGL","text":"<p>EGL is a template-based language that can be used to generate code (or any other kind of text) from different types of models supported by Epsilon (e.g. EMF, UML, XML). This example demonstrates using EGL to generate HTML code from the XML document below.</p> <pre><code>&lt;library&gt;\n&lt;book title=\"EMF Eclipse Modeling Framework\" pages=\"744\" public=\"true\"&gt;\n&lt;id&gt;EMFBook&lt;/id&gt;\n&lt;author&gt;Dave Steinberg&lt;/author&gt;\n&lt;author&gt;Frank Budinsky&lt;/author&gt;\n&lt;author&gt;Marcelo Paternostro&lt;/author&gt;\n&lt;author&gt;Ed Merks&lt;/author&gt;\n&lt;published&gt;2009&lt;/published&gt;\n&lt;/book&gt;\n&lt;book title=\"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages=\"736\" public=\"true\"&gt;\n&lt;id&gt;EMPBook&lt;/id&gt;\n&lt;author&gt;Richard Gronback&lt;/author&gt;\n&lt;published&gt;2009&lt;/published&gt;\n&lt;/book&gt;\n&lt;book title=\"Official Eclipse 3.0 FAQs\" pages=\"432\" public=\"false\"&gt;\n&lt;id&gt;Eclipse3FAQs&lt;/id&gt;\n&lt;author&gt;John Arthorne&lt;/author&gt;\n&lt;author&gt;Chris Laffra&lt;/author&gt;\n&lt;published&gt;2004&lt;/published&gt;\n&lt;/book&gt;\n&lt;/library&gt;\n</code></pre> <p>More specifically, we will generate one HTML file for each <code>&lt;book&gt;</code> element that has a <code>public</code> attribute set to <code>true</code>. Below is an EGL template (<code>book2page.egl</code>) that can generate an HTML file from a single <code>&lt;book&gt;</code> element. For more details on using EGL's expression language to navigate and query XML documents, please refer to this article.</p> <pre><code>&lt;h1&gt;Book [%=index%]: [%=book.a_title%]&lt;/h1&gt;\n\n&lt;h2&gt;Authors&lt;/h2&gt;\n&lt;ul&gt;\n[%for (author in book.c_author) { %]\n  &lt;li&gt;[%=author.text%]\n[%}%]\n&lt;/ul&gt;</code></pre> <p>The template above can generate one HTML file from one <code>&lt;book&gt;</code> element. To run this template against '''all''' <code>&lt;book&gt;</code> elements anywhere in the XML document, and generate appropriately-named HTML files, we need to use an EGX co-ordination program such as the one illustrated below (<code>main.egx</code>). The <code>Book2Page</code> rule of the EGX program will <code>transform</code> every <code>&lt;book&gt;</code> element (<code>t_book</code>) that satisfies the declared <code>guard</code> (has a <code>public</code> attribute set to <code>true</code>), into a <code>target</code> file, using the specified <code>template</code> (<code>book2page.egl</code>). In addition, the EGX program specifies a <code>Library2Page</code> rule, that generates an HTML (index) file for each <code>&lt;library&gt;</code> element in the document.</p> <pre><code>rule Book2Page \n  transform book : t_book {\n\n  // We only want to generate pages\n  // for books that have their public\n  // attribute set to true\n  guard : book.b_public\n\n  parameters {\n    // These parameters will be made available\n    // to the invoked template as variables\n    var params : new Map;\n    params.put(\"index\", t_book.all.indexOf(book) + 1);\n    return params;\n  }\n\n  // The EGL template to be invoked\n  template : \"book2page.egl\"\n\n  // Output file\n  target : \"gen/\" + book.e_id.text + \".html\"\n\n}\n\nrule Library2Page \n  transform library : t_library {\n\n  template : \"library2page.egl\"\n\n  target : \"gen/index.html\"\n}</code></pre> <p>For completeness, the source code of the <code>library2page.egl</code> template appears below.</p> <pre><code>&lt;h1&gt;Books&lt;/h1&gt;\n\n&lt;ul&gt;\n[%for (book in library.c_book.select(b|b.b_public)) { %]\n  &lt;li&gt;&lt;a href=\"[%=book.e_id.text%].html\"&gt;[%=book.a_title%]&lt;/a&gt;\n[%}%]\n&lt;/ul&gt;</code></pre>"},{"location":"doc/articles/code-generation-tutorial-egl/#running-the-code-generator-from-eclipse","title":"Running the Code Generator from Eclipse","text":"<p>Screenshots of the Eclipse run configuration appear below. The complete source for this example is available here.</p> <p></p> <p></p> <p></p>"},{"location":"doc/articles/code-generation-tutorial-egl/#running-the-code-generator-from-java","title":"Running the Code Generator from Java","text":"<p>The following snippet demonstrates using Epsilon's Java API to parse the XML document and execute the EGX program. The complete source for this example is available here (please read <code>lib/readme.txt</code> for instructions on how to obtain the missing Epsilon JAR). </p> <pre><code>import java.io.File;\n\nimport org.eclipse.epsilon.egl.EglFileGeneratingTemplateFactory;\nimport org.eclipse.epsilon.egl.EgxModule;\nimport org.eclipse.epsilon.emc.plainxml.PlainXmlModel;\n\npublic class App {\n\npublic static void main(String[] args) throws Exception {\n\n// Parse main.egx\nEgxModule module = new EgxModule(new EglFileGeneratingTemplateFactory());\nmodule.parse(new File(\"main.egx\").getAbsoluteFile());\n\nif (!module.getParseProblems().isEmpty()) {\nSystem.out.println(\"Syntax errors found. Exiting.\");\nreturn;\n}\n\n// Load the XML document\nPlainXmlModel model = new PlainXmlModel();\nmodel.setFile(new File(\"library.xml\"));\nmodel.setName(\"L\");\nmodel.load();\n\n// Make the document visible to the EGX program\nmodule.getContext().getModelRepository().addModel(model);\n// ... and execute\nmodule.execute();\n}\n\n}  </code></pre>"},{"location":"doc/articles/csv-emc/","title":"Scripting CSV documents using Epsilon","text":"<p>In this article we demonstrate how you can create, query and modify CSV documents in Epsilon programs using the CSV driver. The examples in this article demonstrate using EOL and ETL to script CSV documents. However, it's worth stressing that CSV documents are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models - XML or EMF-based -, or totext), compare and merge your CSV documents.</p> <p>Note: This article is consistent with Epsilon versions 1.5+.</p>"},{"location":"doc/articles/csv-emc/#the-csv-model-configuration-dialog","title":"The CSV Model Configuration Dialog","text":"<p>To add a CSV document to your Epsilon launch configuration you first need to click on \"Show all model types\" in order to display the CSV Model type. From there you can select \"CSV Model\" from the list of available model types.</p> <p></p> <p>Then you can configure the details of your document (name, file etc.) in the screen that pops up.</p> <p></p> <p>You need to provide a name for the model and select the CSV file using the \"Browse Workspace...\" button.</p> <p>The CSV section allows you to define specific behaviour for the CSV model.</p> <ul> <li> <p>The Field Separator allows you to select a different separator than comma.... yes, they are called comma-separated files, but sometimes a colon, or a semi-colon, or other char is used as a field separator. Now you can tell the model loader which one too use. By default it is a comma.</p> </li> <li> <p>The Quote Character allows you to select the character used for quotes. Quotes are used when a column value contains the field separator to avoid erroneous input.</p> </li> <li> <p>The Known Headers tells the loader that the first row of your file contains headers. Headers can late be used to access fields of a row.</p> </li> <li> <p>The Varargs Header tells the loader that the last column/field of the file can span multiple columns. This is not the \"standard\" (did you know that RFC 4180 describes CSV file standards?), but in some cases it can be useful.</p> </li> <li> <p>Finally, the Id Field allows you to optionally select one of the fields as an id for your model elements. When using Known Headers, this should be the name of one of the fields. If not, it should be the index (integer) of the field.</p> </li> </ul> <p>Next we show how the different options can be used when working with CSV models.</p>"},{"location":"doc/articles/csv-emc/#querying-a-csv-document","title":"Querying a CSV document","text":"<p>All elements in the CSV model are of type <code>Row</code>, that is, all model access has to be done using that type.</p>"},{"location":"doc/articles/csv-emc/#header-less-csv-model","title":"Header-less CSV Model","text":"<p>Consider the following <code>NoHeaders.csv</code> input.</p> <pre><code>604-78-8459,Ricoriki,Dwyr,rdwyr0@parallels.com,Male,VP Quality Control,2558058636921002,Horror\n272-41-1349,Norry,Halpin,nhalpin1@slashdot.org,Female,Legal Assistant,,Drama\n844-07-0023,Matteo,Macer,mmacer2@sogou.com,Male,Tax Accountant,3542981651057648,Horror\n429-41-4964,Kattie,Fysh,kfysh3@angelfire.com,Female,Senior Financial Analyst,,Comedy\n378-90-9530,Link,Proffitt,lproffitt4@cloudflare.com,Male,Paralegal,,Drama\n811-26-0387,Rafferty,Sobieski,rsobieski5@usatoday.com,Male,Physical Therapy Assistant,5602242765074843,Horror\n386-53-1139,Ernestine,Kringe,ekringe6@gov.uk,Female,Software Consultant,3531096662484096,Drama\n850-05-5333,Flossy,Mobberley,fmobberley7@msn.com,Female,Chief Design Engineer,3558038696922012,Romance\n605-52-9809,Tull,Ingerith,tingerith8@surveymonkey.com,Male,VP Quality Control,,Drama\n580-79-7291,Derry,Laurisch,dlaurisch9@taobao.com,Male,Software Test Engineer I,,War\n676-89-8860,Cosetta,Vlasov,cvlasova@livejournal.com,Female,Nurse Practicioner,,Thriller\n748-10-2370,Lissa,Stanger,lstangerb@tmall.com,Female,Analyst Programmer,,Thriller\n164-18-3409,Giffie,Boards,gboardsc@gmpg.org,Male,Graphic Designer,3575314620284632,Comedy\n212-06-7778,Rabbi,Varran,rvarrand@jugem.jp,Male,GIS Technical Architect,3551249058791476,Horror\n628-02-3617,Olvan,Alabone,oalabonee@archive.org,Male,Help Desk Technician,,Thriller\n318-48-3006,Constantino,Eyckelbeck,ceyckelbeckf@histats.com,Male,Recruiter,564182300132483644,War\n122-74-6759,Nickolas,Collard,ncollardg@dot.gov,Male,Web Designer IV,,Drama\n309-57-3090,Chere,Hurry,churryh@huffingtonpost.com,Female,Tax Accountant,,Mystery\n833-32-9040,Mattie,Hamon,mhamoni@auda.org.au,Male,Structural Engineer,,Drama\n101-82-2564,Hew,Goble,hgoblej@ocn.ne.jp,Male,VP Accounting,,Comedy\n</code></pre> <p>Since there are no headers, we need to access the information via the general field attribute and index (0 based):</p> <pre><code>// Get all Rows elements\nvar people = Row.all;\n\n// Get a random person\nvar p = people.random();\n\n// Check the gender of p (field 4)\n// Prints 'Male' or 'Female'\np.field.at(4).println();\n\n// Get the emails (field 3) of people that like Horror movies (field 7) so we can let them know a new movie is out.\n// Prints 'Sequence {rdwyr0@parallels.com, mmacer2@sogou.com, rsobieski5@usatoday.com, rvarrand@jugem.jp}'\npeople.select(p | p.field.at(7) == 'Horror').collect(p | p.field.at(3)).println();</code></pre>"},{"location":"doc/articles/csv-emc/#header-full-csv-model","title":"Header-full CSV Model","text":"<p>Consider that we add headers to the previous CSV model (<code>Headers.csv</code>)</p> <pre><code>id,first_name,last_name,email,gender,job,credit_card,movies\n604-78-8459,Ricoriki,Dwyr,rdwyr0@parallels.com,Male,VP Quality Control,2558058636921002,Horror\n272-41-1349,Norry,Halpin,nhalpin1@slashdot.org,Female,Legal Assistant,,Drama\n...\n</code></pre> <p>We can query the same information as before, but this time we can use the field names defined by the header:</p> <pre><code>// Get all Rows elements\nvar people = Row.all;\n\n// Get a random person\nvar p = people.random();\n\n// Check the gender of p\n// Prints 'Male' or 'Female'\np.gender.println();\n\n// Get the emails of people that like Horror movies so we can let them know a new movie is out.\n// Prints 'Sequence {rdwyr0@parallels.com, mmacer2@sogou.com, rsobieski5@usatoday.com, rvarrand@jugem.jp}'\npeople.select(p | p.movies == 'Horror').collect(p | p.email).println();\n\n// Get all males and females that like Thrillers and set up dates\n// Prints\n//    Olvan and Cosetta is a match made in heaven!\n//    Olvan and Lissa is a match made in heaven!\nvar mt = people.select(p | p.movies == 'Thriller' and p.gender == 'Male');\nvar ft = people.select(p | p.movies == 'Thriller' and p.gender == 'Female');\nfor (m in mt) {\n  for (f in ft) {\n    (m.first_name + \" and \" + f.first_name + \" is a match made in heaven!\").println();\n  }\n}</code></pre>"},{"location":"doc/articles/csv-emc/#header-full-with-varargs-csv-model","title":"Header-full with Varargs CSV Model","text":"<p>Last, we have a CSV model with some vararg information, is the same as before, but in this case persons are allowed to have multiple movies. We have also added a <code>quote</code> field that shows the quote character in action.</p> <pre><code>id,first_name,last_name,email,gender,job,credit_card,quote,movies\n604-78-8459,Ricoriki,Dwyr,rdwyr0@parallels.com,Male,VP Quality Control,,Duis at velit eu est congue elementum.,Horror\n272-41-1349,Norry,Halpin,nhalpin1@slashdot.org,Female,Legal Assistant,,Aenean sit amet justo. Morbi ut odio.,Drama,Film-Noir,Thriller\n844-07-0023,Matteo,Macer,mmacer2@sogou.com,Male,Tax Accountant,3542981651057648,In hac habitasse platea dictumst.,Horror,Mystery,Thriller\n429-41-4964,Kattie,Fysh,kfysh3@angelfire.com,Female,Senior Financial Analyst,,Suspendisse potenti. In eleifend quam a odio.,Comedy\n378-90-9530,Link,Proffitt,lproffitt4@cloudflare.com,Male,Paralegal,,Suspendisse accumsan tortor quis turpis. Sed ante.,Drama\n811-26-0387,Rafferty,Sobieski,rsobieski5@usatoday.com,Male,Physical Therapy Assistant,5602242765074843,\"Nulla neque libero, convallis eget, eleifend luctus, ultricies eu, nibh. Quisque id justo sit amet sapien dignissim vestibulum.\",Horror\n386-53-1139,Ernestine,Kringe,ekringe6@gov.uk,Female,Software Consultant,3531096662484096,Nulla justo. Aliquam quis turpis eget elit sodales scelerisque.,Drama\n850-05-5333,Flossy,Mobberley,fmobberley7@msn.com,Female,Chief Design Engineer,3558038696922012,Nulla tempus.,Comedy,Romance\n605-52-9809,Tull,Ingerith,tingerith8@surveymonkey.com,Male,VP Quality Control,,\"Morbi vestibulum, velit id pretium iaculis, diam erat fermentum justo, nec condimentum neque sapien placerat ante. Nulla justo.\",Drama\n580-79-7291,Derry,Laurisch,dlaurisch9@taobao.com,Male,Software Test Engineer I,,Praesent blandit lacinia erat. Vestibulum sed magna at nunc commodo placerat.,Drama,War\n676-89-8860,Cosetta,Vlasov,cvlasova@livejournal.com,Female,Nurse Practicioner,,In hac habitasse platea dictumst.,Crime,Film-Noir,Thriller\n748-10-2370,Lissa,Stanger,lstangerb@tmall.com,Female,Analyst Programmer,,Pellentesque at nulla.,Action,Adventure,Thriller\n164-18-3409,Giffie,Boards,gboardsc@gmpg.org,Male,Graphic Designer,3575314620284632,\"Morbi vel lectus in quam fringilla rhoncus. Mauris enim leo, rhoncus sed, vestibulum sit amet, cursus id, turpis.\",Comedy\n212-06-7778,Rabbi,Varran,rvarrand@jugem.jp,Male,GIS Technical Architect,3551249058791476,Suspendisse potenti.,Horror\n628-02-3617,Olvan,Alabone,oalabonee@archive.org,Male,Help Desk Technician,,Pellentesque viverra pede ac diam. Cras pellentesque volutpat dui.,Action,Adventure,Sci-Fi,Thriller\n318-48-3006,Constantino,Eyckelbeck,ceyckelbeckf@histats.com,Male,Recruiter,564182300132483644,In hac habitasse platea dictumst. Maecenas ut massa quis augue luctus tincidunt.,War\n122-74-6759,Nickolas,Collard,ncollardg@dot.gov,Male,Web Designer IV,,Praesent blandit lacinia erat. Vestibulum sed magna at nunc commodo placerat.,Drama\n309-57-3090,Chere,Hurry,churryh@huffingtonpost.com,Female,Tax Accountant,,\"In tempor, turpis nec euismod scelerisque, quam turpis adipiscing lorem, vitae mattis nibh ligula nec sem.\",Drama,Fantasy,Mystery\n833-32-9040,Mattie,Hamon,mhamoni@auda.org.au,Male,Structural Engineer,,Duis at velit eu est congue elementum. In hac habitasse platea dictumst.,Drama\n101-82-2564,Hew,Goble,hgoblej@ocn.ne.jp,Male,VP Accounting,,Etiam pretium iaculis justo.,Comedy\n</code></pre> <pre><code>// Get all Rows elements\nvar people = Row.all;\n\n// Random thoughts\nfor (p in people) {\n  if (p.gender == \"Female\" and p.movies.includes(\"Thriller\")) {\n    (p.first_name + \" screams '\" + p.quote + \"' when watching a Thriller. She is afraid of being a \" + p.job + \".\").println();\n  }\n  else if (p.gender == \"Male\" and p.movies.includes(\"Drama\")) {\n    (p.first_name + \" sighs, but blames '\" + p.quote + \"' for the tear in his eye. Being a \" + p.job + \" will never be the same.\").println();\n  }\n}\n\n// Output\n//Norry screams 'Aenean sit amet justo. Morbi ut odio.' when watching a Thriller. She is afraid of being a Legal Assistant.\n//Link sighs, but blames 'Suspendisse accumsan tortor quis turpis. Sed ante.' for the tear in his eye. Being a Paralegal will never be the same.\n//Tull sighs, but blames 'Morbi vestibulum, velit id pretium iaculis, diam erat fermentum justo, nec condimentum neque sapien placerat ante. Nulla justo.' for the tear in his eye. Being a VP Quality Control will never be the same.\n//Derry sighs, but blames 'Praesent blandit lacinia erat. Vestibulum sed magna at nunc commodo placerat.' for the tear in his eye. Being a Software Test Engineer I will never be the same.\n//Cosetta screams 'In hac habitasse platea dictumst.' when watching a Thriller. She is afraid of being a Nurse Practicioner.\n//Lissa screams 'Pellentesque at nulla.' when watching a Thriller. She is afraid of being a Analyst Programmer.\n//Nickolas sighs, but blames 'Praesent blandit lacinia erat. Vestibulum sed magna at nunc commodo placerat.' for the tear in his eye. Being a Web Designer IV will never be the same.\n//Mattie sighs, but blames 'Duis at velit eu est congue elementum. In hac habitasse platea dictumst.' for the tear in his eye. Being a Structural Engineer will never be the same.</code></pre>"},{"location":"doc/articles/csv-emc/#queryingmodifying-csv-documents-in-eol","title":"Querying/modifying CSV documents in EOL","text":"<p>The CSV driver support direct query and modification of attribute values:</p> <pre><code>// Get all Rows elements\nvar people = Row.all;\n\n// Get a random person\nvar p = people.random();\np.name.println();\n\n// Change the name\np.name = \"Maria Antonieta\"\np.name.println();</code></pre>"},{"location":"doc/articles/csv-emc/#how-do-i-create-an-element","title":"How do I create an element?","text":"<p>You can use the <code>new</code> operator for this, and remember that all CSV elements are rows! New Rows will be added at the end of the file when persisting the changes.</p> <pre><code>// Check how many entries are in the model\n// Prints '20'\nRow.all.size().println();\n\n// Creates a new book element\nvar b = new Row;\n\n// Check again\n// Prints '21'\nRow.all.size().println();</code></pre>"},{"location":"doc/articles/csv-emc/#loading-an-csv-document-in-your-ant-buildfile","title":"Loading an CSV document in your ANT buildfile","text":"<p>The following ANT build file demonstrates how you can use ANT to load/store and process CSV documents with Epsilon.</p> <pre><code>&lt;project default=\"main\"&gt;\n&lt;target name=\"main\"&gt;\n\n&lt;epsilon.csv.loadModel name=\"people\" file=\"people.csv\"\nread=\"true\" store=\"false\", knownHeaders=\"true\"/&gt;\n&lt;/epsilon.csv.loadModel&gt;\n\n&lt;epsilon.eol src=\"my.eol\"&gt;\n&lt;model ref=\"people\"/&gt;\n&lt;/epsilon.eol&gt;\n\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"doc/articles/csv-emc/#loading-an-csv-document-through-java-code","title":"Loading an CSV document through Java code","text":"<p>The following excerpt demonstrates using CSV models using Epsilon\\'s Java API.</p> <pre><code>EolModule module = new EolModule();\nmodule.parse(new File(\"...\"));\n\nCsvModel model = new CsvModel();\nmodel.setName(\"M\");\nmodel.setFile(new File(\"...\"));\nchar fieldSeparator = ',';\nmodel.setFieldSeparator(fieldSeparator);\nmodel.setKnownHeaders(false);\nmodel.setVarargsHeaders(false);\n\nmodule.getContext().getModelRepository().addModel(model);\nmodule.getContext().setModule(module);\nmodule.execute();\n</code></pre>"},{"location":"doc/articles/dev-setup/","title":"Eclipse Setup for Epsilon Developers","text":"<p>If you are a contributor to Epsilon (or you want to build on top of it), and don't already have Eclipse installed or the repository cloned, you can easily set this up automatically in a few clicks.</p> <p>Head to the Downloads page, download the installer for your platform and launch it.</p> <p></p> <p>Then switch to Advanced Mode.</p> <p></p> <p>Select \"Eclipse IDE for Java Developers\" in the Product page and then Next.</p> <p></p> <p>On the Projects page, look for Epsilon and select it, then Next.</p> <p></p> <p>You can customise variables to suit, such as where Eclipse will be installed and the protocol for cloning the repositories. The defaults should be fine.</p> <p></p> <p>Keep going with Next and then Finish. If all went to plan, then you should have a local copy of the main Epsilon repository and the website, with projects imported into Eclipse. You may need to wait for setup tasks to finish when first launching Eclipse. This can also be manually triggered from the Help -&gt; Perform Setup Tasks menu in Eclipse.</p> <p>If you encounter any issues, please let us know via the mailing list or forum.</p>"},{"location":"doc/articles/developing-a-new-emc-driver/","title":"Developing a new EMC Driver","text":"<p>This article demonstrates the implementation of \"drivers\" for Epsilon's Model Connectivity layer.</p>"},{"location":"doc/articles/developing-a-new-emc-driver/#yaml-driver","title":"YAML Driver","text":"<p>The following training session recording and deck of slides demonstrate the implementation of Epsilon's YAML driver. The complete source-code is located in Epsilon's Git repository.</p>"},{"location":"doc/articles/developing-a-new-emc-driver/#csv-pro-driver","title":"CSV Pro Driver","text":"<p>The slides below demonstrate the implementation of an alternative driver for CSV files, located under the <code>examples</code> folder of Epsilon's repository.</p>"},{"location":"doc/articles/developing-a-new-emc-driver/#filesystem-driver","title":"Filesystem Driver","text":"<p>This is a minimal toy driver where filesystem folders represent types and property files contained in them represent model elements that are their instances. Below is the main class of the driver and the full source code in Epsilon's repository.</p> FilesystemModel.java <pre><code>/*********************************************************************\n* Copyright (c) 2008 The University of York.\n*\n* This program and the accompanying materials are made\n* available under the terms of the Eclipse Public License 2.0\n* which is available at https://www.eclipse.org/legal/epl-2.0/\n*\n* SPDX-License-Identifier: EPL-2.0\n**********************************************************************/\npackage org.eclipse.epsilon.emc.filesystem;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.eclipse.epsilon.eol.exceptions.EolRuntimeException;\nimport org.eclipse.epsilon.eol.exceptions.models.EolEnumerationValueNotFoundException;\nimport org.eclipse.epsilon.eol.exceptions.models.EolModelElementTypeNotFoundException;\nimport org.eclipse.epsilon.eol.exceptions.models.EolModelLoadingException;\nimport org.eclipse.epsilon.eol.exceptions.models.EolNotInstantiableModelElementTypeException;\nimport org.eclipse.epsilon.eol.execute.introspection.IPropertyGetter;\nimport org.eclipse.epsilon.eol.execute.introspection.IPropertySetter;\nimport org.eclipse.epsilon.eol.models.Model;\n\n\npublic class FilesystemModel extends Model {\n\n// Map of directories -&gt; files they contain\nprotected Map&lt;File, List&lt;File&gt;&gt; cache = new HashMap&lt;&gt;();\n\npublic FilesystemModel(File root) {\npopulateCache(root, cache);\n}\n\n@Override\npublic boolean hasType(String type) {\nreturn directoryForName(type) != null;\n}\n\n@Override\npublic Collection&lt;?&gt; getAllOfKind(String type)\nthrows EolModelElementTypeNotFoundException {\nreturn cache.get(directoryForName(type));\n}\n\n@Override\npublic boolean owns(Object instance) {\nfor (File directory : cache.keySet()) {\nif (cache.get(directory).contains(instance)) {\nreturn true;\n}\n}\nreturn false;\n}\n\n@Override\npublic IPropertyGetter getPropertyGetter() {\nreturn new FilesystemModelPropertyGetter();\n}\n\n@Override\npublic IPropertySetter getPropertySetter() {\nreturn new FilesystemModelPropertySetter();\n}\n\n@Override\npublic Collection&lt;?&gt; getAllOfType(String type)\nthrows EolModelElementTypeNotFoundException {\n\nreturn cache.get(directoryForName(type));\n}\n\n//TODO: Implement\n\n@Override\npublic void load() throws EolModelLoadingException {\n\n}\n\n@Override\npublic Object getEnumerationValue(String enumeration, String label)\nthrows EolEnumerationValueNotFoundException {\nreturn null;\n}\n\n@Override\npublic Collection&lt;?&gt; allContents() {\nreturn null;\n}\n\n@Override\npublic String getTypeNameOf(Object instance) {\nreturn null;\n}\n\n@Override\npublic Object createInstance(String type)\nthrows EolModelElementTypeNotFoundException,\nEolNotInstantiableModelElementTypeException {\nreturn null;\n}\n\n@Override\npublic Object getElementById(String id) {\nreturn null;\n}\n\n@Override\npublic String getElementId(Object instance) {\nreturn null;\n}\n\n@Override\npublic void setElementId(Object instance, String newId) {\n\n}\n\n@Override\npublic void deleteElement(Object instance) throws EolRuntimeException {\n\n}\n\n@Override\npublic boolean isInstantiable(String type) {\nreturn false;\n}\n\n@Override\npublic boolean store(String location) {\nreturn false;\n}\n\n@Override\npublic boolean store() {\nreturn false;\n}\n\nprotected File directoryForName(String name) {\nfor (File directory : cache.keySet()) {\nif (directory.getName().equals(name)) {\nreturn directory;\n}\n}\nreturn null;\n}\n\nprotected void populateCache(File file, Map&lt;File, List&lt;File&gt;&gt; cache) {\n\nif (file.isDirectory()) {\nArrayList&lt;File&gt; files = new ArrayList&lt;&gt;();\nfor (File child : file.listFiles()) {\nif (child.isFile()) {\nfiles.add(child);\n}\nelse {\npopulateCache(child, cache);\n}\n}\ncache.put(file, files);\n}\n}\n\n}\n</code></pre>"},{"location":"doc/articles/developing-a-new-language/","title":"Developing a new Epsilon Language","text":"<p>The following decks of slides demonstrate the implementation of two minimal model management languages (and their supporting Eclipse-based development tools) on top of Epsilon: one using annotations (TestLang - with fewer than 200 lines of code), and one using grammar extension (EDL - with fewer than 300 lines of code). All the source-code for the two languages is located in the Epsilon Git repository (see details in the slides).</p>"},{"location":"doc/articles/developing-a-new-language/#annotations-testlang","title":"Annotations: TestLang","text":""},{"location":"doc/articles/developing-a-new-language/#grammar-extension-epsilon-demo-language-edl","title":"Grammar Extension: Epsilon Demo Language (EDL)","text":""},{"location":"doc/articles/development-principles/","title":"Epsilon Development Principles","text":"<p>This article describes the guiding principles that the committers of Epsilon follow.</p> <p>In-keeping with agile development principles, we don't use a strict/heavy-weight development process. Each member of the development team is free to use quite different approaches to software development. However, we aim to follow the following principles to ensure that there is a basic level of consistency across the Epsilon platform and its development.</p>"},{"location":"doc/articles/development-principles/#general","title":"General","text":"<ol> <li>Be mindful of different use cases: design, implementation and evolution of the platform respects that Epsilon can be used in different environments (from Eclipse or stand-alone) and on different operating systems (Windows, Linux, Mac OS); and that Epsilon programs can be invoked in different manners (Eclipse launch configurations, Ant tasks, programmatically).</li> <li>Maintain backwards-compatibility: the APIs exposed by Epsilon should be stable. Changes should not break client code. We use deprecation to warn users that an API has changed, and might be changed in a breaking manner in a future version of Epsilon.</li> </ol>"},{"location":"doc/articles/development-principles/#source-code","title":"Source code","text":"<ol> <li>Collectively own the code: all of the code is owned by the entire team, and anybody can make changes anywhere. Often, we work together on changes to the core of the platform, or to languages that a particular committer has developed initially (e.g., we might work closely with Antonio on a change to EUnit, because Antonio has done most of the recent work on EUnit).</li> <li>Collaborate on design: although we rarely practice \"live\" pair programming, we do share patches and discuss important design decisions internally.</li> <li>Adhere to code conventions<ul> <li>We do not place opening brackets on their own line.</li> <li>We always use braces for the bodies of <code>if</code>/<code>while</code>/<code>for</code> statements, unless it's a single statement that can be placed on the same line.</li> <li>Also, <code>else if</code> and <code>else</code> statements are not placed in the same line as the closing brace of the previous block, but on the next one.</li> <li>Avoid printing the stack traces of caught exceptions. When users run Epsilon from Eclipse they won't see these stack traces while and when they use Epsilon as a library, the stack traces will pollute the application's output. If you can handle the exception meaningfully in the <code>catch</code> block, then do it and don't print its stack trace, otherwise throw the exception for the caller to handle.</li> </ul> </li> </ol> <pre><code>// Not OK\nif (true)\n{\nreturn false;\n}\n\n// OK\nif (true) {\nreturn false;\n}\n\n// Not OK\nif (true)\nreturn false;\n\n// OK\nif (true) return false;\n\n// Not OK\nif (something) {\ndo something;\n} else if (other thing) {\ndo other thing;\n} else {\ndo alternative thing;\n}\n\n// OK\nif (something) {\ndo something;\n}\nelse if (other thing) {\ndo other thing;\n}\nelse {\ndo alternative thing;\n}\n\n// Not OK\ntry {\nsomethingDangerous();\n}\ncatch (Exception ex) {\nex.printStackTrace();\n}\n</code></pre>"},{"location":"doc/articles/development-principles/#testing","title":"Testing","text":"<ol> <li>Favour automated testing: to provide some assurance that we are shipping working code, we include automated tests along with feature code.</li> <li>Favour testing over testing-first: although we appreciate the benefits of test-first and test-driven development, we do not always develop tests first, often preferring peer review to make design decisions.</li> <li>Everyone uses the same testing frameworks: currently we favour JUnit 4 and Mockito for testing and mocking, respectively. Older code might still use other libraries (e.g. JUnit 3 and JMock), and we aim to replace these when we encounter them.</li> </ol>"},{"location":"doc/articles/development-principles/#bugfeature-tracking","title":"Bug/Feature Tracking","text":"<p>Trace changes using GitHub Issues: we use Github Issues to document and discuss design and implementation changes. We often raise our own issues. We use issue numbers in commit messages to maintain trace links between the code and discussions about the code.</p>"},{"location":"doc/articles/development-principles/#source-code-management","title":"Source Code Management","text":"<ol> <li>Describe commits with meaningful messages: to ensure that the history of the code can be understood by every member of the team, we endeavour to make our commit messages understandable and traceable. Metadata is often include in commit messages, for example: \"[EOL] Fixes bug #123456, which prevented the creation of widgets.\"</li> <li>Avoid large commits: to ensure that the history of the code can be understood by every member of the team, we favour breaking large commits into smaller consecutive commits.</li> </ol>"},{"location":"doc/articles/development-principles/#technical-support","title":"Technical Support","text":"<ol> <li>No forum post goes unanswered: to maintain and foster the community around Epsilon, we answer every question on the user forum.</li> <li>Encourage users to produce minimal examples: if we need to reproduce a user's issue, we will often ask for a minimal example to aid in debugging. We have found this to be effective because it allows us to focus most of our time on fixing issues, and because users sometimes discover the solution to their issue while producing the minimal example.</li> </ol>"},{"location":"doc/articles/egl-invoke-egl/","title":"Re-using EGL templates","text":"<p>Sometimes it may be handy to send the output of one EGL template into another EGL template. This is a great idea because it will make your templates more modular, cohesive and lead to less code overall. For example, suppose you've been generating an XML file for each Book in your model. Hence, you have a Book2XML.egl template with the following contents:</p> <pre><code>&lt;book&gt;\n  &lt;title&gt;[%=title%]&lt;/title&gt;\n  &lt;isbn&gt;[%=isbn%]&lt;/isbn&gt;\n  &lt;pages&gt;[%=pages.asString()%]&lt;/pages&gt;\n  &lt;authors&gt;\n  [% for (author in authors) {%]\n    &lt;author name=\"[%=author.name%]\"/&gt;\n  [%}%]\n  &lt;/authors&gt;\n&lt;/book&gt;</code></pre> <p>Suppose that now you also want to generate a single XML for each Library; where a Library is a collection of Books. Instead of duplicating the code in Book2XML.egl, you can re-use it by calling it from Library2XML.egl, like so:</p> <pre><code>&lt;library id=[%=lib.id%] name=\"[%=lib.name%]\"&gt;\n[% for (book in lib.books) {\n  var bookTemplate : Template = TemplateFactory.load(\"/path/to/Book2XML.egl\");\n  bookTemplate.populate(\"book\", book);\n  bookTemplate.populate(\"title\", book.title);\n  bookTemplate.populate(\"isbn\", book.isbn);\n  bookTemplate.populate(\"pages\", book.pages);\n  bookTemplate.populate(\"authors\", book.authors);\n  %]\n\n  [%=bookTemplate.process()%]\n[%}%]</code></pre> <p>As with EGX, you can pass parameters to the invoked template using the \"populate\" operation, where the first parameter is the variable name (that the invoked template will see) and the second parameter is the value.</p>"},{"location":"doc/articles/egl-server-side/","title":"Using EGL as a server-side scripting language in Tomcat","text":"<p>The original purpose of EGL was to enable batch generation of source code and other textual artefacts from EMF models. However, since there is no hard binding between the language and the file system, it is also possible to use EGL in other contexts.</p> <p>In this article, we demonstrate using EGL as a server-side scripting language in Tomcat, to produce web pages from EMF models on the fly.</p>"},{"location":"doc/articles/egl-server-side/#setup","title":"Setup","text":"<ul> <li>Download a fresh copy of Tomcat 6.0 here and extract it</li> <li>Download egl-servlet-full.zip</li> <li>Extract all .jar files from the zip into the <code>lib</code> folder of Tomcat</li> <li>Open <code>web.xml</code> in the <code>conf</code> directory of Tomcat and add the following snippet</li> </ul> <pre><code>&lt;servlet&gt;\n&lt;servlet-name&gt;egl&lt;/servlet-name&gt;\n&lt;servlet-class&gt;\norg.eclipse.epsilon.egl.servlet.EglServlet\n  &lt;/servlet-class&gt;\n&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&lt;/servlet&gt;\n&lt;servlet-mapping&gt;\n&lt;servlet-name&gt;egl&lt;/servlet-name&gt;\n&lt;url-pattern&gt;*.egl&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre> <ul> <li>Make sure that there is an environment variable called <code>JRE_HOME</code> and it's pointing to your JRE installation directory (the root, not the <code>bin</code>). In Windows, you can create this variable from <code>System Properties</code> \u2192 <code>Advanced</code> \u2192 <code>Environment Variables</code> \u2192 <code>System Variables</code> \u2192 <code>New...</code></li> </ul>"},{"location":"doc/articles/egl-server-side/#create-a-hello-world-web-application","title":"Create a Hello World web application","text":"<p>To create a hello world web application and test your installation, you need to go through the following steps:</p> <ul> <li> <p>Go to the <code>webapps</code> folder and create a new directory named <code>helloworld</code></p> </li> <li> <p>Inside <code>helloworld</code>, create a new file called <code>index.egl</code> and add to it the following code</p> </li> </ul> <pre><code>[%=\"Hello World\"%]</code></pre> <ul> <li>Start Tomcat using <code>bin/startup.bat</code> (or <code>startup.sh</code> in Linux/MacOS)</li> <li>Open your browser and go to http://localhost:8080/helloworld/index.egl</li> <li>A web-page with the text <code>Hello World</code> should appear. If not, please make sure you've followed all the steps above and if it still doesn't work, please drop by the forum and we'll be happy to help.</li> </ul>"},{"location":"doc/articles/egl-server-side/#accessing-parameters-from-the-url","title":"Accessing parameters from the URL","text":"<p>To access parameters from the URL (or fields of a submitted form) you can use the <code>request.getParameter('parameter-name')</code> method. For example, by modifying the source code of <code>index.egl</code> to the following</p> <pre><code>[%=\"Hello \"+request.getParameter(\"visitor\")%]</code></pre> <p>and navigating to http://localhost:8080/helloworld/index.egl?visitor=John, you should get a page reading <code>Hello John</code> as a result.</p>"},{"location":"doc/articles/egl-server-side/#other-built-in-objects","title":"Other built-in objects","text":"<p>EGL provides the following built-in objects which (should) function exactly like they do in JSP</p> <ul> <li><code>request</code></li> <li><code>response</code></li> <li><code>config</code></li> <li><code>application</code></li> <li><code>session</code></li> </ul> <p>You may want to have a look here for a tutorial that explains their functionality.</p>"},{"location":"doc/articles/egl-server-side/#caching","title":"Caching","text":"<p>EGL provides the built-in <code>cache</code> object to facilitate two types of caching. Page caching can be used to ensure that repeated requests to the same URL do not result in the execution of EGL templates. Fragment caching can be used to share the text generated by a template between requests for different URLs.</p> <p>For example, the following code is used to ensure that repeated requests for pages matching the regular expression <code>index.*</code> are served from the page cache:</p> <pre><code>[% cache.pages(\"index.*\"); %]</code></pre> <p>The page cache can be expired programmatically, as shown below, or by restarting the Tomcat server.</p> <pre><code>[% cache.expirePages(\"index.*\"); %]</code></pre> <p>In addition to page caching, EGL supports fragment caching which allows the contents of a sub-template to be cached. For example, the following code processes <code>sidebar.egl</code> only the first time that the template is executed:</p> <pre><code>[% var sidebarTemplate = TemplateFactory.load(\"Sidebar.egl\"); %]\n[%=cache.fragment(sidebarTemplate) %]</code></pre> <p>Note that the <code>fragment</code> method should be used in a dynamic output section. Like pages, fragments can be expired programmatically (or by restarting the Tomcat server):</p> <pre><code>[% cache.expireFragment(sidebarTemplate); %]</code></pre> <p>A simple caching strategy is to populate the page and fragment caches from your main EGL templates, and to provide a <code>ClearCache.egl</code> template in a sub-directory that only administrators that can access.</p>"},{"location":"doc/articles/egl-server-side/#loading-emf-models-in-egl-pages","title":"Loading EMF models in EGL pages","text":"<p>The main motivation for turning EGL into a server-side scripting language is its ability to work well with EMF models. EGL provides the <code>modelManager</code> built-in object to let you load EMF models that reside in the web application.</p> <p>To experiment with <code>modelManager</code>, download the Graph.ecore and Ecore.ecore models and place them in your helloworld directory. Then, change your <code>index.egl</code> to look like this</p> <pre><code>[%\nmodelManager.registerMetamodel(\"Ecore.ecore\");\nmodelManager.loadModel(\"Sample\", \"Graph.ecore\", \"http://www.eclipse.org/emf/2002/Ecore\");\n%]\n\nThe metamodel has [%=EClass.all.size()%] classes</code></pre> <p>Refresh the page in your browser and it should now read:</p> <pre><code>The metamodel has 3 classes\n</code></pre>"},{"location":"doc/articles/egl-server-side/#the-model-manager","title":"The Model Manager","text":"<p>The <code>modelManager</code> built-in object provides the following methods:</p> <ul> <li><code>registerMetamodel(file : String)</code>: Registers the file (should be an Ecore metamodel) in <code>EPackage.Registry.INSTANCE</code></li> <li><code>loadModel(name : String, modelFile : String, metamodelURI : String)</code>: Loads the model stored in <code>modelFile</code> using the registered metamodel <code>metamodelURI</code>.</li> <li><code>loadModelByFile(name : String, modelFile : String, metamodelFile : String)</code>: Loads the model stored in <code>modelFile</code> using the metamodel in <code>metamodelFile</code>.</li> <li><code>loadModel(name : String, aliases : String, modelFile : String, metamodel : String, expand : Boolean, metamodelIsFilebased : Boolean)</code>: Provides more parameters for loading models.</li> <li><code>uncacheModel(modelFile : String)</code>: Removes the <code>modelFile</code> from the cache (next call to <code>loadModel()</code> will actually reload it)</li> <li><code>clear()</code>: Clears cached models and metamodels</li> </ul>"},{"location":"doc/articles/egl-server-side/#sharing-models-between-templates","title":"Sharing models between templates","text":"<p>Currently, each model is only loaded once (the first time the <code>loadModel()</code> or <code>loadModelByFile()</code> is called). If multiple pages need to access the same model, add the model loading logic in an operation in a separate <code>models.eol</code> file:</p> <pre><code>operation loadModels() {\n  modelManager.registerMetamodel(\"Ecore.ecore\");\n  modelManager.loadModel(\"Sample\", \"Graph.ecore\", \"http://www.eclipse.org/emf/2002/Ecore\");\n}</code></pre> <p>and then import and call it from each one of your pages:</p> <pre><code>[%\nimport \"models.eol\";\nloadModels();\n%]\n\n// Page code here</code></pre>"},{"location":"doc/articles/egl-server-side/#running-egl-on-google-app-engine","title":"Running EGL on Google App Engine","text":"<p>By default App Engine will treat EGL files as static content and serve their source code instead of executing them. To work around this, add the following snippet under the root element of the <code>appengine-web.xml</code> configuration file of your App Engine application.</p> <pre><code>&lt;static-files&gt;\n&lt;exclude path=\"*.egl\"/&gt;\n&lt;/static-files&gt;\n</code></pre>"},{"location":"doc/articles/egl-server-side/#working-with-big-models","title":"Working with big models","text":"<p>If you encounter a Java <code>OutOfMemoryError</code> while querying a big model you'll need to start Tomcat with more memory than the default 256 MB. To do this, go to <code>bin/catalina.bat</code> (on Windows -- if you're on Linux you should modify <code>catalina.sh</code> accordingly) and change line</p> <pre><code>set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER%\n</code></pre> <p>to</p> <pre><code>set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Xms1024m -Xmx1024m -XX:MaxPermSize=128m\n</code></pre> <p>If you keep getting out of memory errors, you may find PSI Probe useful for figuring out what's going wrong.</p>"},{"location":"doc/articles/egl-template-operations/","title":"Using template operations in EGL","text":"<p>Template operations provide a way to re-use small fragments of EGL code. This article shows how to write EGL template operations and discusses when you might want to use them.</p> <p>Suppose we are writing a code generator for plain-old Java objects, and we have the following EGL code (which assumes the presence of a class object):</p> <pre><code>class [%=class.name%] {\n[% for (feature in class.features) { %]\n  /**\n   * Gets the value of [%=feature.firstToLowerCase()%]\n   */\n   public [%=feature.type%] get[%=feature%]() {\n      return [%=feature.firstToLowerCase()%];\n   }\n\n  /**\n   * Sets the value of [%=feature.firstToLowerCase()%]\n   */\n   public void set[%=feature%]([%=feature.type%] [%=feature.firstToLowerCase()%]) {\n      this.[%=feature.firstToLowerCase()%] = [%=feature.firstToLowerCase()%];\n   }\n[% } %]\n}</code></pre> <p>While the above code will work, it has a couple of drawbacks. Firstly, the code to generate getters and setters cannot be re-used in other templates. Secondly, the template is arguably hard to read - the purpose of the loop's body is not immediately clear.</p> <p>Using EGL template operations, the above code becomes:</p> <pre><code>class [%=class.name%] {\n[% for (feature in class.features) { %]\n  [%=feature.getter()%]\n  [%=feature.setter()%]\n[% } %]\n}\n[%\n  @template\n  operation Feature getter() { %]\n    /**\n     * Gets the value of [%=self.firstToLowerCase()%]\n     */\n     public [%=self.type%] get[%=self%]() {\n        return [%=self.firstToLowerCase()%];\n     }\n  [% } %]\n\n  @template\n  operation Feature setter() { %]\n    /**\n     * Sets the value of [%=self.firstToLowerCase()%]\n     */\n     public void set[%=self%]([%=self.type%] [%=self.firstToLowerCase()%]) {\n        this.[%=self.firstToLowerCase()%] = [%=self.firstToLowerCase()%];\n     }\n   [% }\n%]</code></pre> <p>Notice that, in the body of the loop, we call the template operations, <code>getter</code> and <code>setter</code>, to generate the getter and setter methods for each feature. This makes the loop arguably easier to read, and the <code>getter</code> and <code>setter</code> operations can be re-used in other templates.</p> <p>Template operations are annotated with <code>@template</code> and can mix dynamic and static sections, just like the main part of an EGL template. Operations are defined on metamodel types (Feature in the code above), and may be called on any model element that instantiates that type. In the body of an operation, the keyword <code>self</code> is used to refer to the model element on which the operation has been called.</p>"},{"location":"doc/articles/egl-template-operations/#common-issues","title":"Common issues","text":"<p>Issue: my template operation produces no output.</p> <p>Resolution: ensure that the call to the template operation is placed in a dynamic output section (e.g. <code>[%=thing.op()%]</code>) rather than in a plain dynamic section (e.g. <code>[% thing.op(); %]</code>). Template operations return a value, which must then be emitted to the main template using a dynamic output section.</p> <p>Thanks to Mark Tippetts for reporting this issue via the Epsilon forum.</p>"},{"location":"doc/articles/egx-parameters/","title":"Co-ordinating EGL template execution with EGX","text":"<p>Suppose you're using Epsilon to make a compiler for a domain-specific language (DSL). Specifically, for every Library in the DSL, you want to generate a separate XML file with all of the properties of the Library and its Books. With EGX, you can parameterize your EGL templates to achieve this, like so:</p> <pre><code>pre {\n    var outDirLib : String = \"../libraries/\";\n    var extension : String = \".xml\";\n    var specialBook : String = \"Art of War\";\n    var bigLibThreshold : Integer = 9000;\n}\n\nrule Libraries transform lib : Library {\n    parameters : Map {\n        \"library\" = lib,\n        \"name\" = lib.name,\n        \"books\" = lib.books,\n        \"hasSpecialBook\" = lib.books.exists(book | book.title == specialBook),\n        \"isBigLibrary\" = lib.books.size() &gt; bigLibThreshold\n    }\n    template: \"/path/to/Lib2XML.egl\"\n    target: outDirLib+lib.name+extension\n}</code></pre> <p>In this example, the Lib2XML EGL template will be invoked for every Library instance in the model, and the output will be written to the file specified in the \"target\". The Lib2XML template will receive all of the parameters put in the \"params\" variable in the parameters block of the rule. The variable is a mapping from variable name (that the EGL template will use to refer to it) and variable value. For reference, the Lib2XML template is shown below.</p> <p>Note</p> <p>There is no limit on the number of rules you can declare in an EGX program.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;library id=[%=lib.id%] name=\"[%=name%]\" isBigLibrary=\"[%=isBigLibrary.asString()%]\"&gt;\n[% for (book in books) {%]\n    &lt;book&gt;\n        &lt;title&gt;[%=book.title%]&lt;/title&gt;\n        &lt;isbn&gt;[%=book.isbn%]&lt;/isbn&gt;\n        &lt;pages&gt;[%=book.pages.asString()%]&lt;/pages&gt;\n        &lt;authors&gt;\n        [% for (author in book.authors) {%]\n            &lt;author name=\"[%=author.name%]\"/&gt;\n        [%}%]\n        &lt;/authors&gt;\n    &lt;/book&gt;\n[%}%]\n&lt;/library&gt;</code></pre>"},{"location":"doc/articles/eol-interpreter-view/","title":"EOL Interpreter View","text":"<p>Acceleo provides an extensible interpreter view that can be used to evaluate queries on selections of model elements in EMF-based editors. Epsilon extends this view with support for writing and running Epsilon Object Language scripts. To show the view, click on <code>Window</code> \u2192 <code>Show View</code> \u2192 <code>Other</code> \u2192 <code>Interpreter</code>, and to switch to EOL, click on the respective button at the top-right of the view. More detailed instructions on using the different facilities offered by the interpreter view (e.g. variables, live evaluation) are provided here.</p> <p></p> <p>Info</p> <p>The EOL interpreter view is available in versions of Epsilon &gt;= 2.3.0</p>"},{"location":"doc/articles/eol-interpreter-view/#accessing-selected-model-elements-and-variables","title":"Accessing Selected Model Elements and Variables","text":"<p>Selected model elements in EMF-based editors can be accessed from the EOL script through the <code>self</code> variable. If multiple model elements are selected, then <code>self</code> will be a list containing all these elements, and if no model elements are selected, <code>self</code> will be <code>null</code>. Variables are accessible by name.</p>"},{"location":"doc/articles/eol-interpreter-view/#importing-external-operations","title":"Importing External Operations","text":"<p>You can import operations defined in EOL files in your workspace using an <code>import</code> statement with a <code>platform:/resource</code> URI, as shown below.</p> <pre><code>// bar() is defined in bar.eol under the bar project\nimport \"platform:/resource/bar/bar.eol\";\n\nreturn foo() + bar();\n\noperation foo() {\n    return \"foo\";\n}</code></pre>"},{"location":"doc/articles/eol-syntax-updates/","title":"EOL Syntax Updates","text":"<p>The following is a brief description of changes to the Epsilon Object Language's syntax in each release.</p>"},{"location":"doc/articles/eol-syntax-updates/#22","title":"2.2","text":"<ul> <li> <p><code>Tuple</code> type. Similar to a Map with String keys, but its properties can be     accessed like a regular object (using the <code>.</code> operator).</p> </li> <li> <p>Assign if null operator <code>?=</code> as convenient shorthand for <code>a = a ?: b</code>, that is: <code>a = a &lt;&gt; null ? a : b</code>.</p> </li> </ul>"},{"location":"doc/articles/eol-syntax-updates/#21","title":"2.1","text":"<ul> <li> <p>Elvis operator as a convenient     shorthand to use an alternative value if an expression is null.     <code>a ?: b</code> is a concise way of writing <code>a &lt;&gt; null ? a else b</code>.</p> </li> <li> <p>Null-safe navigation operator     to allow for easy chaining of feature calls without resorting to null checks.     For example, <code>null?.getClass()?.getName()</code> will return <code>null</code> without crashing.</p> </li> <li> <p><code>!=</code> can be used as an alias for <code>&lt;&gt;</code> (i.e. \"not equals\").</p> </li> </ul>"},{"location":"doc/articles/eol-syntax-updates/#20","title":"2.0","text":"<ul> <li>Ternary expressions, which can be used almost anywhere, not just in     assignments or returns. Syntax and semantics are identical to Java,     but you can also use the <code>else</code> keyword in place of the <code>:</code> if you     prefer.</li> <li>Native lambda expressions. You can use first-order operation syntax     or JavaScript-style <code>=&gt;</code> for invoking functional     interfaces.</li> <li>Removed old-style OCL comments (<code>-*</code> and <code>--</code>).</li> <li><code>--</code> can be used to decrement integers.</li> <li>Thread-safe collection types: <code>ConcurrentBag</code>, <code>ConcurrentMap</code> and     <code>ConcurrentSet</code>.</li> </ul>"},{"location":"doc/articles/eol-syntax-updates/#14","title":"1.4","text":"<ul> <li>Added support for postfix increment operator (i.e. <code>i++</code>) and for     composite assignment statements (i.e.     <code>a +=1; a -= 2; a *= 3; a /= 4;</code>)</li> </ul>"},{"location":"doc/articles/eol-syntax-updates/#091","title":"0.9.1","text":"<ul> <li>Added support for externally defined variables.</li> <li>Support for Map literal expressions (e.g.     <code>Map {key1 = value1, k2 = v2}</code>)</li> </ul>"},{"location":"doc/articles/eol-syntax-updates/#088","title":"0.8.8","text":"<p>In 0.8.8 we extended the syntax of EOL so that it looks and feels a bit more like Java. As the majority of Eclipse/EMF audience are Java programmers, this will hopefully make their (and our) lives a bit easier. Of course, all these changes also affect all languages built on top of EOL.</p> <p>More specifically, we have introduced:</p> <ul> <li>double quotes (<code>\" \"</code>) for string literals,</li> <li>backticks (` `) for reserved words,</li> <li>Java-like comments (<code>//</code> and <code>/**/</code>),</li> <li><code>==</code> as a comparison operator,</li> <li><code>=</code> as an assignment operator (in 0.8.7)</li> </ul> <p>All these changes (except for the double quotes which have now been replaced by ` `) are non-breaking: the old syntax (<code>''</code> for strings, <code>=</code> for comparison and <code>:=</code> for assignment still work). Below is an example demonstrating the new syntax:</p> <pre><code>/*\n This is a multi line comment\n*/\n// This is a single line comment\nvar i = 1;\nif (i == 1) {\n  \"Hello World\".println();\n}\n\ni = 2; // Assigns the value 2 to i\n\nvar `variable with spaces` = 3;\n`variable with spaces`.println(); // Prints 3</code></pre> <p>If you have suggestions for further Java-ifications of the EOL syntax, please post your comments to the Epsilon forum or add them to bug 292403.</p>"},{"location":"doc/articles/epackage-registry-view/","title":"The EMF EPackage Registry View","text":"<p>The EPackage registry (<code>EPackage.Registry.INSTANCE</code>) contains references to all registered Ecore EPackages in EMF. To visualise the contents of the registry, we have implemented the following EPackage Registry view. Using this view, one can browse through the EClasses contained in each registered EPackage, discover the super/sub types of each EClass, and navigate through its features and operations. The view provides options to show/hide derived features, operations, inherited features and opposite references, supports quick navigation from a feature to its type (double-click), and integrates with the Properties view.</p> <p></p> <p>To make this view visible go to Window \u2192 Show view \u2192 Other... and select EPackage Registry under the Epsilon category.</p> <p></p> <p>The view is populated and refreshed on demand. As such, when it first appears it is empty. To populate it with the registered EPackages, you need to click the <code>Refresh</code> button on the top right.</p>"},{"location":"doc/articles/epsilon-1.x/","title":"Working with versions of Epsilon prior to 2.0","text":"<p>In the old days before we embraced advancements in Eclipse provisioning technology (P2), to use Epsilon one needed to download an Eclipse distribution and manually install the pre-requisite plugins and features required to work with Epsilon.</p>"},{"location":"doc/articles/epsilon-1.x/#pre-packaged-distributions","title":"Pre-packaged distributions","text":"<p>If you wish to use an older version of Epsilon, the easiest and most compatible way is to download one of the ready-made distributions bundled from the archives, since they contain the selected version of Epsilon all its mandatory and optional dependencies. You will only need a Java Runtime Environment.</p> <p>Navigate to the directory with the desired version, and download the archive file appropriate for your platform and unzip it. If you are using Windows, please extract the download close to the root of a drive (e.g. C:) as the maximum path length on Windows may not exceed 255 characters by default.</p>"},{"location":"doc/articles/epsilon-1.x/#from-a-modeling-distribution","title":"From a Modeling Distribution","text":"<p>For a more up-to-date IDE, we recommend that users install the Eclipse Modeling Tools distribution and install Epsilon along with its (optional) dependencies (these are mainly for working with Eugenia) by adding the following list of update sites through Help \u2192 Install New Software...:</p> <ul> <li>Epsilon : https://download.eclipse.org/epsilon/updates/1.5 (substitute 1.5 for the desired version)</li> <li>Emfatic: https://download.eclipse.org/emfatic/update</li> <li>GMF Tooling: https://download.eclipse.org/modeling/gmp/gmf-tooling/updates/releases</li> <li>QVTo: https://download.eclipse.org/mmt/qvto/updates/releases/3.9.1</li> </ul>"},{"location":"doc/articles/epsilon-emf/","title":"Epsilon and EMF","text":"<p>Below are some frequently-asked questions related to querying and modifying EMF-based models with Epsilon.</p>"},{"location":"doc/articles/epsilon-emf/#what-is-the-difference-between-containment-and-non-containment-references-in-emf","title":"What is the difference between containment and non-containment references in EMF?","text":"<p>Briefly, a model element can belong to as most one containment reference at a time. Containment references also demonstrate a cascade-delete behaviour. For example, consider the following Ecore metamodel (captured in Emfatic).</p> <pre><code>package cars;\n\nclass Person {\n  ref Person[*] friends; //non-containment reference\n  val Car[*] cars; // containment reference\n}\n\nclass Car { }</code></pre> <p>Now consider the following EOL code which demonstrates the similarities/differences of containment and non-containment references.</p> <pre><code>// Set up a few model elements to play with\nvar c1 = new Car;\nvar c2 = new Car;\nvar p1 = new Person;\nvar p2 = new Person;\nvar p3 = new Person;\n\n// p1's car is c1 and p2's car is c2\np1.cars.add(c1);\np2.cars.add(c2);\n\n// p3 is a friend of both p1 and p2\np1.friends.add(p3);\np2.friends.add(p3);\n\np1.friends.println(); // prints {p3}\np2.friends.println(); // prints {p3}\n\n//add c2 to p1's cars\np1.cars.add(c2);\np1.cars.println(); // prints {c1, c2}\n\n// The following statement prints an empty set! \n// As discussed above, model elements can belong to at \n// most 1 containment reference. As such, by adding c2 to\n// the cars of p1, EMF removes it from the cars of p2\np2.cars.println();\n\n// Delete p1 from the model\ndelete p1;\n\nPerson.all.println(); // prints {p2, p3}\n\n// The following statement prints an empty set!\n// As discussed above, containment references demonstrate\n// a cascade-delete behaviour. As such, when we deleted p1,\n// all the model elements contained in its cars containment reference\n// were also deleted from the model. Note how the friends of p1 (p2 and p3)\n// were not deleted from the model, since they were referenced through a \n// non-containment reference (friends)\nCar.all.println();</code></pre>"},{"location":"doc/articles/epsilon-emf/#how-can-i-get-all-children-of-a-model-element","title":"How can I get all children of a model element?","text":"<p>Epsilon does not provide a built-in method for this but you can use EObject's <code>eContents()</code> method if you're working with EMF. To get all descendants of an element, something like the following should do the trick: <code>o.asSequence().closure(x | x.eContents())</code>. See https://www.eclipse.org/forums/index.php/t/855628/ for more details.</p>"},{"location":"doc/articles/epsilon-emf/#how-can-i-get-the-container-of-a-model-element","title":"How can I get the container of a model element?","text":"<p>Epsilon does not provide a built-in method for this but you can use EObject's <code>eContainer()</code> method if you're working with EMF.</p>"},{"location":"doc/articles/epsilon-emf/#how-can-i-use-an-existing-emf-resource-in-epsilon","title":"How can I use an existing EMF Resource in Epsilon?","text":"<p>To use an existing EMF Resource in your Epsilon program, you should wrap it as an InMemoryEmfModel first.</p>"},{"location":"doc/articles/epsilon-emf/#how-can-i-access-the-emf-resource-that-underpins-an-emf-model","title":"How can I access the EMF Resource that underpins an EMF model?","text":"<p>You can use the <code>getResource()</code> method of <code>AbstractEmfModel</code> for this.</p>"},{"location":"doc/articles/epsilon-emf/#how-can-i-use-custom-loadsave-options-for-my-emf-model","title":"How can I use custom load/save options for my EMF model?","text":"<p>You need to un-tick the \"Read on load\"/\"Store on disposal\" options in your model configuration dialog and use the underlying EMF resource's load/save methods directly from your EOL code. For example, to turn off the OPTION_DEFER_IDREF_RESOLUTION option, which is on by default in Epsilon's EMF driver and has been reported to slow down loading of models that use \"id\" attributes, you can use the following EOL statement.</p> <pre><code>M.resource.load(Map{\"DEFER_IDREF_RESOLUTION\" = false});\n</code></pre>"},{"location":"doc/articles/epsilon-emf/#how-do-i-load-an-ecore-metamodel","title":"How do I load an Ecore metamodel?","text":"<p>If you're developing a standalone application, before you can load an EMF model, you will need to put its metamodel (<code>EPackage</code>) in the global EMF EPackage registry, or in the local package registry of the model resource. The following snippet shows how you can parse an Ecore metamodel from a file (<code>my.ecore</code>) and put its root EPackage in the global EMF registry.</p> <pre><code>// Parse the metamodel file into an EMF resource\nResourceSet ecoreResourceSet = new ResourceSetImpl();\necoreResourceSet.getResourceFactoryRegistry().\ngetExtensionToFactoryMap().put(\"ecore\", new XMIResourceFactoryImpl());\necoreResourceSet.getPackageRegistry().\nput(EcorePackage.eINSTANCE.getNsURI(), EcorePackage.eINSTANCE); Resource ecoreResource = ecoreResourceSet.createResource(\nURI.createFileURI(new File(\"my.ecore\").getAbsolutePath()));\necoreResource.load(null);\n\n// Ecore files usually contain one EPackage\nEPackage ePackage = (EPackage) ecoreResource.getContents().get(0);\n// Put the EPackage in the global EMF EPackage registry\nEPackage.Registry.INSTANCE.put(ePackage.getNsURI(), ePackage);\n</code></pre>"},{"location":"doc/articles/epsilon-in-ecore/","title":"Using Epsilon for Ecore Validation, Setting and Invocation Delegation","text":"<p>Note</p> <p>This Feature is available in versions &gt;= 2.5.0</p> <p>EMF provides three delegation mechanisms that enable functionality not directly supported by EMF to be delegated to a technology that can support it.</p> <ul> <li>Validation Delegate supports checking additional invariants on an EClassifier</li> <li>Setting Delegate supports getting an initial or derived computed value for an EStructuralFeature</li> <li>Invocation Delegate supports the execution of a function defined by an EOperation</li> </ul> <p>Epsilon supports using EOL for setting and invocation delegation and EVL for validation delegation. Delegate registration and delegate implementation are added to the Ecore model via EAnnotations.</p>"},{"location":"doc/articles/epsilon-in-ecore/#delegate-registration","title":"Delegate Registration","text":"<p>The provided EOL/EVL implementations become active when the appropriate delegate functionality is registered for a given EPackage. In practice, all three delegations should be registered.</p>"},{"location":"doc/articles/epsilon-in-ecore/#setting-delegate","title":"Setting Delegate","text":"<p>The setting delegate is specified by adding an EAnnotation to the EPackage with the following values:</p> <pre><code>source = \"http://www.eclipse.org/emf/2002/Ecore\"\nkey = \"settingDelegates\"\nvalue = \"http://eclipse.dev/epsilon/ecore/EOL\"\n</code></pre> <p>Note</p> <p>When generating the java classes from your genmodel, remember to set the genmodel option <code>root-&gt;Model-&gt;'Feature Delegation'</code> to something other than <code>None</code> (the specific type depends on your needs).</p>"},{"location":"doc/articles/epsilon-in-ecore/#invocation-delegate","title":"Invocation Delegate","text":"<p>The invocation delegate is specified by an EPackage EAnnotation with:</p> <pre><code>source = \"http://www.eclipse.org/emf/2002/Ecore\"\nkey = \"invocationDelegates\"\nvalue = \"http://eclipse.dev/epsilon/ecore/EOL\"\n</code></pre> <p>The delegate value matches an org.eclipse.emf.ecore.invocation_delegate extension point usage in the org.eclipse.ocl.ecore plug-in that provides the delegate functionality. Multiple comma-separated delegates may be specified.</p> <p>Note</p> <p>When generating the java classes from your genmodel, remember to set the genmodel option <code>root-&gt;Model-&gt;'Operation Reflection'</code> to <code>true</code>. (From EMF 2.8 onwards, <code>true</code> is the default.)</p>"},{"location":"doc/articles/epsilon-in-ecore/#validation-delegate","title":"Validation Delegate","text":"<p>The validation delegate is specified by an EPackage EAnnotation with:</p> <pre><code>source = \"http://www.eclipse.org/emf/2002/Ecore\"\nkey = \"validationDelegates\"\nvalue = \"http://eclipse.dev/epsilon/ecore/EVL\"\n</code></pre>"},{"location":"doc/articles/epsilon-in-ecore/#eol-setting-delegation","title":"EOL Setting Delegation","text":"<p>A setting delegate is invoked to provide the derived value of an EStructuralFeature. Folowing the guidelines of the Eclipse Modeling Framework book, EOL Setting Delegation will only work for derived EStructuralFeature that are volatile, transient and non-changeable.</p> <p>Warning</p> <p>EStructuralFeatures using Setting Delegation for derived value calculation must belong to an EClass inside an EPacakge for which the Epsilon Setting Delegate has been registered.</p>"},{"location":"doc/articles/epsilon-in-ecore/#implementing-derived-features-with-eol","title":"Implementing Derived features with EOL","text":"<p>The setting delegate is provided by an EAnnotation on the EStructuralFeature:</p> <pre><code>source = \"http://eclipse.dev/epsilon/ecore/EOL\"\nkey = derivation\nvalue = EOL expression\n</code></pre> <p>The EOL expression is evaluated to provide the EStructuralFeature value with the containing EClassifier instance (EObject) assigned to the special variable <code>self</code>. The EOL expression must be a valid EOL expression (i.e., no syntax errors) and the runtime result type of the EOL expression must conform to the type of the EStructuralFeature.</p>"},{"location":"doc/articles/epsilon-in-ecore/#eol-invocation-delegation","title":"EOL Invocation Delegation","text":"<p>The invocation delegate is provided by an EAnnotation on the EOperation:</p> <pre><code>source = \"http://eclipse.dev/epsilon/ecore/EOL\"\nkey = body\nvalue = body EOL expression\n</code></pre> <p>The body EOL expression is evaluated to provide the EOperation value with the containing EClassifier  instance (EObject) assigned to the special variable <code>self</code> and one variable for each EParameters. The body EOL expression of the contraint must be a valid EOL operation body, i.e., no syntax errors, and have a <code>return</code> statement. The runtime result type of the return statement must be <code>boolean</code>.</p>"},{"location":"doc/articles/epsilon-in-ecore/#evl-validation-delegation","title":"EVL Validation Delegation","text":"<p>Validation delegation allows to specify contraints for an EClassifier and consists of two parts:</p> <ul> <li>List of constraints</li> <li>Constraint implementaiton</li> </ul> <p>Warning</p> <p>EClassifiers that provide EVL constraints, must be owned by an EPacakge for which the Epsilon Validation Delegate has been registered.</p>"},{"location":"doc/articles/epsilon-in-ecore/#specifying-constraints","title":"Specifying Constraints","text":"<p>All Ecore constraints must be listed in an EAnnotation on the EClassifier</p> <pre><code>source = http://www.eclipse.org/emf/2002/Ecore\nkey = constraints\nvalue = constraintName_1 constraintName_2 ... constraintName_n\n</code></pre>"},{"location":"doc/articles/epsilon-in-ecore/#implementing-constraints-with-evl","title":"Implementing Constraints with EVL","text":"<p>The validation delegate for each Ecore constraint is provided by either a further EAnnotation on the EClassifier or an EOperation in the EClassifier.</p>"},{"location":"doc/articles/epsilon-in-ecore/#via-eannotation","title":"Via EAnnotation","text":"<p>The EVL constraint body (check) is specified by an EAnnotation on the EClassifier</p> <pre><code>source = \"http://eclipse.dev/epsilon/ecore/EVL\"\nkey = \"constraintName_1\"\nvalue = EOL expression\n</code></pre> <p>The EOL expression is evaluated to validate the EClassifier instance (EObject) with the instance assigned to the special variable <code>self</code>. The EOL expression must be a valid EOL expression and the runtime result type of the EOL expression must be <code>boolean</code>.</p>"},{"location":"doc/articles/epsilon-in-ecore/#via-eoperation","title":"Via EOperation","text":"<p>The EVL constraint can be defined by adding an EOperation to the EClassifier with the following signature:</p> <p><code>EBoolean constraintName (DiagnosticChain diagnostics, EMap&lt;EJavaObject, EJavaObject&gt; context)</code></p> <p>The EVL constraint body (check) is specified by an EAnnotation on the EOperation</p> <pre><code>source = \"http://eclipse.dev/epsilon/ecore/EVL\"\nkey = \"body\"\nvalue = body EOL expression\n</code></pre> <p>The body EOL expression is evaluated to validate the EClassifier instance (EObject) with the instance assigned to the special variable <code>self</code>. The body EOL expression of the contraint must be a valid EOL operation body, i.e., no syntax errors, and have a <code>return</code> statement. The runtime result type of the return statement must be <code>boolean</code>.</p>"},{"location":"doc/articles/epsilon-in-ecore/#example","title":"Example","text":"<p>The following annotated EMF metamodel (expressed using Emfatic shows how to use the Epsilon delegates:</p> <p>First, we register the delegates in the EPacakge:</p> <pre><code>@Ecore(\n    validationDelegates=\"http://eclipse.dev/epsilon/ecore/EVL\",\n    invocationDelegates=\"http://eclipse.dev/epsilon/ecore/EOL\",\n    settingDelegates=\"http://eclipse.dev/epsilon/ecore/EOL\")\n@namespace(\n    uri=\"http://www.eclipse.org/OCL/examples/codegen/employee\",\n    prefix=\"emp\")\npackage employee;\n\nclass Company {\n    attr String name;\n    val Employee[*]#company employees;\n    val Department[*]#company departments;\n}\n...</code></pre> <p>For the Department EClass, we defined three constraints implemented via EAnnotations, and the feature directReports as derived:</p> <pre><code>...\n\n@Ecore(constraints=\"deptHasEmployees positiveID validName\")\n@\"http://eclipse.dev/epsilon/ecore/EVL\"(\n    deptHasEmployees=\"not self.manager.isUndefined() implies self.employees.notEmpty()\",\n    positiveID=\"self.deptID &gt; 0\",\n    validName=\"not self.name.isUndefined() and self.name.length() &gt; 0\")\nclass Department {\n    ref Employee manager;\n    id attr int[1] deptID;\n    attr String name;\n\n    @\"http://eclipse.dev/epsilon/ecore/EOL\"(\n        derivation=\"if (self.manager.isUndefined()) {\n                return Sequence{};\n            } else {\n                return self.manager.directReports;\n            }\")\n    !ordered readonly volatile transient derived ref Employee[*]#department employees;\n    ref Company#departments company;\n}\n...</code></pre> <p>For the Employee EClass, we defined the validName constraint implemented via EOperation. The features isManager and department are derived. Last, the operations allReports, reportinChain and reportsTo are implemented with EOL.</p> <pre><code>...\n@Ecore(constraints=\"positiveID validName\")\n@\"http://eclipse.dev/epsilon/ecore/EVL\"(\n    positiveID=\"self.empID &gt; 0\")\nclass Employee {\n\n    @\"http://eclipse.dev/epsilon/ecore/EOL\"(\n        body=\"return self.closure(t | t.directReports);\")\n    !ordered op Employee[*] allReports();\n\n    @\"http://eclipse.dev/epsilon/ecore/EOL\"(\n        body=\"if (self.manager.isUndefined()) {\n                return Sequence{};\n            } else {\n                var result = Sequence {self.manager};\n                return result.includingAll(self.manager.reportingChain());\n            }\")\n    op Employee[*] reportingChain();\n\n    @\"http://eclipse.dev/epsilon/ecore/EOL\"(\n        body=\"return self.reportingChain().includes(mgr);\")\n    !ordered op boolean reportsTo(Employee mgr);\n\n    @\"http://eclipse.dev/epsilon/ecore/EVL\"(\n        body=\"not self.name.isUndefined() and self.name.length() &gt; 0\")\n    op boolean validName(ecore.EDiagnosticChain diagnostics, ecore.EMap&lt;EJavaObject, EJavaObject&gt; context);\n\n    @\"http://eclipse.dev/epsilon/ecore/EOL\"(\n        derivation=\"return self.directReports.notEmpty();\")\n    readonly volatile transient derived attr boolean isManager;\n\n    @\"http://eclipse.dev/epsilon/ecore/EOL\"(\n        derivation=\"return self.company.departments.selectOne(d | d.employees.includes(self));\")\n    readonly volatile transient derived ref Department#employees department;\n    ref Employee#directReports manager;\n    !ordered ref Employee[*]#manager directReports;\n    id attr int[1] empID;\n    attr String name;\n    ref Company#employees company;\n}\n</code></pre>"},{"location":"doc/articles/epsilon-in-ecore/#validation-results","title":"Validation Results","text":"<p>The results of running the validation are shown in the following figure.</p> <p></p>"},{"location":"doc/articles/epsilon-in-ecore/#derived-features","title":"Derived Features","text":"<p>In the following figure, we selected one of the Employees that does not satisfy the positiveID constraint. We can also see that the isManager and department features values have been derived.</p> <p></p>"},{"location":"doc/articles/eugenia-affixed-nodes/","title":"Eugenia: Affixed Nodes in GMF","text":"<p>From the following annotated Ecore metamodel (in Emfatic)</p> <pre><code>@namespace(uri=\"components\", prefix=\"components\")\npackage components;\n\n@gmf.diagram\nclass ComponentDiagram {\n   val Component[*] components;\n   val Connector[*] connectors;\n}\n\nabstract class NamedElement {\n   attr String name;\n}\n\n@gmf.node(label=\"name\")\nclass Component extends NamedElement {\n   @gmf.affixed\n   val Port[*] ports;\n}\n\n@gmf.node(figure=\"rectangle\", size=\"20,20\", label=\"name\",\n  label.placement=\"external\", label.icon=\"false\")\nclass Port extends NamedElement {\n\n}\n\n@gmf.link(source=\"source\", target=\"target\", label=\"name\",\n  target.decoration=\"arrow\")\nclass Connector extends NamedElement {\n   ref Port source;\n   ref Port target;\n}</code></pre> <p>Eugenia can automatically generate this GMF editor:</p> <p></p>"},{"location":"doc/articles/eugenia-ant/","title":"Eugenia: Automated Invocation with Ant","text":"<p>Eugenia can be called from Ant, using the <code>&lt;epsilon.eugenia&gt;</code> Ant task. This way, the creation of the GMF editors can be easily automated by using a standard Ant Builder. Additionally, the Ant task has several features which are not currently available through the regular graphical user interface.</p> <p>In this article, we will show how to invoke the Eugenia Ant task and offer some recommendations on how to adopt it.</p>"},{"location":"doc/articles/eugenia-ant/#basic-usage","title":"Basic usage","text":"<p>The Eugenia Ant task only requires specifying the source Emfatic description or Ecore model through the <code>src</code> attribute:</p> <pre><code>&lt;!-- Generate myfile.ecore from myfile.emf and then proceed --&gt;\n&lt;epsilon.eugenia src=\"myfile.emf\"/&gt;\n\n&lt;!-- Start directly from the Ecore model --&gt;\n&lt;epsilon.eugenia src=\"myfile.ecore\"/&gt;\n</code></pre> <p>Warning</p> <p>The Eugenia Ant task requires that the Ant buildfile is run from the same JRE as the workspace. Please check the Workflow documentation for instructions on how to do it.</p>"},{"location":"doc/articles/eugenia-ant/#limiting-the-steps-to-be-run","title":"Limiting the steps to be run","text":"<p>Normally, Eugenia runs all these steps:</p> <ul> <li>Clean the models from the previous run (the <code>clean</code> step)</li> <li>If <code>src</code> is an Emfatic source file (with the <code>.emf</code> extension), generate the Ecore model from it (<code>ecore</code>)</li> <li>Generate the EMF GenModel from the Ecore model and polish it with <code>Ecore2GenModel.eol</code> if available (<code>genmodel</code>)</li> <li>Generate the GmfGraph, GmfTool and GmfMap models and polish them with <code>Ecore2GMF.eol</code> if available (<code>gmf</code>)</li> <li>Generate the GmfGen model and polish it with <code>FixGMFGen.eol</code> if available (<code>gmfgen</code>)</li> <li>Generate the EMF code from the EMF GenModel model (<code>emfcode</code>)</li> <li>Generate the GMF code from the GMFGen model (<code>gmfcode</code>) Optionally, the Ant task can run only some of these steps. The <code>firstStep</code> attribute can be used to specify the first step to be run, and the <code>lastStep</code> can be used to specify the last step to be run. For example:</li> </ul> <pre><code>&lt;!-- Skips the clean, ecore and genmodel steps --&gt;\n&lt;epsilon.eugenia src=\"myfile.ecore\" firstStep=\"gmf\"/&gt;\n\n&lt;!-- Does not run the emfcode and gmfcode steps --&gt;\n&lt;epsilon.eugenia src=\"myfile.emf\" lastStep=\"gmfgen\"/&gt;\n\n&lt;!-- Only runs the gmf and gmfgen steps --&gt;\n&lt;epsilon.eugenia src=\"myfile.ecore\" firstStep=\"gmf\" lastStep=\"gmfgen\"/&gt;\n</code></pre>"},{"location":"doc/articles/eugenia-ant/#using-extra-models-for-polishing","title":"Using extra models for polishing","text":"<p>Additional models to be used in a polishing transformation can be specified through the <code>&lt;model&gt;</code> nested element. <code>&lt;model&gt;</code> has three attributes:</p> <ul> <li><code>ref</code> (mandatory) is the name with which the model was loaded into the model repository of the Ant project, using the Epsilon model loading Ant tasks.</li> <li><code>as</code> (optional) is the name to be used for the model inside the polishing transformation.</li> <li><code>step</code> (mandatory) is the identifier of the Eugenia step to which we will add the model reference. As an example, consider the following fragment:</li> </ul> <pre><code>&lt;epsilon.emf.loadModel name=\"Labels\"\nmodelfile=\"my.model\" metamodeluri=\"mymetamodelURI\"\nread=\"true\" store=\"false\"/&gt;\n\n&lt;epsilon.eugenia src=\"myfile.emf\"&gt;\n&lt;model ref=\"Labels\" step=\"gmf\"/&gt;\n&lt;/epsilon.eugenia&gt;\n</code></pre> <p>This example will make the Labels model available to the <code>Ecore2GMF.eol</code> polishing transformation, which is part of the <code>gmf</code> step.</p>"},{"location":"doc/articles/eugenia-nodes-with-centred-layout/","title":"Eugenia: Nodes with centred content","text":"<p>This recipe shows how to create nodes in your GMF editor whose contents are centred both horizontally and vertically. The resulting editor will produce nodes like this:</p> <p></p> <p>We'll start with the following metamodel and Eugenia annotations:</p> <pre><code>@namespace(uri=\"www.eclipse.org/epsilon/examples/widgets\", prefix=\"w\")\npackage widgets;\n\n@gmf.diagram\nclass System {\n   val Widget[*] widgets;\n}\n\n@gmf.node(label=\"name\", label.icon=\"false\")\nclass Widget {\n   attr String[1] name;\n}</code></pre> <p>In this case, we only have one child node (the label for the node). We need to add a polishing transformation to our project (described in more detail in this article) to use a grid layout and specify the appropriate layout data for the label. In a file named ECore2GMF.eol, place the following code:</p> <pre><code>var shape = findShape('WidgetFigure');\nshape.layout = new GmfGraph!GridLayout;\n\nvar label = shape.children.first;\nlabel.layoutData = new GmfGraph!GridLayoutData;\nlabel.layoutData.grabExcessVerticalSpace = true;\nlabel.layoutData.grabExcessHorizontalSpace = true;\n\noperation findShape(name : String) {\n  return GmfGraph!Shape.all.selectOne(s|s.name = name);\n}</code></pre> <p>If we have multiple child nodes, we may want to use a custom layout manager instead to achieve the centring. The polishing transformation will have to add the custom layout to our widget figure, and the ECcore2GMF.eol file will now look like this:</p> <pre><code>findShape('WidgetFigure').layout = createCentredLayout();\n\noperation findShape(name : String) {\n  return GmfGraph!Shape.all.selectOne(s|s.name = name);\n}\n\noperation createCentredLayout() : GmfGraph!CustomLayout {\n  var layout = new GmfGraph!CustomLayout;\n  layout.qualifiedClassName = 'widgets.custom.layouts.CentredLayout';\n  return layout;\n}</code></pre> <p>Notice that the layout specifies a qualified class name of <code>widgets.custom.layouts.CentredLayout</code>. We must create a class with that name, which implements the <code>LayoutManager</code> of draw2d. We'll use this exemplar implementation of widgets.custom.layouts.CentredLayout and place it in a <code>widgets.custom</code> plug-in project. We must add a dependency for the <code>widgets.custom</code> plugin project to the <code>widgets.diagram</code> project generated by GMF.</p> <p>For more details, please check the <code>org.eclipse.epsilon.eugenia.examples.centred</code> example projects at the Epsilon Git repository.</p>"},{"location":"doc/articles/eugenia-nodes-with-images/","title":"Eugenia: Nodes with images instead of shapes","text":"<p>This recipe shows how to create nodes in your GMF editor that are represented with images (png, jpg etc.) instead of the standard GMF shapes (rectangle, ellipse etc.). We'll use the simple <code>friends</code> metamodel as demonstration:</p> <pre><code>@namespace(uri=\"friends\", prefix=\"\")\npackage friends;\n\n@gmf.diagram\nclass World {\n    val Person[*] people;\n}\n\n@gmf.node(figure=\"figures.PersonFigure\", label.icon=\"false\", label=\"name\", label.placement=\"external\")\nclass Person {\n    attr String name;\n\n    @gmf.link(width=\"2\", color=\"0,255,0\", source.decoration=\"arrow\",\n      target.decoration=\"arrow\", style=\"dash\")\n    ref Person[*] friendOf;\n\n    @gmf.link(width=\"2\", color=\"255,0,0\", source.decoration=\"arrow\", \n      target.decoration=\"arrow\", style=\"dash\")\n    ref Person[*] enemyOf;\n}</code></pre> <p>We define a custom figure for Person (<code>figure=\"figures.PersonFigure\"</code>) and also specify that the label should be placed externally to the node (<code>label.placement=\"external\"</code>). Once we have generated our diagram code we need to go and define the <code>figure.PersonFigure</code> class. An example of an png image-based implementation is available below:</p> <pre><code>package figures;\n\nimport org.eclipse.draw2d.ImageFigure;\nimport activator.PluginActivator;\n\n/**\n * @generated\n */\npublic class PersonFigure extends ImageFigure {\n\npublic PersonFigure() {\nsuper(PluginActivator.imageDescriptorFromPlugin(PluginActivator.ID,\n\"images/Person.png\").createImage(), 0);\n}\n\n}\n</code></pre> <p>The PluginActivator extends AbstractUIPlugin, which provides methods for loading images from within our plug-in:</p> <pre><code>package activator;\n\nimport org.eclipse.core.runtime.Plugin;\nimport org.eclipse.ui.plugin.AbstractUIPlugin;\nimport org.osgi.framework.BundleContext;\n\n\npublic class PluginActivator extends AbstractUIPlugin {\n\npublic static final String ID = \"friends.figures\"; //$NON-NLS-1$\n\n\nprivate static PluginActivator ourInstance;\n\npublic PluginActivator() {}\n\npublic void start(BundleContext context) throws Exception {\nsuper.start(context);\nourInstance = this;\n}\n\npublic void stop(BundleContext context) throws Exception {\nourInstance = null;\nsuper.stop(context);\n}\n\npublic static PluginActivator getDefault() {\nreturn ourInstance;\n}\n}\n</code></pre> <p>The result looks like this:</p> <p></p> <p>For more details, please check the full example.</p>"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/","title":"Eugenia: Nodes with images defined at run-time","text":"<p>This recipe addresses the case where the end-user needs to set an image for each node at runtime (based on Thomas Beyer's solution presented in the GMF newsgroup). For our example, we'll use the Component class.</p>"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#create-an-attribute-to-store-the-image-path","title":"Create an attribute to store the image path","text":"<p>First we need to create an <code>imagePath</code> attribute that will store the path of the image for each component.</p>"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#set-the-figure-of-component-to-a-custom-componentfigure","title":"Set the figure of Component to a custom ComponentFigure","text":"<p>The next step is to set the figure of Component in Eugenia to a custom figure. After those two steps, our definition of Component looks like this:</p> <pre><code>@gmf.node(label=\"name\", figure=\"ccdl.diagram.figures.ComponentFigure\", label.placement=\"external\")\nclass Component {\n  attr String name;\n  attr String imagePath;\n}</code></pre> <p>Once we generate the diagram code, we'll get an error because <code>ComponentFigure</code> has not been found. We need to create the <code>ComponentFigure</code> class and set its code to the following:</p> <pre><code>import java.io.File;\nimport java.util.HashMap;\n\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.FileLocator;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.draw2d.ImageFigure;\nimport org.eclipse.jface.resource.ImageDescriptor;\nimport org.eclipse.swt.graphics.Image;\n\nimport ccdl.diagram.part.CcdlDiagramEditorPlugin;\n\npublic class ComponentFigure extends ImageFigure  {\n\nstatic Image unspecified = null;\n\npublic ComponentFigure() {\nif (unspecified == null) {\nunspecified = ImageDescriptor.createFromURL(\nFileLocator.find(\nPlatform.getBundle(CcdlDiagramEditorPlugin.ID),\nnew Path(\"icons/ComponentDefault.png\"), new HashMap()))\n.createImage();\n}\n}\n\npublic static Image createImage(String imagePath) {\ntry {\nIFile res=(IFile)ResourcesPlugin.getWorkspace().getRoot().\nfindMember(new Path(imagePath));\nFile file = new File(res.getRawLocation().toOSString());\nreturn ImageDescriptor.createFromURL(file.toURI().toURL()).createImage();\n}\ncatch (Exception ex) {\nreturn unspecified;\n}\n}\n\npublic void setImagePath(String imagePath) {\n\ntry {\n\nif (getImage()!=null &amp;&amp; getImage() !=unspecified) {\ngetImage().dispose();\n}\n\nthis.setImage(createImage(imagePath));\n}\ncatch (Exception ex) {\nex.printStackTrace();\n}\n}\n\n}\n</code></pre>"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#create-the-image-path-property-descriptor","title":"Create the image path property descriptor","text":"<p>The next step is to create the property descriptor for the image path so that we can eventually get a nice browse button in the properties view. To do this we need to create a new class named <code>ComponentImagePathPropertyDescriptor</code>.</p> <pre><code>import org.eclipse.emf.ecore.EAttribute;\nimport org.eclipse.emf.edit.provider.IItemPropertyDescriptor;\nimport org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositeSourcePropertyDescriptor;\nimport org.eclipse.jface.viewers.CellEditor;\nimport org.eclipse.swt.widgets.Composite;\n\npublic class ComponentImagePathPropertyDescriptor  extends\nEMFCompositeSourcePropertyDescriptor {\n\npublic ComponentImagePathPropertyDescriptor(Object object,\nIItemPropertyDescriptor itemPropertyDescriptor, String category) {\nsuper(object, itemPropertyDescriptor, category);\n}\n\nprotected CellEditor doCreateEditor(Composite composite) {\ntry {\nif (((EAttribute) getFeature()).getName().equals(\"imagePath\")) {\nreturn new ComponentImagePathCellEditor(composite);\n}\n}\ncatch (Exception ex){}\nreturn super.doCreateEditor(composite);\n}\n}\n</code></pre>"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#create-the-image-path-property-cell-editor","title":"Create the image path property cell editor","text":"<pre><code>import org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.jface.viewers.DialogCellEditor;\nimport org.eclipse.jface.window.Window;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.ui.dialogs.ResourceListSelectionDialog;\n\npublic class ComponentImagePathCellEditor extends DialogCellEditor  {\n\npublic ComponentImagePathCellEditor(Composite parent) {\nsuper(parent);\n}\n\nprotected Object openDialogBox(Control cellEditorWindow) {\n\nResourceListSelectionDialog elementSelector = new ResourceListSelectionDialog(\ncellEditorWindow.getShell(), ResourcesPlugin.getWorkspace().getRoot(),\nIResource.DEPTH_INFINITE | IResource.FILE );\nelementSelector.setTitle(\"Image\");\nelementSelector.setMessage(\"Please select an image\");\nelementSelector.open();\n\nif (elementSelector.getReturnCode() == Window.OK){\nIFile f = (IFile) elementSelector.getResult()[0];\nreturn f.getFullPath().toString();\n}\nelse {\nreturn null;\n}\n\n\n}\n\n}\n</code></pre>"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#update-the-xxxpropertysection-under-xxxdiagramsheet","title":"Update the XXXPropertySection under xxx.diagram.sheet","text":"<p>Update the <code>getPropertySource</code> method as follows:</p> <pre><code>public IPropertySource getPropertySource(Object object) {\nif (object instanceof IPropertySource) {\nreturn (IPropertySource) object;\n}\nAdapterFactory af = getAdapterFactory(object);\nif (af != null) {\nIItemPropertySource ips = (IItemPropertySource) af.adapt(object,\nIItemPropertySource.class);\n\nif (ips != null) {\n\nif (object instanceof Component) {\nreturn new PropertySource(object, ips) {\nprotected IPropertyDescriptor createPropertyDescriptor(\nIItemPropertyDescriptor itemPropertyDescriptor) {\n\nEStructuralFeature feature = (EStructuralFeature) itemPropertyDescriptor.getFeature(object);\n\nif(feature.getName().equalsIgnoreCase(\"imagePath\")) {\n\nreturn new ComponentImagePathPropertyDescriptor(\nobject, itemPropertyDescriptor, \"Misc\");\n\n\n}\nelse {\nreturn new EMFCompositeSourcePropertyDescriptor(object, itemPropertyDescriptor, \"Misc\");\n}\n}\n};\n}\n\n//return new PropertySource(object, ips);\nreturn new EMFCompositePropertySource(object, ips, \"Misc\");\n}\n}\nif (object instanceof IAdaptable) {\nreturn (IPropertySource) ((IAdaptable) object)\n.getAdapter(IPropertySource.class);\n}\nreturn null;\n}\n</code></pre>"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#modify-the-edit-part","title":"Modify the edit part","text":"<p>Modify the <code>handleNotificationEvent</code> method so that the figure is updated every time the value of <code>imagePath</code> changes</p> <pre><code>protected void handleNotificationEvent(Notification event) {\nif (event.getNotifier() == getModel()\n&amp;&amp; EcorePackage.eINSTANCE.getEModelElement_EAnnotations()\n.equals(event.getFeature())) {\nhandleMajorSemanticChange();\n} else {\n\nif (event.getFeature() instanceof EAttribute) {\nEAttribute eAttribute = (EAttribute) event.getFeature();\n\nif (eAttribute.getName().equalsIgnoreCase(\"imagePath\")) {\nComponentFigure figure = (ComponentFigure) this.getPrimaryShape();\nfigure.setImagePath(event.getNewStringValue());\n}\n\n}\n\n\nsuper.handleNotificationEvent(event);\n}\n}\n</code></pre> <p>Modify the <code>createNodeShape</code> method so that the figure is initialized from the existing <code>imagePath</code> the first time.</p> <pre><code>protected IFigure createNodeShape() {\nprimaryShape = new ComponentFigure();\nComponent component = (Component) ((Node)getNotationView()).getElement();\n((ComponentFigure) primaryShape).setImagePath(component.getImagePath());\nreturn primaryShape;\n}\n</code></pre>"},{"location":"doc/articles/eugenia-patching/","title":"Customizing the Java source code generated by Eugenia","text":"<p>Occasionally, the Java source code generated by GMF to implement your graphical editor is not quite what you want, and it's not possible to polish the GMF models to incorporate your desired changes. Essentially, you'd like to change the code generation templates used by GMF.</p> <p>In this situation, you have two options. The first option is to use GMF dynamic templates, which requires some knowledge of Xpand (the code generation language used by GMF) and can often involve hunting around in the GMF code generator for the right place to make your changes. Alternatively, you can use Eugenia's patch generation and application functionality (described below).</p>"},{"location":"doc/articles/eugenia-patching/#running-example","title":"Running example","text":"<p>The remainder of this article demonstrates how to customize the source code for a generated GMF editor to change the size of the margins used for external labels. As shown below, the patched version of the GMF editor positions labels closer to their nodes:</p> <p></p> <p>Note that the models used by GMF to generate our editor don't provide a way to control the size of the margins, so we can't use a polishing transformation.</p>"},{"location":"doc/articles/eugenia-patching/#automatically-patching-the-source-code-of-a-generated-gmf-editor","title":"Automatically patching the source code of a generated GMF editor","text":"<p>After generating the GMF code for your editor, Eugenia will search for a <code>patches</code> directory in the same project as your Emfatic source. If the patches directory is found, Eugenia will apply to your workspace any <code>.patch</code> file found in that directory.</p> <p></p>"},{"location":"doc/articles/eugenia-patching/#creating-and-applying-patches-with-eugenia","title":"Creating and applying patches with Eugenia","text":"<p>Create <code>.patch</code> files using Eclipse's Team functionality:</p> <ul> <li> <p>Make your desired changes to the generated Java source code by hand.</p> </li> <li> <p>Right-click the project containing your changes, and select Team\u2192Create Patch...</p> </li> <li> <p>Select Clipboard and click Finish</p> </li> <li> <p>Create a <code>patches</code> directory in the project containing your Emfatic source.</p> </li> <li> <p>Create a new file (e.g. <code>patches/MyChanges.patch</code>), paste your patch into the new file and save it.</p> </li> <li> <p>The next time that you run EuGEnia, your <code>.patch</code> file will be automatically applied to the generated Java source code.</p> </li> <li> <p>You can also apply or remove all of your patches by right-clicking your <code>patches</code> directory and selecting Eugenia\u2192Apply patches or Eugenia\u2192Remove applied patches.</p> </li> </ul> <p>In our running example, we devise the patch below to fix the margins of externally placed labels for the State model element type. We save the patch into <code>patches/FixExternalLabelMarginsForState.patch</code></p> <pre><code>diff --git org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/StateEditPart.java org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/StateEditPart.java\nindex d0684d6..f162365 100644\n--- org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/StateEditPart.java\n+++ org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/StateEditPart.java\n@@ -143,7 +143,7 @@\n     if (borderItemEditPart instanceof StateNameEditPart) {\n       BorderItemLocator locator = new BorderItemLocator(getMainFigure(),\n           PositionConstants.SOUTH);\n-      locator.setBorderItemOffset(new Dimension(-20, -20));\n+      locator.setBorderItemOffset(new Dimension(-5, -5));\n       borderItemContainer.add(borderItemEditPart.getFigure(), locator);\n     } else {\n       super.addBorderItem(borderItemContainer, borderItemEditPart);\n</code></pre>"},{"location":"doc/articles/eugenia-patching/#generating-patches-with-eugenia","title":"Generating patches with Eugenia","text":"<p>It is possible to generate <code>.patch</code> files as part of the Eugenia code generation process. This allows you to include in <code>.patch</code> files information from your source metamodel, or from the GMF models generated by Eugenia. Generating <code>.patch</code> files is particularly useful when you want to apply the same type of change in several places in the Java source code for your GMF editor:</p> <ul> <li> <p>Create a file named <code>GeneratePatches.egx</code> in the same directory as your Emfatic source code.</p> </li> <li> <p>In the <code>GeneratePages.egx</code> file, write a transformation rule for each element of the ECore or GMF models for which you want to generate a <code>.patch</code> file:</p> </li> <li> <p>Create one or more EGL templates for use by your <code>GeneratePages.egx</code> file. Each EGL template is essentially a parameterised <code>.patch</code> file.</p> </li> <li> <p>The next time that you run EuGEnia, your <code>GeneratePatches.egx</code> file will be automatically invoked to generate one or more <code>.patch</code> files, which will then be automatically applied to the generated Java source code.</p> </li> <li> <p>You can also test your <code>GeneratePatches.egx</code> file, by right-clicking it and selecting Eugenia\u2192Generate patches.</p> </li> </ul> <p>In our running example, we can generalise our State patch (above) such that it is applied to any element in our metamodel that has an external label. First, we create a <code>GeneratePatches.egx</code> file that produces a <code>.patch</code> file for every EClass in our ECore file that is annotated with <code>label.placement</code> set to <code>external</code>:</p> <pre><code>// Imports the EClass#getLabelPlacement() operation from Eugenia\nimport \"platform:/plugin/org.eclipse.epsilon.eugenia/transformations/ECoreUtil.eol\";\n\nrule FixExternalLabelMargins\n  // apply this rule to all EClasses where...\n  transform c : ECore!EClass\n{\n\n  // ... the EClass is annotated with @gmf.node(label.placement=\"external\")\n  guard: c.getLabelPlacement() == \"external\"\n\n  // invoke the following EGL template on the EClass\n  template : \"FixExternalLabelMargin.egl\"\n\n  // make the source directory and name of the node available to the template\n  parameters : Map{ \"srcDir\" = getSourceDirectory(), \"node\" = c.name }\n\n  // and save the generated text to the following .patch file\n  target : \"FixExternalLabelMarginsFor\" + c.name + \".patch\"\n}\n\n// Determine source directory from GMF Gen model\n@cache\noperation getSourceDirectory() {\n  var genEditor = GmfGen!GenEditorGenerator.all.first;\n  return genEditor.pluginDirectory.substring(1) + \"/\" +\n         genEditor.packageNamePrefix.replace(\"\\\\.\", \"/\");\n}</code></pre> <p>We'll also need to provide a parameterised version of our State patch, saving it as an EGL template at <code>FixExternalLabelMargin.egl</code>:</p> <p><pre><code>diff --git [%=srcDir%]/edit/parts/[%=node%]EditPart.java [%=srcDir%]/edit/parts/[%=node%]EditPart.java\nindex d0684d6..f162365 100644\n--- [%=srcDir%]/edit/parts/[%=node%]EditPart.java\n+++ [%=srcDir%]/edit/parts/[%=node%]EditPart.java\n@@ -143,7 +143,7 @@\n     if (borderItemEditPart instanceof [%=node%]NameEditPart) {\n       BorderItemLocator locator = new BorderItemLocator(getMainFigure(),\n           PositionConstants.SOUTH);\n-      locator.setBorderItemOffset(new Dimension(-20, -20));\n+      locator.setBorderItemOffset(new Dimension(-5, -5));\n       borderItemContainer.add(borderItemEditPart.getFigure(), locator);\n     } else {\n       super.addBorderItem(borderItemContainer, borderItemEditPart);\n</code></pre> Note that the above template uses the <code>srcDir</code> and <code>node</code> variables made available by our EGX transformation rule.</p> <p>The next time that Eugenia is invoked, a <code>.patch</code> file is generated and applied for every EClass in our ECore file that has an externally-placed label:</p> <p></p>"},{"location":"doc/articles/eugenia-patching/#faq","title":"FAQ","text":""},{"location":"doc/articles/eugenia-patching/#should-my-patches-produce-generated-not-annotations","title":"Should my patches produce <code>@generated NOT</code> annotations?","text":"<p>No, because this can cause subsequent invocations of Eugenia and the GMF code generator to fail -- the GMF code generator will attempt to preserve code marked as <code>@generated NOT</code> and your <code>.patch</code> files will likely not apply cleanly to the code that has been preserved. The code that is applied via <code>.patch</code> files is generated code and should be treated as such.</p>"},{"location":"doc/articles/eugenia-patching/#one-or-more-of-my-patches-couldnt-be-applied-what-should-i-do","title":"One or more of my patches couldn't be applied. What should I do?","text":"<p>Firstly, check to ensure that Eclipse can apply your patch via the Team\u2192Apply patch... menu item. If not, you'll need to fix your .patch file. Secondly, ensure that the order in which your patches are being applied is not causing problems. By default Eugenia orders patches alphabetically by filename: <code>a.patch</code> will be applied before <code>z.patch</code></p>"},{"location":"doc/articles/eugenia-patching/#im-using-git-svn-and-my-patch-files-cant-be-applied-by-eugenia-or-by-eclipses-teamapply-patch-menu-item-what-should-i-do","title":"I'm using <code>git-svn</code> and my patch files can't be applied by Eugenia or by Eclipse's Team\u2192Apply patch... menu item. What should I do?","text":"<p>You should edit the headers of any patch file generated by <code>git-svn</code> and remove the dummy <code>a</code> and <code>b</code> folders. For example:*</p> <pre><code>diff --git a/org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java b/org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java\nindex 65e2685..109b568 100644\n--- a/org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java\n+++ b/org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java\n@@ -152,6 +152,8 @@\n...\n</code></pre> <p>becomes:</p> <pre><code>diff --git org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java\nindex 65e2685..109b568 100644\n--- org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java\n+++ org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java\n@@ -152,6 +152,8 @@\n...\n</code></pre>"},{"location":"doc/articles/eugenia-phantom-nodes/","title":"Eugenia: Phantom nodes in GMF editors","text":"<p>Containment references in Ecore metamodels are usually depicted in GMF as spatial containment (e.g. in the sense that a class is contained inside the figure of a package). However, it is sometimes needed to represent containment references using links instead. To achieve this, GMF provides the notion of phantom nodes. Eugenia provides first-class support for phantom nodes in GMF using the <code>phantom</code> annotation detail. The following listing provides such an example:</p> <pre><code>@namespace(uri=\"phantom\", prefix=\"phantom\")\npackage phantom;\n\n@gmf.diagram\nclass Model extends NamedElement {\n   val Group[*] groups;\n}\n\nclass NamedElement {\n   attr String name;\n}\n\n@gmf.node(label=\"name\")\nclass Group extends NamedElement {\n   @gmf.link(label=\"member\")\n   val Member[*] members;\n}\n\n@gmf.node(label=\"name\", phantom=\"true\")\nclass Member extends NamedElement {\n\n}</code></pre> <p>In this example, a Model contains many groups and a Group contains many members. To represent the Group.members containment reference as a normal link, we set the <code>phantom</code> detail of the <code>gmf.node</code> annotation of Member to <code>true</code> and add a <code>gmf.link</code> anotation to Group.members. The result looks like this:</p> <p></p> <p></p>"},{"location":"doc/articles/eugenia-polishing/","title":"Customizing a GMF editor generated by Eugenia","text":"<p>So now you have created the first version of your GMF editor with Eugenia and it looks almost like what you want - just a few tweaks and you are there. As Eugenia doesn't support all the features of GMF (otherwise it would be just as complex) you are finding that the tweaks you want to do are not supported by the annotations provided by Eugenia and therefore you need to go change one or more of the generated .gmfgraph, .gmfmap and .gmftool models manually. If you decide to do this, you won't be able to use Eugenia any more for your editor because it will overwrite your changes.</p> <p>We've come across this situation many times and decided to do something about it. Since merging such complex models sensibly is virtually impossible, we've implemented support for user-defined transformations that complement the built-in transformations provided by Eugenia. Let's go straight to an example. We have the following <code>classdiagram</code> metamodel:</p> <pre><code>@namespace(uri=\"classdiagram\", prefix=\"classdiagram\")\npackage classdiagram;\n\n@gmf.diagram\nclass Model {\n   val Clazz[*] classes;\n}\n\n@gmf.node(label=\"name\", figure=\"rectangle\")\nclass Clazz {\n   attr String name;\n   @gmf.compartment(layout=\"list\", collapsible=\"false\")\n   val Attribute[*] attributes;\n}\n\n@gmf.node(label=\"name,type\", figure=\"rectangle\",\n    label.icon=\"false\", label.pattern=\"{0}:{1}\")\nclass Attribute {\n   attr String name;\n   attr String type;\n}</code></pre> <p>and we follow the standard Eugenia procedure to generate a GMF editor from it. The editor looks like this:</p> <p></p> <p>which is almost what we want. What we really want is something like this:</p> <p></p> <p>To get this, we need to customize the <code>classdiagram.gmfgraph</code> model like this</p> <p></p> <p>so that we can get this:</p> <p></p> <p>To perform these changes automatically every time Eugenia is executed on <code>classdiagram.ecore</code>, we can create a new EOL transformation called <code>ECore2GMF.eol</code> and place it in the same folder with <code>classdiagram.ecore</code>. Eugenia will then pick it up and execute it after the built-in transformation every time we invoke <code>Generate GMF tool, graph and map models</code> action. In our case, the <code>ECore2GMF.eol</code> customization transformation looks like this:</p> <pre><code>// Find the compartment figure\nvar clazzAttributesCompartmentFigure = GmfGraph!Rectangle.all.\n    selectOne(r|r.name = 'ClazzAttributesCompartmentFigure');\n\n// ... and add a stack layout to it\nclazzAttributesCompartmentFigure.layout = new GmfGraph!StackLayout;\n\n// Find the attribute figure\nvar attributeFigure = GmfGraph!Rectangle.all.\n    selectOne(r|r.name = 'AttributeFigure');\n\n// ... delete its border\ndelete attributeFigure.border;\n\n// ... set its outline to false\nattributeFigure.outline = false;\n\n// ... and add a preferred size to it\nvar preferredSize = new GmfGraph!Dimension;\npreferredSize.dx = 100;\npreferredSize.dy = 16;\nattributeFigure.preferredSize = preferredSize;</code></pre> <p>Similarly, if we needed to customize the logic behind the <code>Synchronize GMF Gen model</code> action, we'd need to define a <code>FixGMFGen.eol</code> transformation next to <code>classdiagram.ecore</code>.</p>"},{"location":"doc/articles/eugenia-polishing/#what-models-can-i-access-from-the-ecore2gmfeol-and-fixgmfgeneol-transformations","title":"What models can I access from the ECore2GMF.eol and FixGMFGen.eol transformations?","text":"<p>In the <code>Ecore2GenModel.eol</code> transformation and the later <code>FixGenModel.eol</code> transformation you can access the ECore metamodel (named <code>Ecore</code>) and the EMF GenModel model (named <code>GenModel</code>). You can run <code>Ecore2GenModel.eol</code> or <code>FixGenModel.eol</code> manually by right-clicking on the <code>.ecore</code> file and selecting \"Generate EMF GenModel\" or \"Synchronize EMF GenModel\", respectively.</p> <p>In the <code>ECore2GMF.eol</code> transformation you can access the ECore metamodel (named <code>ECore</code>), the tool model (named <code>GmfTool</code>), the graph model (named <code>GmfGraph</code>) and the map model (named <code>GmfMap</code>). You can regenerate the GMF models and run <code>ECore2GMF.eol</code> manually by right-clicking on the <code>.ecore</code> file and selecting \"Generate GMF tool, graph and map models\".</p> <p>In the <code>FixGMFGen.eol</code> transformation you can access the ECore metamodel (named <code>ECore</code>), and the generator model (named <code>GmfGen</code>). You can run <code>FixGMFGen.eol</code> manually by right-clicking on the <code>.gmfgen</code> model (which should have been created previously from the <code>.gmfmap</code> using standard GMF tools) and selecting \"Synchronize GMFGen\".</p>"},{"location":"doc/articles/eugenia-polishing/#how-do-i-customize-the-generated-code","title":"How do I customize the generated code?","text":"<p>GMF generates code in two steps:</p> <ol> <li>During the GmfMap \u2192 GmfGen transformation: small fragments are embedded into the GmfGen model, using GMF figure templates. </li> <li>From the GmfGen model: the embedded bits are dumped to certain files, and additional code is generated using the rest of the GMF templates.</li> </ol> <p>To use your own GMF figure templates, you need to place them under a folder called <code>templates-gmfgraph</code>, which should be a sibling of the folder where your <code>.emf</code> or <code>.ecore</code> files are stored. If it exists, Eugenia will use its templates for the GmfMap \u2192 GmfGen transformation.</p> <p>To customize the code generated from the GmfGen model, you will need to use Eugenia's patch generation and application functionality or GMF dynamic templates.</p>"},{"location":"doc/articles/eugenia-polishing/#getting-assistance-in-writing-these-transformations","title":"Getting assistance in writing these transformations","text":"<p>You'll most probably find Exeed and the EPackage Registry view to be useful for writing such transformations.</p>"},{"location":"doc/articles/evl-gmf-integration/","title":"Live validation and quick-fixes in GMF-based editors with EVL","text":"<p>In this tutorial, we demonstrated how Eugenia can be used to easily implement a GMF-based editor for a small FileSystem DSL. Now, we demonstrate how the Epsilon Validation Language can be used to easily contribute validation/quick fixes to our GMF editor. </p> <p>Info</p> <p>This applies to any GMF-based editor - not only to editors constructed with Eugenia.</p> <p>Warning</p> <p>If you have not implemented your editor using Eugenia, before you start please make sure that you have turned on validation in your .gmfgen model. The flags you need to set to true are the <code>Validation Enabled</code> and <code>Validation Decorators</code> in the <code>Gen Diagram</code>.</p>"},{"location":"doc/articles/evl-gmf-integration/#step-1-create-the-integration-plugin","title":"Step 1: Create the integration plugin","text":"<p>In the first step we create the integration plugin that will host our constraints and extensions. We name it <code>org.eclipse.epsilon.eugenia.examples.filesystem.validation</code></p>"},{"location":"doc/articles/evl-gmf-integration/#step-2-set-the-dependencies","title":"Step 2: Set the dependencies","text":"<p>We switch to the dependencies tab of <code>MANIFEST.MF</code> and add <code>org.eclipse.ui.ide</code> and <code>org.eclipse.epsilon.evl.emf.validation</code> to the list of dependencies.</p>"},{"location":"doc/articles/evl-gmf-integration/#step-3-write-the-constraints","title":"Step 3: Write the constraints","text":"<p>We create a new .evl file in the plugin. In our case we've created it under <code>validation/filesystem.evl</code> (make sure you switch to the Build tab to verify that the .evl file is included in your binary build).</p> <p>In our example we define the following constraints:</p> <pre><code>context File {\n\n    constraint HasName {\n\n        check : self.name.isDefined()\n\n        message : 'Unnamed ' + self.eClass().name + ' not allowed'\n\n    }\n\n}\n\ncontext Folder {\n\n    critique NameStartsWithCapital {\n\n        guard : self.satisfies('HasName')\n\n        check : self.name.firstToUpperCase() = self.name\n\n        message : 'Folder ' + self.name +\n            ' should start with an upper-case letter'\n\n        fix {\n\n            title : 'Rename to ' + self.name.firstToUpperCase()\n\n            do {\n                self.name := self.name.firstToUpperCase();\n            }\n        }\n\n    }\n\n}\n\ncontext Sync {\n\n    constraint MustLinkSame {\n\n        check : self.source.eClass() = self.target.eClass()\n\n        message : 'Cannot synchronize a ' + self.source.eClass().name\n            + ' with a ' + self.target.eClass().name\n\n        fix {\n\n            title : 'Synchronize with another ' +\n                self.source.eClass().name\n\n            do {\n\n                var target := UserInput.choose('Select target',\n                    _Model.getAllOfType(self.source.eClass().name));\n\n                if (target.isDefined()) self.target := target;\n\n            }\n\n        }\n\n    }\n\n}</code></pre> <p>We have defined three constraints:</p> <ul> <li>The first (<code>HasName</code>) requires that each file has a non-empty name.</li> <li>The second one (<code>NameStartsWithCapital</code>) requires that every folder starts with a capital letter. Unlike the <code>HasName</code>, this is declared as a critique which means that if it is not satisfied by an element, this will be shown as a warning (instead of an error) on the editor. In the <code>guard</code> of this constraint we first check that the element satisfies the <code>HasName</code> constraint first (it wouldn't make sense to check this for an empty-named file). If the critique is not satisfied, a warning is generated and the user is presented with the option to invoke the fix which automatically renames the folder.</li> <li>The third one (<code>MustLinkSame</code>) requires that a sync synchronizes two things of the same type: i.e. a folder with a folder, a file with a file etc. If this fails, it generates an error and the user can invoke the fix to repair it. In the fix, the user is prompted to select one of the elements of the same type as the source of the sync to serve as the target.</li> </ul>"},{"location":"doc/articles/evl-gmf-integration/#step-4-bind-the-constraints-to-the-editor","title":"Step 4: Bind the constraints to the editor","text":"<p>Having written the constraints, the next step is to bind them to the GMF editor. To do this, we switch to the <code>Extensions</code> tab of MANIFEST.MF and add the <code>org.eclipse.epsilon.evl.emf.validation</code> extension. Then we right-click it and add a new <code>constraintBinding</code>. In the <code>namespaceURI</code> field of the extension we set the value to <code>filesystem</code> and in the <code>constraints</code> field we select the <code>validation/filesystem.evl</code> EVL file we created in Step 3.</p> <p>Next, we add the <code>org.eclipse.ui.ide.markerResolution</code> extension and below it we create two <code>markerResolutionGenerator</code> with the following details</p> <ul> <li><code>class</code> : <code>org.eclipse.epsilon.evl.emf.validation.EvlMarkerResolutionGenerator</code></li> <li><code>markerType</code> : <code>org.eclipse.epsilon.eugenia.examples.filesystem.diagram.diagnostic</code></li> </ul> <p>and</p> <ul> <li><code>class</code> : <code>org.eclipse.epsilon.evl.emf.validation.EvlMarkerResolutionGenerator</code></li> <li><code>markerType</code> : <code>org.eclipse.emf.ecore.diagnostic</code></li> </ul>"},{"location":"doc/articles/evl-gmf-integration/#step-5-ready-to-go","title":"Step 5: Ready to go!","text":"<p>The next step is to run a new Eclipse instance and create a new filesystem diagram that looks like this:</p> <p></p> <p>To validate this we go to the <code>Diagram</code> menu and select <code>Validate</code> (depending on your version of Eclipse, the <code>Validate</code> option may be located under the <code>Edit</code> menu instead). The editor now looks like this:</p> <p></p> <p>There are two problems with our model:</p> <ul> <li>The sync between picture.bmp and backup is invalid as it syncs a file with a folder. As a result the <code>MustLinkSame</code> constraint has failed and the sync has been visually annotated with a red circle that shows this.</li> <li>Similarly, the <code>NameStartsWithCapital</code> constraints has failed for the backup folder (it should start with an upper-case letter) and this is indicated with a red triangle on the folder.</li> </ul> <p>The generated errors/warnings also appear in the <code>Problems</code> view:</p> <p></p> <p>Double-clicking on an error/warning in this view brings us to the respective editor and highlights the failing element. What is more important however is that for constraints for which we have defined fixes (e.g. the <code>MustLinkSame</code> and <code>NameStartsWithCapital</code>) constraints, we can also apply the fixes using this view. To do this we need to right-click a problem that has quick fixes (indicated by a small lamp on the bottom right) and select <code>Quick Fix</code>.</p> <p>Doing this for the \"Folder backup should start with an upper-case letter\" warning, brings up the following dialog:</p> <p></p> <p>Clicking <code>Finish</code> invokes the behaviour of the fix which renames the folder from backup to Backup (and resolves the problem). The change is also reflected to the diagram automatically due to the GMF MVC architecture. It is worth mentioning that any changes done during a quick fix can be undone/redone using the respective options from the <code>Edit</code> menu (or simply using <code>Ctrl-Z</code>, <code>Ctrl-Y</code>). Also, if an error occurs in the middle of a fix block, all changes to the model done in the block are automatically rolled back.</p> <p></p>"},{"location":"doc/articles/evl-gmf-integration/#troubleshootingknown-issues","title":"Troubleshooting/Known issues","text":"<p>While errors/warnings are persisted across sessions, quick-fixes are not. Therefore, if you run validation and re-start Eclipse, in the new Eclipse instance the problems will still appear in the editor/problems view but quick-fixes will not be available until you run validation again. We are currently working on a fix for this.</p>"},{"location":"doc/articles/evl-gmf-integration/#recipes","title":"Recipes","text":"<p>If you need validation to be performed whenever your diagram is saved add the following line in the <code>doSaveDocument(IProgressMonitor monitor, Object element, IDocument document, boolean overwrite)</code> method of your <code>XXXDocumentProvider</code> class (located in the <code>.diagram.part</code> package) in your diagram plugin.</p> <pre><code>ValidateAction.runValidation((View) document.getContent());\n</code></pre>"},{"location":"doc/articles/excel/","title":"Scripting Excel Spreadsheets using Epsilon","text":"<p>Spreadsheets are commonly used in software and systems engineering processes to capture and analyse structured data, and can be sources of valuable information for model-based software engineering activities. </p> <p>Epsilon provides built-in support for querying and transforming Excel spreadsheets through an Apache POI-based EMC driver. This article discusses how you can configure an Epsilon program to query and modify an Excel spreadsheet, and the video below demonstrates the driver in action.</p> Citing the Excel EMC driver in a publication? <p>If you are referring to Epsilon's Excel EMC driver in a publication, please cite this paper instead of the website URL.</p> Regression in Epsilon 2.2 <p>Due to a regression, the Excel driver is broken in Epsilon 2.2. The driver works well in previous versions (e.g. 2.1) as well as in 2.3. Support for column datatypes and for writing to Excel spreadsheets has improved substantially in 2.3.</p>"},{"location":"doc/articles/excel/#worksheets-columns-and-rows","title":"Worksheets, Columns and Rows","text":"<p>Essentially, in the Excel driver, by default, worksheets are treated as model element types (e.g. <code>Student</code>, <code>Staff</code>, <code>Module</code> and <code>Mark</code> in the spreadsheet below), columns as their properties (e.g. <code>Mark</code> has <code>student</code>, <code>module</code> and <code>mark</code> properties), and rows are treated as model elements (i.e. there are two students, two members of staff, three modules and two marks in the spreadsheet below).</p> StudentStaffModuleMark <p> ABCDEF 1idfirstnamelastnameagesupervisormodules 2jt501JoeThompson23mt506MSD,RQE 3js502JaneSmith22mt506MSD,HCI </p> <p> ABCDEF 1idfirstnamelastnameteaches 2mt506MatthewThomasMSD,RQE 3dj503DanielJacksonHCI </p> <p> ABCDEF 1idtitleterm 2MSDModelling and System DesignAutumn 3HCIHuman Computer InteractionSpring 4RQERequirements EngineeringSpring </p> <p> ABCDEF 1studentmodulemark 2jt501MSD62 3js502HCI74 </p>"},{"location":"doc/articles/excel/#references-and-column-types","title":"References and Column Types","text":"<p>The driver supports specifying additional configuration information (e.g. column data types, references between columns) about a spreadsheet in the form of an external XML document, that can be attached to the spreadsheet in Epsilon's run configuration dialog.</p> <p>For our example spreadsheet, above, the configuration file below specifies the types of the <code>age</code> and <code>mark</code> columns of the spreadsheet, the multiplicity of the <code>teaches</code> column, as well as references between the <code>Student.supervisor</code> and <code>Staff.id</code>, and the <code>Staff.teaches</code> and <code>Module.id</code> columns.</p> <pre><code>&lt;spreadsheet&gt;\n&lt;worksheet name=\"Student\"&gt;\n&lt;column name=\"age\" datatype=\"integer\"/&gt;\n&lt;column name=\"modules\" many=\"true\"/&gt;\n&lt;/worksheet&gt;\n&lt;worksheet name=\"Mark\"&gt;\n&lt;column name=\"mark\" datatype=\"integer\"/&gt;\n&lt;/worksheet&gt;\n&lt;worksheet name=\"Staff\"&gt;\n&lt;column name=\"teaches\" many=\"true\" delimiter=\",\"/&gt;\n&lt;/worksheet&gt;\n&lt;reference source=\"Student-&gt;supervisor\"\ntarget=\"Staff-&gt;id\"/&gt;\n&lt;reference source=\"Student-&gt;modules\"\ntarget=\"Module-&gt;id\"/&gt;           &lt;reference source=\"Staff-&gt;teaches\"\ntarget=\"Module-&gt;id\"/&gt;\n&lt;reference source=\"Mark-&gt;module\"\ntarget=\"Module-&gt;id\"/&gt;\n&lt;reference source=\"Mark-&gt;student\"\ntarget=\"Student-&gt;id\"/&gt;\n&lt;/spreadsheet&gt;\n</code></pre> <p>The format of the XML configuration document is as follows:</p>"},{"location":"doc/articles/excel/#worksheet","title":"Worksheet","text":"<p>Each worksheet can have an optional name (if a name is not provided, the name of the worksheet on the spreadsheet is used) and acts as a container for <code>column</code> elements.</p>"},{"location":"doc/articles/excel/#column","title":"Column","text":"<p>Each <code>column</code> needs to specify at least either its zero-based <code>index</code> in the context of the worksheet it belongs to, or its <code>name</code> (if a name is not provided, the cell value in the first row is used, as discussed above). Additionally, a <code>column</code> can have:</p> <ul> <li><code>alias</code>: an alternative name for the column.</li> <li><code>datatype</code>: the type of the values in the column. As of Epsilon 2.5.0, the valid options (ignoring case) are <code>string</code>, <code>integer</code>, <code>boolean</code>, <code>double</code>, or <code>float</code>. The default datatype is <code>string</code>.</li> <li><code>many</code>: it can be <code>true</code> or <code>false</code>. If <code>true</code>, then its cells will be considered to contain unbounded collections, separated by the <code>delimeter</code>(see below). Columns are single-valued by default.</li> <li><code>delimeter</code>: the delimiter used to separate values if <code>many</code> is <code>true</code>. The default delimeter is <code>,</code>.</li> </ul> <p>As of 2.6.0, numeric values are converted to various datatypes as follows:</p> <ul> <li><code>string</code>: the textual representation of the cell's value is used, applying its declared format if possible. If the cell format is not supported, a format similar to the Excel General format will be used: <code>#</code> for whole numbers and <code>#.##########</code> for decimal numbers (see the Apache POI DateFormatter documentation).</li> <li><code>integer</code>, <code>double</code>, and <code>float</code>:  the cell value is computed (using the formula if one is present), and then cast to the appropriate datatype.</li> <li><code>boolean</code>: zero values will be treated as <code>false</code>, and non-zero values will be treated as <code>true</code>.</li> </ul> Issues with numeric cell values in Epsilon 2.5.0 and earlier <p>In Epsilon 2.5.0 and earlier releases, the Excel driver only supported the <code>integer</code>, <code>double</code>, and <code>float</code> datatypes for cells with numeric values. <code>string</code> and <code>boolean</code> datatypes were ignored, and treated as <code>double</code>. See issue #89.</p>"},{"location":"doc/articles/excel/#reference","title":"Reference","text":"<p>In a configuration document we can also specify ID-based references to capture relationships between columns belonging to potentially different worksheets. Each reference has a <code>source</code> and a <code>target</code> column, an optional <code>name</code> (if a name is not specified, the name of the source column is used to navigate the reference), a cardinality (<code>many</code> attribute), and specifies whether updates to cells of the target column should be propagated automatically (<code>cascadeUpdates</code> attribute) to the respective cells in the source column to preserve referential integrity.</p>"},{"location":"doc/articles/excel/#querying-and-modifying-spreadsheets","title":"Querying and Modifying Spreadsheets","text":"<p>Having specified the configuration document above, we can now query the spreadsheet with EOL as follows.</p> <pre><code>// Returns all students supervised by Matthew Thomas\nStudent.all.select(s|s.supervisor?.lastname = \"Thomas\");\n\n// Returns the modules taught by Daniel Jackson\nModule.all.select(m|\n    Staff.all.exists(s|\n        s.firstname=\"Daniel\" and s.teaches.includes(m)));</code></pre>"},{"location":"doc/articles/excel/#creating-rows","title":"Creating Rows","text":"<p>As discussed above, worksheets are treated as types and rows as their instances. As such, to create a new row in the <code>Student</code> worksheet, EOL's <code>new</code> operation can be used.</p> <pre><code>var student : new Student;</code></pre>"},{"location":"doc/articles/excel/#deleting-rows","title":"Deleting Rows","text":"<p>To delete a row from a worksheet, EOL's <code>delete</code> operator can be used. When a row is deleted, all the rows that contain cells referring to it through cascade-update references also need to be recursively deleted.</p> <pre><code>var student = Student.all.selectOne(s|s.id = \"js502\");\n// deletes row 2 of the Student worksheet\n// also deletes row 3 of the Mark worksheet\ndelete student;</code></pre>"},{"location":"doc/articles/excel/#modifying-cell-values","title":"Modifying Cell Values","text":"<p>If a cell is single-valued, a type-conforming assignment can be used to edit its value. For example, the following listing demonstrates modifying the age and the supervisor of a particular student.</p> <pre><code>var student : Student = ...;\nvar supervisor : Staff = ...;\nstudent.age = 24;\nstudent.supervisor = supervisor;</code></pre> <p>If on the other hand the cell is multi-valued, then its values should be handled as a collection. Adding/removing values from property collections has no effect on the spreadsheet; you need to re-assign values instead.</p> <pre><code>// Moves a module between two members of staff\nvar from : Staff = ...;\nvar to : Staff = ...;\nvar module : Module = ...;\n// Neither of these will work\n// from.teaches.remove(module);\n// to.teaches.add(module);\n// ... but these will\nfrom.teaches = from.teaches.excluding(module);\nto.teaches = to.teaches.including(module);</code></pre> <p>Updating the value of a cell can have side effects to other cells that are linked to it through cascade-update references to preserve referential integrity. For example, updating the value of cell A3 in the <code>Module</code> worksheet, should trigger appropriate updates in cells D2 and F2 of the <code>Staff</code> and <code>Student</code> worksheets respectively.</p>"},{"location":"doc/articles/excel/#validating-and-transforming-spreadsheets","title":"Validating and Transforming Spreadsheets","text":"<p>Of course, we can also validate spreadsheets using EVL, transform them into other models using ETL, and into text using EGL, generate graphical views using Picto etc.</p> <pre><code>context Staff {\n    constraint NotOverloaded {\n        check: self.teaches.size() &lt;= 4\n        message: \"Member of staff\" + self.firstname +\n          \" \" + self.lastname + \" is overloaded\"\n    }\n}</code></pre>"},{"location":"doc/articles/excel/#creating-spreadsheets","title":"Creating Spreadsheets","text":"<p>To create a spreadsheet from scratch (e.g. when it is produced by an ETL transformation), we also need to specify an <code>index</code> for each column in the XML mapping file. Below is an EOL program that creates the spreadsheet above from scratch, and the mapping file for it. The complete example is in Epsilon's Git repo.</p> create-spreadsheet.eolmapping.xml <pre><code>// Create the modules\nvar MSD = new Module(id=\"MSD\", \n  title=\"Modelling and System Design\", term=\"Autumn\");\n\nvar HCI = new Module(id=\"HCI\", \n  title=\"Human Computer Interaction\", term=\"Spring\");\n\nvar RQE = new Module(id=\"RQE\", \n  title=\"Requirements Engineering\", term=\"Spring\");\n\n// Create the staff  \nvar matthew = new Staff(id=\"mt506\", firstname=\"Matthew\",\n  lastname=\"Thomas\", teaches=Sequence{MSD, RQE});\n\nvar matthew = new Staff(id=\"dj503\", firstname=\"Daniel\",\n  lastname=\"Jackson\", teaches=Sequence{HCI});\n\n// Create the students\nvar joe = new Student(id=\"jt501\", firstname=\"Joe\", \n  lastname=\"Thompson\", age=\"23\", supervisor=matthew, modules=Sequence{MSD, RQE});\n\nvar jane = new Student(id=\"js502\", firstname=\"Jane\", \n  lastname=\"Smith\", age=\"22\", supervisor=matthew, modules=Sequence{MSD, HCI});\n\n// Create the marks\nnew Mark(student=joe, module=MSD, mark=62);\nnew Mark(student=jane, module=HCI, mark=74);</code></pre> <pre><code>&lt;spreadsheet&gt;\n&lt;worksheet name=\"Student\"&gt;\n&lt;column index=\"0\" name=\"id\"/&gt;\n&lt;column index=\"1\" name=\"firstname\"/&gt;\n&lt;column index=\"2\" name=\"lastname\"/&gt;\n&lt;column index=\"3\" name=\"age\" datatype=\"integer\"/&gt;\n&lt;column index=\"4\" name=\"supervisor\"/&gt;\n&lt;column index=\"5\" name=\"modules\" many=\"true\"/&gt;\n&lt;/worksheet&gt;\n&lt;worksheet name=\"Mark\"&gt;\n&lt;column index=\"0\" name=\"student\"/&gt;\n&lt;column index=\"1\" name=\"module\"/&gt;    &lt;column index=\"2\" name=\"mark\" datatype=\"integer\"/&gt;\n&lt;/worksheet&gt;\n&lt;worksheet name=\"Staff\"&gt;\n&lt;column index=\"0\" name=\"id\"/&gt;\n&lt;column index=\"1\" name=\"firstname\"/&gt;\n&lt;column index=\"2\" name=\"lastname\"/&gt;\n&lt;column index=\"3\" name=\"teaches\" many=\"true\" delimiter=\",\"/&gt;\n&lt;/worksheet&gt;\n&lt;worksheet name=\"Module\"&gt;\n&lt;column index=\"0\" name=\"id\"/&gt;\n&lt;column index=\"1\" name=\"title\"/&gt;\n&lt;column index=\"2\" name=\"term\"/&gt;\n&lt;/worksheet&gt;\n&lt;reference source=\"Student-&gt;supervisor\"\ntarget=\"Staff-&gt;id\"/&gt;\n&lt;reference source=\"Student-&gt;modules\"\ntarget=\"Module-&gt;id\"/&gt;           &lt;reference source=\"Staff-&gt;teaches\"\ntarget=\"Module-&gt;id\"/&gt;\n&lt;reference source=\"Mark-&gt;module\"\ntarget=\"Module-&gt;id\"/&gt;\n&lt;reference source=\"Mark-&gt;student\"\ntarget=\"Student-&gt;id\"/&gt;                      &lt;/spreadsheet&gt;\n</code></pre>"},{"location":"doc/articles/excel/#working-with-formulas","title":"Working with Formulas","text":"<p>To set the value of a cell to a formula, start its value with <code>=</code> as shown below. The complete example is in Epsilon's Git repo.</p> create-spreadsheet-with-formulas.eolmapping.xml <pre><code>var calc : new Calc;\ncalc.a = 1;\ncalc.b = 2;\ncalc.sum = \"=A2+B2\";\n\ncalc.sum.println(); // Prints 3</code></pre> <pre><code>&lt;spreadsheet&gt;\n&lt;worksheet name=\"Calc\"&gt;\n&lt;column index=\"0\" name=\"a\" datatype=\"integer\"/&gt;\n&lt;column index=\"1\" name=\"b\" datatype=\"integer\"/&gt;\n&lt;column index=\"2\" name=\"sum\" datatype=\"integer\"/&gt;\n&lt;/worksheet&gt;\n&lt;/spreadsheet&gt;\n</code></pre>"},{"location":"doc/articles/excel/#reflective-access","title":"Reflective Access","text":"<p>To iterate over all the worksheets, columns and rows of a speadsheet without referring to them by name, we can use the following statements (assuming that our Excel spreadsheet is named <code>M</code> in the run configuration). Additional methods of interest for this mode of access can be found in the Javadoc of the underlying ExcelModel and SpreadsheetModel classes.</p> <pre><code>// Iterate over all worksheets\nfor (w in M.worksheets) {\n  w.name.println();\n\n  // Iterate over all columns\n  // of the worksheet\n  for (c in w.header.columns) {\n    c.name.println(\"\\t\");\n  }\n\n  // Iterate over all rows\n  // of the worksheet\n  for (r in w.rows) {\n    r.println(\"\\t\");\n  }\n}</code></pre>"},{"location":"doc/articles/excel/#resources","title":"Resources","text":"<ul> <li>This article shows how to use Excel spreadsheets in ANT/Gradle/Maven builds.</li> </ul>"},{"location":"doc/articles/exercises/","title":"MDE Exercises","text":"<p>This article provides a number of exercises you can use to test your knowledge on MDE, EMF and Epsilon.</p>"},{"location":"doc/articles/exercises/#exercise-1-metamodelling-with-ecore","title":"Exercise 1: Metamodelling with Ecore","text":"<p>Write Ecore metamodels (using Emfatic or the graphical Ecore editor) for the following scenarios, and create instances of these metamodels using the reflective EMF tree editor:</p> <ol> <li>All school rooms have a buzzer triggered by a central clock to signal the end of the school day.</li> <li>Political parties, such as the Labour Party, the Conservative party, and the Liberal Democrat party, have both voters and supporters.</li> <li>An undirected graph consists of a set of vertices and a set of edges. Edges connect pairs of vertices.</li> <li>A football league has a set of teams, where each team has a manager and a set of players. A player is a forward, defender, or goalkeeper. The manager cannot be a player.</li> <li>A student is awarded a prize. Each prize is donated by at least one sponsor, e.g., IBM. A prize may be jointly awarded. Each student     must write a letter thanking the sponsors of their prize</li> </ol>"},{"location":"doc/articles/exercises/#exercise-2-constructing-models-programmatically-using-eol","title":"Exercise 2: Constructing models programmatically using EOL","text":"<p>In the previous exercise, you created sample models conforming to your metamodels using the reflective EMF tree editor. In this exercise, you should create the same models, but this time programmatically using EOL.</p>"},{"location":"doc/articles/exercises/#exercise-3-introducing-eol-operations","title":"Exercise 3: Introducing EOL operations","text":"<p>The Office Management System (OMS) is used to manage the rooms available to a company. It keeps track of who is assigned to occupy a room, along with their position in the company. It facilitates providing newly hired employees with offices, and assists employees who are to move from one office to another. Employees have positions, an office (offices are never shared), and know when they started work at the company and when they ended their employment. The OMS keeps track of all employees and rooms. Rooms are either occupied or unoccupied.\\ With the OMS, it is possible to:</p> <ol> <li>hire a new employee and assign them to a room</li> <li>fire an employee and remove them from their office</li> <li>move an employee from one room to another, unoccupied room</li> <li>calculate the set of rooms that are unoccupied (useful for planning)</li> </ol> <p>With this scenario in mind you need to do the following:</p> <ul> <li>Write an Ecore metamodel for the system above</li> <li>Write the body of the following EOL operations that implement 1-4     above<ol> <li>operation Employee hire() { ... }</li> <li>operation Employee fire() { ... }</li> <li>operation Employee move(to:Room) { ... }</li> <li>operation Company getFreeRooms() : Sequence(Room) { ... }</li> </ol> </li> </ul>"},{"location":"doc/articles/exercises/#exercise-4-model-validation-with-evl","title":"Exercise 4: Model validation with EVL","text":"<ul> <li>Construct the Ecore metamodel above and create a sample model that conforms to it using the reflective EMF tree editor.</li> <li>Write the following EVL constraints and evaluate them on your sample model<ol> <li>In the context of class Student, write a constraint stating that a student takes up to 6 modules</li> <li>In the context of class Grade, write a constraint stating that the mark must always be non-negative.</li> <li>In the context of Module, write a constraint stating that every student must have a unique name.</li> <li>In the context of Student, write a constraint that states that the grades for the modules taken by a student must be identical to the grades that the student knows about directly</li> </ol> </li> </ul>"},{"location":"doc/articles/exercises/#exercise-5-model-transformation-with-etl","title":"Exercise 5: Model transformation with ETL","text":"<p>Write an ETL transformation that transforms models conforming to the metamodel of Exercise 4 to models conforming to the metamodel below.</p> <p></p>"},{"location":"doc/articles/exercises/#exercise-6-text-generation-with-egl","title":"Exercise 6: Text generation with EGL","text":"<p>Write an EGL transformation that reads a model conforming to the metamodel of exercise 4 and produces a text file containing the names of all students and the total marks each student has obtained so far.</p>"},{"location":"doc/articles/exercises/#exercise-7-multiple-file-generation-with-egl","title":"Exercise 7: Multiple file generation with EGL","text":"<p>Write an EGL transformation that reads a model conforming to the metamodel of exercise 5 and generates one file per transcript. Each output file should be named after the student with a .txt suffix (e.g. John Doe.txt) and it should contain a list of all the modules and marks of the student.</p>"},{"location":"doc/articles/exercises/#exercise-8-using-ant-to-implement-an-etl-egl-workflow","title":"Exercise 8: Using ANT to implement an ETL-EGL workflow","text":"<p>Use the ANT tasks provided by Epsilon to create an ANT workflow that invokes the ETL transformation of Exercise 5 and then passes the produced model to the EGL transformation of Exercise 7, which in turn generates a set of transcript files.</p>"},{"location":"doc/articles/exercises/#exercise-9-constructing-graphical-editors","title":"Exercise 9: Constructing graphical editors","text":"<p>Create GMF editors for the metamodels you have written in the exercises above using Eugenia.</p>"},{"location":"doc/articles/extended-properties/","title":"Extended Properties","text":"<p>This article demonstrates the extended properties mechanism in EOL (and by inheritance, in all languages in Epsilon). We present the rationale and semantics of extended properties using the following simple metamodel (in Emfatic):</p> <pre><code>package SimpleTree;\n\nclass Tree {\n  attr String name;\n  ref Tree#children parent;\n  val Tree[*]#parent children;\n}</code></pre> <p>Now, what we want to do is to traverse a model that conforms to this metamodel and calculate and print the depth of each Tree in it. We can do this using this simple EOL program:</p> <pre><code>var depths = new Map;\n\nfor (n in Tree.allInstances.select(t|not t.parent.isDefined())) {\n  n.setDepth(0);\n}\n\nfor (n in Tree.allInstances) {\n  (n.name + \" \" + depths.get(n)).println();\n}\n\noperation Tree setDepth(depth : Integer) {\n  depths.put(self,depth);\n  for (c in self.children) {\n    c.setDepth(depth + 1);\n  }\n}</code></pre> <p>Because the <code>Tree</code> <code>EClass</code> doesn't have a depth property, we have to use the <code>depths Map</code> to store the calculated depth of each <code>Tree</code>. Another solution would be to add a depth property to the <code>Tree</code> <code>EClass</code> so that its instances can store such information; but following this approach will soon pollute our metamodel with information of secondary importance.</p> <p>We've often come across similar situations where we needed to attach some kind of information (that is not supported by the metamodel) to particular model elements during model management operations (validation, transformation etc.). Until now, we've been using <code>Maps</code> to achieve this (similarly to what we've done above). However, now, EOL (and all languages built atop it) support non-invasive extended properties which provide a more elegant solution to this recurring problem.</p> <p>An extended property is a property that starts with the <code>~</code> character. Its semantics are quite straightforward: the first time a value is assigned to an extended property of an object (e.g. <code>x.~a := b;</code>), the property is created and associated to the object and the value is assigned to it. Similarly, <code>x.~a</code> returns the value of the property or undefined if the property has not been set on the particular object yet. Using extended properties, we can rewrite the above code (without needing to use a <code>Map</code>) as follows:</p> <pre><code>for (n in Tree.allInstances.select(t|not t.parent.isDefined())) {\n  n.setDepth(0);\n}\n\nfor (n in Tree.allInstances) {\n  (n.name + \" \" + n.~depth).println();\n}\n\noperation Tree setDepth(depth : Integer) {\n  self.~depth = depth;\n  for (c in self.children) {\n    c.setDepth(depth + 1);\n  }\n}</code></pre>"},{"location":"doc/articles/html/","title":"Scripting HTML Documents using Epsilon","text":"<p>In this article we demonstrate how you can create, query and modify HTML documents in Epsilon programs using the HTML driver. All the examples in this article demonstrate using EOL to script HTML documents. However, it's worth stressing that HTML documents are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models or to text), compare and merge your HTML documents.</p>"},{"location":"doc/articles/html/#querying-a-html-document","title":"Querying a HTML document","text":"<p>We use the following <code>sales.html</code> as a base for demonstrating the EOL syntax for querying HTML documents.</p> <pre><code>&lt;html&gt;\n    &lt;body&gt;\n        &lt;table border=\"1\"&gt;\n            &lt;thead&gt;\n                &lt;tr&gt;\n                    &lt;th&gt;Product id&lt;/th&gt;\n                    &lt;th&gt;Unit price&lt;/th&gt;\n                    &lt;th&gt;Quantity&lt;/th&gt;\n                &lt;/tr&gt;\n            &lt;/thead&gt;\n            &lt;tbody&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;P1&lt;/td&gt;\n                    &lt;td&gt;10&lt;/td&gt;\n                    &lt;td&gt;15&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;P2&lt;/td&gt;\n                    &lt;td&gt;8&lt;/td&gt;\n                    &lt;td&gt;12&lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/tbody&gt;\n        &lt;/table&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"doc/articles/html/#queryingmodifying-html-documents-in-eol","title":"Querying/modifying HTML documents in EOL","text":"<p>The HTML driver uses predefined naming conventions to allow developers to programmatically access and modify HTML documents in a concise way. This section outlines the supported conventions in the form of questions and answers followed by relevant examples.</p>"},{"location":"doc/articles/html/#how-can-i-access-elements-by-tag-name","title":"How can I access elements by tag name?","text":"<p>The <code>t_</code> prefix in front of the name of the tag is used to represent a type, instances of which are all the elements with that tag. For instance, <code>t_td.all</code> can be used to get all elements tagged as <code>&lt;td&gt;</code> (table cells) in the document, <code>t_tr.all</code> to retrieve all <code>&lt;tr&gt;</code> elements (table rows) etc. Also, if <code>cell</code> is an element with a <code>&lt;td&gt;</code> tag, then <code>cell.isTypeOf(t_td)</code> shall return true.</p> <pre><code>// Get all &lt;td&gt; elements\nvar cells = t_td.all;\n\n// Get a random table cell\nvar cell = cells.random();\n\n// Check if cell is a td\n// Prints 'true'\ncell.isTypeOf(t_td).println();\n\n// Check if cell is a tr\n// Prints 'false'\ncell.isTypeOf(t_tr).println();</code></pre>"},{"location":"doc/articles/html/#how-can-i-get-the-tag-name-of-an-element","title":"How can I get the tag name of an element?","text":"<p>You can use the <code>.tagName</code> property for this purpose. For instance, if <code>cell</code> is an element tagged as <code>&lt;td&gt;</code>, <code>cell.tagName</code> shall return <code>td</code>. The <code>tagName</code> property is read-only.</p> <pre><code>// Get a random &lt;td&gt; element\nvar cell = t_td.all.random();\n\n// Print its tag\n// Prints 'td'\ncell.tagName.println();</code></pre>"},{"location":"doc/articles/html/#how-can-i-getset-the-attributes-of-an-element","title":"How can I get/set the attributes of an element?","text":"<p>You can use the attribute name as a property of the element object, prefixed by <code>a_</code>. For example, if <code>t</code> is the first table of <code>sales.html</code>, <code>t.a_border</code> will return <code>1</code>. Attribute properties are read/write.</p> <p>In this example, <code>t.a_border</code> will return <code>1</code> as a string. For <code>1</code> to be returned as an integer instead, the <code>i_</code> prefix should be used instead (i.e. <code>t.i_border</code>. The driver also supports the following preffixes: <code>b_</code> for boolean, <code>s_</code> for string (alias of <code>a_</code>) and <code>r_</code> for real values. </p> <pre><code>// Get the one and only table in the document\nvar table = t_table.all.first();\n\n// Prints 11 (the border attribute is retrieved as string)\n(table.a_border + 1).println();\n\n// Prints 2 (the border attribute is retrieved as integer)\n(table.i_border + 1).println();</code></pre>"},{"location":"doc/articles/html/#how-can-i-getset-the-text-of-an-element","title":"How can I get/set the text of an element?","text":"<p>You can use the <code>.text</code> read-write property for this.</p> <pre><code>for (cell in t_td.all) {\n    cell.text.println();\n}</code></pre>"},{"location":"doc/articles/html/#how-do-i-get-the-parent-of-an-element","title":"How do I get the parent of an element?","text":"<p>You can use the <code>.parentNode</code> read-only property to retrieve the element's immediate parent and the <code>.parents.</code> read-only property to retrieve all the ancestors of the element.</p> <pre><code>// Get a random cell\nvar cell = t_td.all.random();\n\n// Print the tag of its parent node\n// Prints 'tr'\ncell.parentNode.tagName.println();\n\n// Print the tags of all its ancestors\n// Prints 'Sequence {tr, tbody, table, body, html}'\ncell.parents.tagName.println();</code></pre>"},{"location":"doc/articles/html/#how-do-i-get-the-children-of-an-element","title":"How do I get the children of an element?","text":"<p>You can use the <code>.children</code> read-only property for this.</p> <pre><code>// Get the &lt;tbody&gt; element\nvar tbody = t_tbody.all.first();\n\n// Iterate through its children\nfor (tr in tbody.children) {\n    // Print the tag of each child\n    tr.tagName.println();\n}</code></pre>"},{"location":"doc/articles/html/#how-do-i-get-child-elements-with-a-specific-tag-name","title":"How do I get child elements with a specific tag name?","text":"<p>Using what you've learned so far, you can do this using a combination of the <code>.children</code> property and the select/selectOne() operations. However, the driver also supports <code>e_</code> and <code>c_</code>-prefixed shorthand properties for accessing one or a collection of elements with the specified name respectively. <code>e_</code> and <code>c_</code> properties are read-only.</p> <pre><code>// Get a random tr\nvar row = t_tr.all.random();\n\n// Get its &lt;td&gt; children using the \n// .children property\nvar cells = row.children.select(a|a.tagName = \"td\");\n\n// Do the same using the shorthand\ncells = row.c_td;\n\n// Get the first td child of the row\nrow.e_td.text.println();</code></pre>"},{"location":"doc/articles/html/#how-do-i-create-an-element","title":"How do I create an element?","text":"<p>You can use the <code>new</code> operator for this. </p> <pre><code>// Check how many &lt;tr&gt; are in the document\n// Prints '3'\nt_tr.all.size().println();\n\n// Creates a new tr element\nvar row = new t_tr;\n\n// Check again\n// Prints '4'\nt_tr.all.size().println();</code></pre>"},{"location":"doc/articles/html/#how-can-i-add-a-child-to-an-existing-element","title":"How can I add a child to an existing element?","text":"<p>You can use the <code>.appendChild(child)</code> operation for this.</p> <pre><code>// Create a new row\nvar row = new t_tr;\n\n// Get the tbody element\nvar tbody = t_tbody.all.first();\n\n// Add the book to the library\ntbody.appendChild(row);</code></pre>"},{"location":"doc/articles/html/#bringing-it-all-together","title":"Bringing it all together","text":"<p>The following snippet computes and prints the total sales revenue.</p> <pre><code>var table = t_table.all.first();\n\nvar sum : Real;\n\n// Iterate only through the rows under tbody\nfor (tr in table.e_tbody.c_tr) {\n    sum = sum + tr.c_td.at(1).getRealValue() * \n        tr.c_td.at(2).getRealValue();\n}\n\n// Prints 246.0\nsum.println();\n\noperation t_td getRealValue() {\n    return self.text.asReal();\n}\n</code></pre>"},{"location":"doc/articles/html/#adding-a-html-document-to-your-launch-configuration","title":"Adding a HTML document to your launch configuration","text":"<p>To add a HTML document to your Epsilon launch configuration, you need to select \"HTML document\" from the list of available model types.</p> <p></p> <p>Then you can configure the details of your document (name, file etc.) in the screen that pops up. To load a HTML document that is not in the Eclipse workspace, untick the \"Workspace file\" check box and provide a full uri for your document (e.g. <code>http://www.google.com</code> or <code>file:/c:/myhtml.html</code>). </p> <p></p>"},{"location":"doc/articles/html/#loading-a-html-document-in-your-ant-buildfile","title":"Loading a HTML document in your ANT buildfile","text":"<p>The following ANT build file demonstrates how you can use ANT to load/store and process HTML documents with Epsilon.</p> <pre><code>&lt;project default=\"main\"&gt;\n&lt;target name=\"main\"&gt;\n\n&lt;epsilon.loadModel name=\"M\" type=\"HTML\"&gt;\n&lt;parameter name=\"readOnLoad\" value=\"true\"/&gt;\n&lt;parameter name=\"storeOnDisposal\" value=\"false\"/&gt;\n&lt;parameter name=\"file\" file=\"sales.html\"/&gt;\n&lt;/epsilon.loadModel&gt;\n\n&lt;epsilon.eol src=\"sales.eol\"&gt;\n&lt;model ref=\"M\"/&gt;\n&lt;/epsilon.eol&gt;\n\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"doc/articles/html/#loading-a-html-document-through-java-code","title":"Loading a HTML document through Java code","text":"<p>The following excerpt demonstrates using HTML models using Epsilon's Java API.</p> <pre><code>EolModule module = new EolModule();\nmodule.parse(new File(\"...\"));\n\nHtmlModel model = new HtmlModel();\nmodel.setName(\"M\");\nmodel.setFile(new File(\"...\"));\nmodel.load();\n\nmodule.getContext().getModelRepository().addModel(model);\nmodule.getContext().setModule(module);\nmodule.execute();\n</code></pre>"},{"location":"doc/articles/html/#loading-a-remote-html-document-in-gradle","title":"Loading a remote HTML document in Gradle","text":"<p>The example below shows a standalone Gradle file (<code>build.gradle</code>) that runs a set of EOL queries (<code>queries.eol</code>) against the HTML behind the Epsilon homepage.</p> build.gradlequeries.eol <pre><code>configurations {\nepsilon\n}\n\nrepositories {\nmaven {\nurl \"https://oss.sonatype.org/content/repositories/snapshots\"\n}\nmavenCentral()\n}\n\ndependencies {\nepsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.3.0-SNAPSHOT'\nepsilon 'org.eclipse.epsilon:org.eclipse.epsilon.emc.html:2.3.0-SNAPSHOT'\n}\n\ntask setupEpsilonTasks {\n// Set up the core Epsilon tasks\nant.taskdef(resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml', classpath: configurations.epsilon.asPath, loaderref: 'epsilon')\n// Set logging level to info so that EOL's println() is not suppressed\nant.lifecycleLogLevel = 'INFO'\n}\n\ntask run {\ndependsOn tasks.setupEpsilonTasks\n// Load the eclipse.org/epsilon webpage as a HTML model\nant.'epsilon.loadModel'(name: 'HTML', type: 'HTML',  impl: 'org.eclipse.epsilon.emc.html.HtmlModel',)\n{ parameter(name: 'uri', value: 'https://www.eclipse.org/epsilon/') }\n\n// Run query.eol against it\nant.'epsilon.eol'(src: 'queries.eol'){ model(ref: 'HTML') }\n}\n</code></pre> <pre><code>// Print the text of all &lt;strong&gt; elements\nfor (s in t_strong.all) {\n    s.text().println();\n}\n\n// Print all links that point to external websites\nfor (link in t_a.all) {\n    if (link.a_href.startsWith(\"http\")) {\n        link.a_href.println();\n    }\n}\n\n// Print the text of all &lt;li&gt; elements which are\n// children of the &lt;ul&gt; that's the first sibling\n// of the \"Why Epsilon?\" &lt;h2&gt;\nvar whyEpsilon = t_h2.all.selectOne(h2|h2.text.startsWith(\"Why Epsilon\"));\nvar ul = whyEpsilon.nextElementSibling();\nfor (li in ul.c_li) {\n    li.text.println();\n}</code></pre>"},{"location":"doc/articles/html/#additional-resources","title":"Additional resources","text":"<p>The Epsilon HTML driver leverages the excellent Jsoup HTML parser. In fact, all elements returned via EOL queries are instances of the <code>org.jsoup.nodes.Element</code> class and as such, all methods of the class can be invoked on them through EOL.</p>"},{"location":"doc/articles/hutn-basic/","title":"Using the Human-Usable Textual Notation (HUTN) in Epsilon","text":"<p>In this article we demonstrate how you can use a textual notation to create models using the Human-Usable Textual Notation (HUTN) implementation provided by Epsilon. Please note that, currently, HUTN works only with EMF, and cannot be used to create models for other modelling technologies, such as MDR or plain XML.</p>"},{"location":"doc/articles/hutn-basic/#getting-started","title":"Getting started","text":"<p>To create a model with HUTN, we first need to define our metamodel. In this example, we'll use the Families metamodel shown below:</p> <p></p> <p>Once we have created your metamodel and registered it with Epsilon, we create a new HUTN document by clicking File\u2192New\u2192Other... and selecting HUTN File. The metamodel nsuri field should contain the namespace URI of our metamodel: families</p> <p></p> <p>Epsilon will initialise a HUTN file for our metamodel (as shown below). We can now specify and then generate our model.</p> <pre><code>@Spec {\n  metamodel \"families\" {\n    nsUri: \"families\"\n  }\n}\n\nfamilies {\n  // Place your model element specifications here\n}\n</code></pre>"},{"location":"doc/articles/hutn-basic/#hutn-syntax","title":"HUTN Syntax","text":"<p>We now briefly describe the HUTN syntax. We can specify an instance of Family using the following HUTN:</p> <pre><code>Family {\n  name: \"The Smiths\"\n  lotteryNumbers: 10, 24, 26, 32, 45, 49\n}\n</code></pre> <p>Note that multi-valued features can be specified using a comma separated list.</p>"},{"location":"doc/articles/hutn-basic/#containment-references","title":"Containment references","text":"<p>Containment references are specified by nesting model element definitions. For example, the following HUTN specifies two members, John and Jane of the Smiths:</p> <pre><code>Family {\n  name: \"The Smiths\"\n  lotteryNumbers: 10, 24, 26, 32, 45, 49\n  members: Person {\n             name: \"John Smith\"\n           }, Person {\n             name: \"Jane Smith\"\n           }\n}\n</code></pre>"},{"location":"doc/articles/hutn-basic/#non-containment-references","title":"Non-containment references","text":"<p>Non-containment references are specified using a HUTN identifier, which is the string appearing in double-quotes as part of an object\\'s declaraton. Below, the second Family has the identifier \"bloggs.\" In the following HUTN, The first family references the second family, using the familyFriends reference:</p> <pre><code>Family {\n  familyFriends: Family \"bloggs\"\n}\n\nFamily \"bloggs\" {}\n</code></pre>"},{"location":"doc/articles/hutn-basic/#cross-model-references","title":"Cross-model references","text":"<p>References to model elements stored in another file are using a URI fragment:</p> <pre><code>Family {\n  familyFriends: Family \"../families/AnotherNeighbourhood.model#/1/\"\n  familyFriends: Family \"../families/AnotherNeighbourhood.model#_swAAYJX5Ed2TbbKclPHPaA\"\n}\n</code></pre> <p>URI fragments can have either a relative (XPath-like) syntax, or use a unique identifier. For example, the first reference above uses a relative syntax to refer to the second (index of 1) Family in the AnotherNeighbourhood.model file. For more information on URI fragments, see section 13.2.1 of the EMF book.</p>"},{"location":"doc/articles/hutn-basic/#shortcuts","title":"Shortcuts","text":"<p>There are some syntactic shortcuts in HUTN, which we now demonstrate.</p> <p>Objects do not have to specify a body, and can instead be terminated with a semi-colon:</p> <pre><code>Family {}\n// is equivalent to:\nFamily;\n</code></pre> <p>Although boolean-valued attributes can be specified using true or false values, they can also be specified as a prefix on the model element definition:</p> <pre><code>Family {\n  nuclear: false\n  migrant: true\n}\n// is equivalent to:\n~nuclear migrant Family;\n</code></pre> <p>Non-containment references can be specified using association blocks or even with an infix notation:</p> <pre><code>Family {\n  familyFriends: Family \"bloggs\"\n}\nFamily \"bloggs\";\n// is equivalent to the following association block\nFamily \"smiths\";\nFamily \"bloggs\";\nfamilyFriends {\n  \"smiths\" \"bloggs\"\n  // More familyFriends can be specified here\n}\n// is equivalent to the following infix notation:\nFamily \"smiths\";\nFamily \"bloggs\";\nFamily \"smiths\" familyFriends Family \"bloggs\";\n</code></pre>"},{"location":"doc/articles/hutn-basic/#generating-a-model-from-hutn","title":"Generating a model from HUTN","text":"<p>When we have finished specifying our HUTN, we can generate a corresponding model. Right-click the HUTN document and select HUTN\u2192Generate Model, as shown below</p> <p></p> <p>Epsilon can automatically generate a model whenever you change your HUTN file. Right-click your project and select HUTN\u2192Enable HUTN Project Nature. This is illustrated in the following screenshot:</p> <p></p>"},{"location":"doc/articles/hutn-basic/#additional-resources","title":"Additional resources","text":"<ul> <li>http://www.omg.org/spec/HUTN/: The OMG HUTN specification.</li> <li>http://dx.doi.org/10.1007/978-3-540-87875-9_18: Our MoDELS/UML 2008 paper on the HUTN implementation provided by Epsilon.</li> </ul>"},{"location":"doc/articles/hutn-compliance/","title":"Compliance of Epsilon HUTN to the OMG Standard","text":"<p>Epsilon HUTN is an implementation of the OMG HUTN standard. Epsilon HUTN implements most of the OMG standard, but there are some differences between the two. This article summaries the similarities and differences between Epsilon HUTN and the OMG HUTN standard.</p> Feature Section of the OMG HUTN Standard Supported in Epsilon HUTN? Details of support in Epsilon HUTN Packages Section 6.2 Yes Classes Section 6.3 Partial Epsilon HUTN provides an extra syntactic shortcut. Not yet supported: parametric attributes and enumeration adjectives. Attributes Section 6.4 Yes Epsilon HUTN corrects a mistake in the HUTN standard. References Sections 6.5 and 6.8 Yes Limitation: Epsilon HUTN only allows absolute references for non-containment features. Classifier-Level Attributes Section 6.6 Yes Data values Section 6.7 Yes Epsilon HUTN supports Ecore (EMF) types, rather than MOF types. Inline configuration Section 6.9 No A configuration model is used instead. Configuration rules Section 5 Partial Currently supported: IdentifierConfig and DefaultValueConfig rules."},{"location":"doc/articles/hutn-compliance/#extra-object-shorthand","title":"Extra Object Shorthand","text":"<p>Epsilon HUTN allows classes with no body to be terminated with a semi-colon rather than with a pair of empty brackets, for example the following are equivalent in Epsilon HUTN:</p> <pre><code>Family \"The Smiths\" {}\nFamily \"The Smiths\";\n</code></pre> <p>This form appears in Figure 6.5 of the HUTN specification, but oddly is not supported in the grammar provided by the HUTN specification.</p>"},{"location":"doc/articles/hutn-compliance/#parametric-attributes","title":"Parametric Attributes","text":"<p>The HUTN specification allows classes to be instantiated with arguments, for example:</p> <pre><code>Coordinate (3.5, 7.3) {}\n</code></pre> <p>The above code assumes that configuration rules have been specified for the parameters of Coordinate.</p> <p>Epsilon HUTN does not currently support this form. Instead, the following code can be used:</p> <pre><code>Coordinate { \n  x: 3.5\n  y: 7.3 \n}\n</code></pre>"},{"location":"doc/articles/hutn-compliance/#enumeration-adjectives","title":"Enumeration Adjectives","text":"<p>The HUTN specification allows objects to be prefixed with enumeration values as adjectives, for example:</p> <pre><code>poodle Dog {}\n</code></pre> <p>The above code assumes that configuration rules have been specified to configure Dog to accept a feature, \"breed,\" as an enumeration adjective.</p> <p>Epsilon HUTN does not currently support this form. Instead, the following code can be used:</p> <pre><code>Dog { \n  breed: poodle \n}\n</code></pre>"},{"location":"doc/articles/hutn-compliance/#potential-error-in-the-omg-hutn-specification","title":"Potential error in the OMG HUTN Specification","text":"<p>Section 6.4 of the OMG HUTN specification appears to contain an error. Grammar rule [20] implies that AttributeName is optional in specifying a KeywordAttribute. However, the semantics of an empty KeywordAttribute or a single tilde as a KeywordAttribute are not defined.</p> <p>Epsilon HUTN ensures that an AttributeName is specified for every KeywordAttribute.</p>"},{"location":"doc/articles/hutn-compliance/#absolute-references","title":"Absolute References","text":"<p>The HUTN specification allows relative referencing for non-containment references. For example:</p> <pre><code>ShapePackage \"triangles\" {\n  Polygon \"my_triangle\" {\n    Coordinate (3.6, 7.3) {}\n    Coordinate (5.2, 7.6) {}\n    Coordinate (9.4, 13) {}\n  }\n}\n\nShapePackage \"lines\" {\n  Polygon \"my_line\" {\n     Coordinate (4.6, 78.3) {}\n     Coordinate (10.4, 1.5) {}\n  }\n\n  Diagram \"my_diagram\" {\n    shapes: \"//triangles/my_triangle\", \"/my_line\"\n  }\n}\n</code></pre> <p>The Diagram object references two Polygons: \"my_triangle\" and \"my line\". The first is referenced with respect to the root of the document (\"//\"), while the second is referenced with respect to the current package (\"/\").</p> <p>Epsilon HUTN does not support relative referencing, and all references are resolved with respect to the diagram root. The \"//\" prefix is omitted:</p> <pre><code>Diagram \"my_diagram\" {\n  shapes: \"my_triangle\", \"my_line\"\n}\n</code></pre>"},{"location":"doc/articles/hutn-configuration/","title":"Customising Epsilon HUTN documents with configuration","text":"<p>In this article we demonstrate how you can use the configuration features of Epsilon HUTN to customise your HUTN documents. For an introduction to modelling with HUTN, please refer to this article.</p>"},{"location":"doc/articles/hutn-configuration/#getting-started","title":"Getting started","text":"<p>Throughout this article, we'll use the following metamodel:</p> <p></p> <p>Suppose we've already constructed a Families model using the following HUTN source:</p> <pre><code>@Spec {\n  metamodel \"families\" {\n    nsUri: \"families\"\n  }\n}\nfamilies {\n  Family {\n    name: \"The Smiths\"\n    familyFriends: Family \"does\", Family \"bloggs\"\n  }\n\n  Family \"does\" {\n    name: \"The Does\"\n    migrant: true\n  }\n\n  Family \"bloggs\" {\n    name: \"The Bloggs\"\n    migrant: true\n  }\n}\n</code></pre> <p>There is some duplication in the HUTN document above. Firstly, the identifiers used to reference Family objects are very similar to the families' names. Secondly, the migrant property is set to true in two of the three Families.</p> <p>A HUTN configuration model can be used to customise the document and reduce the duplication. A HUTN configuration model comprises rules, which customise the HUTN document. The remainder of this article describes how to create and use a configuration model to specify default values for properties and inferred values for identifiers.</p>"},{"location":"doc/articles/hutn-configuration/#creating-a-hutn-configuration-model","title":"Creating a HUTN configuration model","text":"<p>To create a HUTN configuration model, select File\u2192New\u2192Other\u2192Epsilon\u2192EMF Model. Specify a filename ending in .model, select the HUTN config metamodel URI and select Configuration as the root element. The dialogue should then look like this:</p> <p></p> <p>After opening the resulting configuration model, new rules can be added. Right-click the configuration element, select New Child\u2192Rules Default Value Rule and New Child\u2192Rules Identifier Rule to create two rules:</p> <p></p> <p>Default value rules are used to specify a value that will be used when the HUTN source document does not specify a value for a feature. Right-click the newly created default value rule and select Show Properties View. Specify Family as the classifier, migrant as the attribute and true as the value:</p> <p></p> <p>Identifier rules are used to specify an attribute that will be used to identify model elements in the HUTN source document. Right-click the identifier rule and select Show Properties View. Specify Family as the classifier, and name as the attribute:</p> <p></p>"},{"location":"doc/articles/hutn-configuration/#using-a-hutn-configuration-model","title":"Using a HUTN configuration model","text":"<p>To make use of the configuration model, the preamble of the HUTN document must be changed to the following:</p> <pre><code>@Spec {\n  metamodel \"families\" {\n    nsUri: \"families\"\n    configFile: \"FamiliesConfig.model\"\n  }\n}\n</code></pre> <p>Note the extra line that references the configuration model. The value of the configFile attribute is a path relative to the HUTN document.</p> <p>The body of the HUTN document shown at the start of the article can now be rewritten as follows:</p> <pre><code>families {\n  Family {\n    name: \"The Smiths\"\n    familyFriends: Family \"The Does\", Family \"The Bloggs\"\n    migrant: false\n  }\n\n  Family \"The Does\" {}\n  Family \"The Bloggs\" {}\n}\n</code></pre> <p>The identifiers specified for the last two families also specify the value of their name attribute, and so there's no need to explicitly set the name attribute in the body of the Family element. Conversely, the first Family specifies a name (The Smiths), and no identifier. A reference to the first family can use The Smiths as an identifier.</p> <p>Notice also that the migrant attribute values have been removed from the The Does and The Bloggs, as the default value is now true. However, The Smiths must now explicitly state that its migrant value should be false.</p>"},{"location":"doc/articles/hutn-configuration/#additional-resources","title":"Additional resources","text":"<ul> <li>Article: Using HUTN in Epsilon</li> </ul>"},{"location":"doc/articles/in-memory-emf-model/","title":"Working with custom EMF resources","text":"<p>Epsilon's default EMF driver (EmfModel), provides little support for customising the underlying EMF resource loading/persistence process (e.g. using custom resource factories, passing parameters to the resources's load/save methods etc.). If you're invoking an Epsilon program from Java and you need more flexibility in this respect, you can use InMemoryEmfModel instead, which is essentially a wrapper for a pre-loaded EMF resource. A skeleton example follows.</p> <pre><code>Resource resource = ...;\nInMemoryEmfModel model = new InMemoryEmfModel(resource);\nmodel.setName(\"M\");\nEolModule module = new EolModule();\nmodule.parse(...);\nmodule.getContext().getModelRepository().addModel(model);\nmodule.execute();\nresource.save(...);\n</code></pre>"},{"location":"doc/articles/inspect-models-exeed/","title":"Inspecting EMF models with Exeed","text":"<p>Exeed is an extended version of the built-in EMF reflective editor that enables customisation of labels and icons by adding annotations to ECore metamodels. Another feature it provides is the ability to display structural information about the elements of an EMF model. To see the types of all elements in the editor tree as well as the feature in which each element is contained, open your EMF model with Exeed and click <code>Exeed</code> \u2192 <code>Show Structural Info</code>.</p> <p></p> <p>By doing this, the structural information of each element appears next to its label. For example, selecting this option for a GMF .gmfgraph model will make it look like this:</p> <p></p> <p>The red-underlined text shows the type of the element (FigureGallery), the blue-underlined text shows the feature in which it is contained (figures), and the green-underlined text shows the EClass that owns the containing feature (Canvas). So next time you need to open an EMF model with a text editor to inspect its structure by reading the underlying XMI, you may want to consider giving Exeed a try instead.</p>"},{"location":"doc/articles/jdt/","title":"Treating Java code as a model in Epsilon","text":"<p>In version 2.4 of Epsilon we introduced a driver that allows Epsilon languages to query Java code as if it were a model, using the internal representations of the Eclipse Java Development Tools.</p>"},{"location":"doc/articles/jdt/#but-wait-a-second-why-should-i-want-to-do-this","title":"But, wait a second, why should I want to do this?","text":"<p>There are many cases in which you may want to check things about your code. In many cases, a simple text-based search or the code navigation facilities in your IDE might be enough.  For instance, finding a class by name or listing its inherited methods  is something we do all the time.</p> <p>However, what if you want to check something very particular which is not supported by your IDE, and which involves \u201cunderstanding\u201d Java? As an example, suppose that you want to find all the places in your  code where a new programmer may have used <code>==</code> to compare floating-point  numbers. This is a very common mistake that novices make.</p> <p>Text search won\u2019t help you: floating-point expressions and variables can be arbitrarily complex. You will need to parse the Java code, find these <code>==</code> comparisons and reimplement the bits of the Java Language Specification needed to find if one of the two sides is a floating-point expression. Too much work for a quick check you wanted to run on your code!</p> <p>A simpler approach would be to have a tool give you a representation of the code that is close to how the  compiler thinks about it, and that you can go through easily. This is what we mean with having a model. In particular, this example would be solved with our tool by writing this snippet of EOL code:</p> <pre><code>for (expr in InfixExpression.all) {\nif (expr.operator.toString() == \"==\") {\nvar typeLExpr = expr.leftOperand.resolveTypeBinding().qualifiedName;\nvar typeRExpr =\nexpr.rightOperand.resolveTypeBinding().qualifiedName;\nif (typeLExpr == \"float\" or typeRExpr == \"float\") {\nvar cUnit = expr.root.javaElement.elementName;\n(\"WARNING: in \" + cUnit\n+ \", tried to use == with a float: \"\n+ expr).println();\n}\n}\n}\n</code></pre> <p>This query finds the <code>==</code> expressions  in your code, reuses the Eclipse Java Developer Tools to find if one of  the two sides is a <code>float</code> (we\u2019re ignoring <code>double</code> to simplify things), and then reports any problems. It can handle non-trivial cases like method invocations, array accesses and so on. And all in 12 lines of  code.</p>"},{"location":"doc/articles/jdt/#how-does-it-differ-from-other-tools","title":"How does it differ from other tools?","text":"<p>The usual approach when exposing code as a model is to parse the code, dump it as a model (e.g in XMI) and  then treat it as usual. This approach is followed by popular tools such as MoDisco, and it works well in \u201csoftware modernization\u201d situations in which you have a \u201cfrozen\u201d legacy code base. This is the bottom path shown on this figure, starting from \u201cJava code\u201d and going to the cyan nodes:</p> <p></p> <p>However, if you have an active codebase, having to extract a full model every time you make a change is tedious and slows you down. Instead, it\u2019d be better to just have something running in the  background keeping such a model up to date. The good news is that many IDEs already do this for their code navigation facilities, so we can piggyback on it without adding yet another background process to the  user experience.</p> <p>Our EMC JDT driver is exactly that \u2013 we don\u2019t do any big extraction work in advance, so the query starts  running almost immediately. The driver exposes the indices maintained by the Eclipse Java Development Tools, so you can quickly find a class and go through its methods, for instance. If at some point you need more  information than the indices provide, we\u2019ll transparently use the JDT  parser (based on the Java compiler) to fetch things for you. This is  represented as the top path in the above figure, starting at \u201cJava code\u201d and going through the orange nodes.</p>"},{"location":"doc/articles/jdt/#how-is-it-used","title":"How is it used?","text":"<p>With Epsilon and the EMC JDT driver  installed, we create a new \u201cquery.eol\u201d file with our query. For  instance, this one-liner prints how many types we have in our program:</p> <pre><code>TypeDeclaration.all.size.println(\"number of types: \");</code></pre> <p>To run it, we create a standard EOL launch configuration and then select the new \u201cJava\u201d model type: </p> <p></p> <p>We then select a set of Eclipse Java projects to expose as a model: </p> <p></p> <p>You can select multiple projects  through Ctrl+click \u2013 these will all be exposed as a single model. Here I have code for various versions of the JFreeChart library, and I have selected the code for the 1.0.19 version in particular.</p> <p>Click on <code>OK</code>, then <code>Run</code>, and you\u2019ll get your answer:</p> <pre><code>number of types: 1041\n</code></pre>"},{"location":"doc/articles/jdt/#what-other-things-can-i-do","title":"What other things can I do?","text":"<p>While the previous example was very  simple, EOL is a fully-featured language, with support for loops,  user-defined operations, built-in data structures and full access to any Java library. In this paper we showed how to use it to validate your real Java code against a UML diagram, checking if perhaps your UML diagram had gone \u201cstale\u201d. We found that using the EMC JDT driver would be faster than using  MoDisco if you just wanted to do this check repeatedly across multiple  releases.</p> <p>Essentially, we expose the JDT document object model (DOM) directly through Epsilon, so if you want to access all instances of the JDT DOM TypeDeclaration class, you write <code>TypeDeclaration.all</code> as we did above. We also provide a few  convenient shorthands. For a TypeDeclaration t, you can use these:</p> <ul> <li><code>t.public</code>,  <code>t.protected</code>, <code>t.private</code>, <code>t.static</code>, <code>t.abstract</code>, <code>t.final</code>: these are  true/false depending on whether the underlying type has this modifier.</li> <li><code>t.name</code>: this exposes the name of the underlying type (which usually requires going through multiple fields).</li> </ul> <p>We also expose the JDT index so you  can quickly find a type by name: in fact, it\u2019s the same index you use  when pressing <code>CTRL+SHIFT+T</code> on Eclipse. To do so, you can use one of  these:</p> <ul> <li><code>TypeDeclaration.all.select(td|td.name=\"someClass\")</code> finds a type by name and returns it as a collection of TypeDeclarations with access to every detail within those types.</li> <li><code>TypeDeclaration.all.search(td|td.name=\"someClass\")</code> does the same, but it only returns the raw index entry (an instance of IType), which is much faster but has less information.</li> </ul>"},{"location":"doc/articles/jdt/#applications","title":"Applications","text":"<p>In this example, we use the JDT driver and Picto to generate PlantUML diagrams from existing Java code on the fly.</p> <p></p> jcd.flexmijcd.pictojcd.egxcd.egl <pre><code>&lt;?nsuri jcd?&gt;\n&lt;_&gt;\n&lt;diagram name=\"Kitchen Sink\"&gt;\n&lt;include name=\"Employee\"/&gt;\n&lt;include name=\"Product\"/&gt;\n&lt;include name=\"Order\"/&gt;\n&lt;include name=\"OrderItem\"/&gt;\n&lt;include name=\"Person\"/&gt;\n&lt;include name=\"Shippable\"/&gt;\n&lt;include name=\"Address\"/&gt;\n&lt;include name=\"Customer\"/&gt;\n&lt;constraint below=\"Order\" above=\"Employee\"/&gt;\n&lt;constraint below=\"OrderItem\" above=\"Product\"/&gt;\n&lt;constraint above=\"Customer\" below=\"Order\"/&gt;\n&lt;constraint right=\"Customer\" left=\"Address\"/&gt;\n&lt;/diagram&gt;\n\n&lt;diagram name=\"Employee and Person\"&gt;\n&lt;preamble&gt;\nskinparam monochrome true\n        skinparam handwritten true\n        &lt;/preamble&gt;\n&lt;postamble&gt;\nnote left of Employee: People working for our company\n        note right of Person::\"lastName : String\"\n        The person's last name\n        end note\n        &lt;/postamble&gt;\n&lt;include name=\"Employee\"/&gt;\n&lt;include name=\"Person\"/&gt;\n&lt;/diagram&gt;\n\n&lt;diagram name=\"Employee but not Person\"&gt;\n&lt;include name=\"Employee\"/&gt;\n&lt;/diagram&gt;\n\n&lt;diagram name=\"Order and Shippable\"&gt;\n&lt;include name=\"Order\"/&gt;\n&lt;include name=\"Shippable\"/&gt;\n&lt;constraint right=\"Order\" left=\"Shippable\"/&gt;\n&lt;/diagram&gt;\n\n&lt;diagram name=\"Order but not Shippable\"&gt;\n&lt;include name=\"Order\"/&gt;\n&lt;/diagram&gt;\n&lt;/_&gt;\n</code></pre> <pre><code>&lt;?nsuri picto?&gt;\n&lt;picto format=\"egx\" transformation=\"jcd.egx\" standalone=\"true\"&gt;\n&lt;model type=\"EMF\"&gt;\n&lt;parameter name=\"name\" value=\"JCD\"/&gt;\n&lt;parameter name=\"metamodelUri\" value=\"jcd\"/&gt;\n&lt;parameter name=\"modelFile\" file=\"jcd.flexmi\"/&gt;\n&lt;/model&gt;\n&lt;model type=\"JDT\"&gt;\n&lt;parameter name=\"name\" value=\"JDT\"/&gt;\n&lt;parameter name=\"projects\" value=\"org.eclipse.epsilon.examples.jdt.picto\"/&gt;\n&lt;/model&gt;    &lt;/picto&gt;\n</code></pre> <pre><code>rule Diagram2PlantUML \n    transform diagram : JCD!Diagram {\n\n    template : \"cd.egl\"\n\n    parameters : Map{\n        \"path\" = Sequence{diagram.name},\n        \"format\" = \"puml\"\n    }\n\n}</code></pre> <pre><code>@startuml\nhide circle\n[%diagram.populate();%]\n[%=diagram.preamble%]\n[%for (class in diagram.types.select(t|t.isTypeOf(Class))){%]\nclass [%=class.name%] {\n    [%for (attribute in class.attributes){%]\n    [%=attribute.name%] : [%=attribute.type%]\n    [%}%]\n    [%for (method in class.methods) { %]\n    [%=method.getLabel()%]\n    [%}%]\n}\n\n[%for (reference in class.references){%]\n[%=reference.getEdge()%]\n[%}%]\n\n[%for (superType in class.superTypes){%]\n[%=getEdge(class, superType)%]\n[%}%]\n\n[%}%]\n[%=diagram.postamble%]\n@enduml\n\n[%\noperation JCD!Diagram populate() {\n\n    // Resolve type declaration from includes and create types\n    for (include in self.includes) {\n        var typeDeclaration = JDT!TypeDeclaration.all.select(td|td.name = include.name).first();\n        if (typeDeclaration.isDefined()) {\n            var class = new JCD!Class;\n            class.name = typeDeclaration.name.identifier;\n            self.types.add(class);\n            class.~typeDeclaration = typeDeclaration;\n        }\n    }\n\n    // Populate supertypes\n    for (class in self.types.select(t|t.isTypeOf(JCD!Class) and t.~typeDeclaration.isDefined())) {\n        if (class.~typeDeclaration.getSuperclassType().isDefined()) {\n            class.superTypes.addAll(self.types.select(c:JCD!Class|c.name = class.~typeDeclaration.getSuperclassType().toString()/*name.identifier*/));\n        }\n\n        for (interface in class.~typeDeclaration.superInterfaceTypes()) {\n            class.superTypes.addAll(self.types.select(c:JCD!Class|c.name = interface.name.identifier)); \n        }\n    }\n\n    // Populate class attributes, references and methods\n    for (class in self.types.select(t|t.isTypeOf(JCD!Class) and t.~typeDeclaration.isDefined())) {\n        for (field in class.~typeDeclaration.fields) {\n            if (not field.getType().isVisible(diagram)) {\n                var attribute = new JCD!Attribute;\n                attribute.name = field.getName();\n                attribute.type = field.getType().getLabel();\n                attribute.many = field.isCollection();\n                class.attributes.add(attribute);\n            }\n            else {\n                var reference = new JCD!Reference;\n                reference.name = field.getName();\n                reference.type = diagram.types.selectOne(c|c.name = field.getType().name.identifier);\n                reference.many = field.isCollection();\n                class.references.add(reference);\n            }\n        }\n\n        // Populate class methods\n        for (methodDeclaration in class.~typeDeclaration.methods) {\n            var method = new JCD!Method;\n            method.name = methodDeclaration.name.identifier;\n            for (formalParameter in methodDeclaration.parameters()) {\n                var parameter : new JCD!Parameter;\n                parameter.name = formalParameter.name.identifier;\n                parameter.type = formalParameter.type.getLabel();\n                method.parameters.add(parameter);\n            }\n            //method.type = methodDeclaration.returnType2.getLabel();\n            class.methods.add(method);\n        }\n\n    }\n\n\n}\n\n/**\n * Produces a generalization edge, taking into account contstraints\n */ \noperation getEdge(class:JCD!Class, superClass:JCD!Class) {\n    var diagram = class.eContainer();\n\n    if (diagram.constraints.exists(c|c.above = class.name and c.below = superClass.name)) {\n        return class.name + \" --|&gt; \" + superClass.name;\n    }\n    else if (diagram.constraints.exists(c|c.left = class.name and c.right = superClass.name)) {\n        return class.name + \" -|&gt; \" + superClass.name;\n    }\n    else if (diagram.constraints.exists(c|c.left = superClass.name and c.right = class.name)) {\n        return superClass.name + \" &lt;|- \" + class.name;\n    }\n    else {\n        return superClass.name + \" &lt;|-- \" + class.name;\n    }\n}\n\n/*\n * Prdoduces a reference edge, taking into account constraints\n */\noperation JCD!Reference getEdge() {\n    var diagram = self.eContainer().eContainer();\n    var label = \" \\\" \" + self.name + (self.many ? \"*\" : \"\") + \"\\\" \";\n\n    if (diagram.constraints.exists(c|c.above = self.eContainer().name and c.below = self.type.name)) {\n        return self.eContainer().name + \" -down-&gt; \" + self.type.name + \" : \" + label;\n    }\n    else if (diagram.constraints.exists(c|c.below = self.eContainer().name and c.above = self.type.name)) {\n        return self.eContainer().name + \" -up-&gt; \" + self.type.name + \" : \" + label;\n    }\n    else if (diagram.constraints.exists(c|c.right = self.eContainer().name and c.left = self.type.name)) {\n        return self.eContainer().name + \" -left-&gt; \" + self.type.name + \" : \" + label;\n    }\n    else {\n        return self.eContainer().name + \" -right-&gt; \" + self.type.name + \" : \" + label;\n    }\n}\n\noperation JDT!FieldDeclaration getName() {\n    return self.fragments.at(0)/*VariableDeclarationFragment*/.name.identifier;\n}\n\noperation JDT!ParameterizedType getLabel() {\n    return self.type.name + \"&lt;\" + self.typeArguments.collect(ta|ta.getLabel()).concat(\", \") + \"&gt;\";\n}\n\noperation JDT!WildcardType getLabel() {\n    return self.toString();\n}\n\noperation JDT!SimpleType getLabel() {\n    return self.name.identifier;\n}\n\noperation JDT!PrimitiveType getLabel() {\n    return self.toString();\n}\n\noperation JDT!FieldDeclaration getType() {\n    if (self.isCollection()) {\n        return self.type.typeArguments.first();\n    }\n    else {\n        return self.type;\n    }\n}\n\noperation JDT!FieldDeclaration isCollection() {\n    return self.type.isTypeOf(JDT!ParameterizedType) \n        and self.type.typeArguments.size() == 1 \n        and self.type.type.name.identifier = \"List\"; /*FIXME*/\n}\n\noperation JDT!Type isVisible(diagram : JCD!Diagram) {\n    if (not self.isTypeOf(JDT!SimpleType)) return false;\n    return diagram.types.name.includes(self.name.identifier);\n}\n\noperation JCD!Method getLabel() {\n    var label = self.name + \"(\" + self.parameters.collect(p|p.name + \":\" + p.type).concat(\", \") + \")\";\n    if (self.type.isDefined() and self.type != \"void\") label += \" : \" + self.type;\n    return label;\n}\n\n%]</code></pre>"},{"location":"doc/articles/json-emc/","title":"Scripting JSON documents using Epsilon","text":"<p>This article discusses how to create, query and modify JSON documents in Epsilon programs using the JSON driver. The examples will only cover some of the Epsilon languages, but the JSON driver supports all the languages in Epsilon.</p> <p>As of Epsilon 2.5.0, the JSON driver can:</p> <ul> <li>Read and write local JSON files.</li> <li>Read JSON documents accessible via a URI (e.g. <code>http(s)://</code>, <code>file:/</code>, <code>jar:/</code>).</li> </ul>"},{"location":"doc/articles/json-emc/#querying-a-json-document","title":"Querying a JSON document","text":"<p>For this first example, we will query the GitHub REST API via HTTP, asking it about the Eclipse Epsilon project, parse its JSON response, and produce a short text report in Markdown. This example is available from the Epsilon GitHub repository.</p> <p>Here is an excerpt of the JSON document (omitted parts are in <code>...</code>):</p> <pre><code>{\n...\n\"description\": \"Epsilon is a family of Java-based scripting languages for automating common model-based software engineering tasks, such as code generation, model-to-model transformation and model validation, that work out of the box with EMF (including Xtext and Sirius), UML (including Cameo/MagicDraw), Simulink, XML and other types of models.\",\n...\n\"ssh_url\": \"git@github.com:eclipse/epsilon.git\",\n\"clone_url\": \"https://github.com/eclipse/epsilon.git\",\n...\n\"stargazers_count\": 27,\n\"watchers_count\": 27,\n...\n\"forks_count\": 8,\n...\n\"license\": {\n\"key\": \"epl-2.0\",\n\"name\": \"Eclipse Public License 2.0\",\n\"spdx_id\": \"EPL-2.0\",\n\"url\": \"https://api.github.com/licenses/epl-2.0\",\n\"node_id\": \"MDc6TGljZW5zZTMy\"\n},\n...\n\"topics\": [\n\"domain-specific-languages\",\n\"model-based-software-engineering\",\n\"model-driven-engineering\"\n],\n...\n}\n</code></pre>"},{"location":"doc/articles/json-emc/#basic-types-in-json-based-models","title":"Basic types in JSON-based models","text":"<p>The JSON driver implements two types for its models: <code>JSONObject</code>s and <code>JSONArray</code>s. A <code>JSONObject</code> is a Java Map, and a <code>JSONArray</code> is a Java List. You can use all their methods as usual (e.g. <code>Map#keySet</code>, or <code>List#size</code>), as well as the EOL methods for collections and maps. In addition, you can refer to the <code>x</code> property of a <code>JSONObject</code> object <code>o</code> with the usual syntax <code>o.x</code>, both for reading and setting it.</p> <p>A JSON model has one root element, which most of the time will be a <code>JSONObject</code> or a <code>JSONArray</code> (although it could be a simple scalar, like an integer). If the name of the model is <code>M</code>, its root element can be accessed via <code>M.root</code>.</p>"},{"location":"doc/articles/json-emc/#example-queries","title":"Example queries","text":"<p>Here are some queries we can run on the above document:</p> <ul> <li>Reading the description: <code>M.root.description</code></li> <li>Reading the SSH URL: <code>M.root.ssh_url</code></li> <li>Reading the license URL: <code>M.root.license.url</code></li> <li>Counting the number of topics: <code>M.root.topics.size()</code></li> </ul>"},{"location":"doc/articles/json-emc/#example-egl-template","title":"Example EGL template","text":"<p>Suppose we have this EGL template:</p> <pre><code># Eclipse Epsilon\n\n([%=M.root.stargazers_count%] stars, [%=M.root.watchers_count%] watchers, [%=M.root.forks_count%] forks)\n\n[%=M.root.description%]\n\n* Clone via HTTPS: [%=M.root.clone_url%]\n* Clone via SSH: [%=M.root.ssh_url%]\n\n## License\n\nEpsilon is licensed under the [[%=M.root.license.name%]]([%=M.root.license.url%]).\n\n## Topics\n\n[% for (topic in M.root.topics) {%]\n* [%=topic.ftuc()%]\n[% } %]</code></pre> <p>With the above JSON document, it will produce this output:</p> <pre><code># Eclipse Epsilon\n\n(27 stars, 27 watchers, 8 forks)\n\nEpsilon is a family of Java-based scripting languages for automating common model-based software engineering tasks, such as code generation, model-to-model transformation and model validation, that work out of the box with EMF (including Xtext and Sirius), UML (including Cameo/MagicDraw), Simulink, XML and other types of models.\n\n* Clone via HTTPS: https://github.com/eclipse/epsilon.git\n* Clone via SSH: git@github.com:eclipse/epsilon.git\n\n## License\n\nEpsilon is licensed under the [Eclipse Public License 2.0](https://api.github.com/licenses/epl-2.0).\n\n## Topics\n\n* Domain-specific-languages\n* Model-based-software-engineering\n* Model-driven-engineering\n</code></pre>"},{"location":"doc/articles/json-emc/#disambiguation-between-java-methods-and-json-properties","title":"Disambiguation between Java methods and JSON properties","text":"<p>In some cases, the name of the property may clash with one of the Java <code>Map</code> / <code>List</code> methods. For instance, consider this JSON document:</p> <pre><code>{\"keySet\": [1, 2, 3]}\n</code></pre> <p>In this case, <code>Model.root.keySet()</code> would invoke the Map <code>keySet</code> method (returning a set containing the <code>\"keySet\"</code> string), rather than refer to the value of the <code>keySet</code> property in the root object.</p> <p>To resolve such clashes, the JSON driver supports adding a <code>p_</code> prefix to refer to the original JSON property: <code>Model.root.p_keySet</code> would return the <code>JSONArray</code> containing the three integers shown in the document (1, 2, and 3).</p>"},{"location":"doc/articles/json-emc/#creating-and-modifying-json-documents","title":"Creating and modifying JSON documents","text":"<p>Modifying the contents of a JSON model can be done through regular assignments in EOL, using <code>Model.root</code> and <code>object.property</code> as usual.</p>"},{"location":"doc/articles/json-emc/#initial-example-author-json-document","title":"Initial example: author JSON document","text":"<p>For instance, suppose we run this EOL script with a JSON model called <code>M</code>:</p> <pre><code>M.root = new JSONObject;\nM.root.name = 'Author Name';\nM.root.email = 'author@example.com';\nM.root.id = 1234;\n\nM.root.accounts = Sequence { 123, 456 };</code></pre> <p>This will produce the following JSON document:</p> <pre><code>{\n\"name\": \"Author Name\",\n\"email\": \"author@example.com\",\n\"id\": 1234,\n\"accounts\": [123, 456]\n}\n</code></pre> <p>The first line set up the root object of the JSON document, and the remaining lines set various fields on the object. The last line assigned a <code>Sequence</code> to the accounts of the root object: this is OK because it did not contain any JSON arrays or objects. Otherwise, we would need to use a <code>JSONArray</code> instead, because the JSON driver needs to keep track of the JSON model that owns each <code>JSONArray</code> and <code>JSONObject</code>, and only <code>JSONArray</code> and <code>JSONObject</code> instances can track this information.</p>"},{"location":"doc/articles/json-emc/#author-json-document-with-detailed-accounts","title":"Author JSON document with detailed accounts","text":"<p>Suppose that we want <code>M.root.accounts</code> to contain not just account IDs, but rather entire objects with their own fields. In that case, we need to use a <code>JSONArray</code> as mentioned before:</p> <pre><code>M.root = new JSONObject;\nM.root.name = 'Author Name';\nM.root.email = 'author@example.com';\nM.root.id = 1234;\n\nM.root.accounts = new JSONArray;\n\nvar firstAccount = new JSONObject;\nfirstAccount.id = 123;\nfirstAccount.followers = 10;\n\nvar secondAccount = new JSONObject;\nsecondAccount.id = 456;\nsecondAccount.followers = 20;\n\nM.root.accounts.add(firstAccount);\nM.root.accounts.add(secondAccount);</code></pre> <p>The above EOL program would produce this JSON document:</p> <pre><code>{\n\"name\": \"Author Name\",\n\"email\": \"author@example.com\",\n\"id\": 1234,\n\"accounts\": [\n{\"id\": 123, \"followers\": 10},\n{\"id\": 456, \"followers\": 20}\n]\n}\n</code></pre> <p>As noted above, the only difference for JSON documents is that we need to create <code>JSONArray</code>s when we want to store a collection of JSON arrays or objects.</p>"},{"location":"doc/articles/json-emc/#reuse-of-objects-in-json-documents","title":"Reuse of objects in JSON documents","text":"<p>One important detail when creating JSON documents is that the same JSON object or array could be referenced from multiple locations. Changing that object or array would affect every location in the JSON document which references it.</p> <p>As an example, consider this EOL script:</p> <pre><code>M.root = new JSONObject;\nM.root.x = new JSONObject;\nM.root.y = M.root.x;\n\n// This new key will also be visible from M.root.y.a\nM.root.x.a = 1;</code></pre> <p>The above EOL script will produce this JSON document:</p> <pre><code>{\n\"x\": {\"a\": 1},\n\"y\": {\"a\": 1}\n}\n</code></pre> <p>Since both <code>M.root.x</code> and <code>M.root.y</code> referenced the same JSON object, the last line of the EOL script affected both locations in the produced JSON file.</p> <p>If this is undesirable, JSON models provide a <code>deepClone</code> method which can produce a standalone clone of any <code>JSONObject</code> or <code>JSONArray</code>. As an example, here is an EOL script which sets <code>M.root.y</code> to a deep clone of <code>M.root.x</code>:</p> <pre><code>M.root = new JSONObject;\nM.root.x = new JSONObject;\nM.root.y = M.deepClone(M.root.x);\n\n// This new key will NOT be visible from M.root.y\nM.root.x.a = 1;\n</code></pre> <p>Since <code>M.root.y</code> is not the same object anymore, the last line only affects <code>M.root.x</code>, and the script produces this JSON document:</p> <pre><code>{\n\"x\": {\"a\": 1},\n\"y\": {}\n}\n</code></pre>"},{"location":"doc/articles/json-emc/#managing-the-model-root-in-declarative-epsilon-scripts","title":"Managing the model root in declarative Epsilon scripts","text":"<p>When writing Epsilon scripts that create JSON objects and arrays using declarative strategies (e.g. ETL), it will be necessary to set the root of the JSON model in a <code>post</code> block. This is because in a JSON model, creating a <code>JSONObject</code> or a <code>JSONArray</code> will not automatically add it to the contents of the model.</p> <p>As an example, here is an ETL script which transforms EMF models that conform to a <code>Tree</code> metamodel into JSON documents:</p> <pre><code>post {\n  var sourceRoots = Source.getResource().contents; \n  Target.root = sourceRoots.get(0).equivalent();\n}\n\nrule TreeToObject transform t: Source!Tree to o: Target!JSONObject {\n   o.label = t.label;\n   o.children = new Target!JSONArray;\n   o.children.addAll(t.children.equivalent());\n}</code></pre> <p>If we did not include the <code>post</code> block, the <code>JSONObject</code>s would be created but <code>Target.root</code> would never be set, so we would end up with just <code>null</code> in the JSON document.</p> <p>The above script will first transform every <code>Tree</code> to a <code>JSONObject</code>, then assign their labels and children, and finally run the <code>post</code> block which will assign the <code>JSONObject</code> equivalent to the root <code>Tree</code> as the root of the <code>Target</code> JSON document.</p>"},{"location":"doc/articles/labsupdatesite/","title":"Publishing your project to the Epsilon Labs Update Site","text":"<p>In this article we explain the steps required to publish your Epsilon related project in the Epsilon Labs update site.</p>"},{"location":"doc/articles/labsupdatesite/#general-recommendations","title":"General Recommendations","text":"<p>As part of the process you will configure your project to be under continuous integration (CI) which is automatically triggered when you push changes to the main branch of your project's git repository. For this reason it is recommended that you create a develop branch in which you make frequent commits/pushes and only merge changes to the main branch when you want to release a new version (you might be interested in GitFlow)</p>"},{"location":"doc/articles/labsupdatesite/#creating-feature-plugins","title":"Creating Feature Plugins","text":"<p>In the Eclipse world, a feature is a group of one or more plugins that offer a specific functionality within Eclipse. For example, the Epsilon Core feature groups all the plugins that provide support for the core Epsilon languages (EOL, ETL, EGL, etc.) and drivers (CSV, XML, Bibtext, etc.). In order to publish your project you need to create feature plugins. As a minimum you would need to provide two features: one for the base functionality and other for the developer tools. The developer tools are the plugins that provide UI contributions (menus, launchers, etc.). For example, the JDBC project provides these two features (developer tools plugins and features should use the dt suffix):</p> <ul> <li>org.eclipse.epsilon.emc.jdbc.mysql.feature</li> <li>org.eclipse.epsilon.emc.jdbc.mysql.feature.dt</li> </ul>"},{"location":"doc/articles/labsupdatesite/#feature-information","title":"Feature Information","text":"<p>NOTE: Correctly fill the feature information. This information is displayed within the Install New Software tool and therefore the first point of contact between your project and the user.</p> <p>Feature Description</p> <ul> <li>Optional URL: Leave blank</li> <li>Text: Meaningful information about the plugins</li> </ul> <p>Copyright Notice</p> <ul> <li>Optional URL: Leave blank</li> <li> <p>Text:</p> <p>Copyright \u00a9 2008 The University of York. All rights reserved.  Contributors:  <p>License Agreement Use the appropriate license agreement. This depends on the libraries you are using.</p> <p>Sites to visit Any important sites of interest (e.g. Epsilon's website)</p>"},{"location":"doc/articles/labsupdatesite/#group-your-projects-plugins","title":"Group your project's plugins","text":"<p>Add each of your project plugins to the relevant feature. Remember that your dt plugins should go in your dt (development tools) feature.</p>"},{"location":"doc/articles/labsupdatesite/#create-a-sitexml","title":"Create a site.xml","text":"<p>An update site contains information about the features and plugins that can be installed from it. In order to the EpsilonLabs Updatesite to know what features/plugins you provide you must add this information to a site.xml file. You can find a template here or in the EpsilonLabs update site repository (template folder). In a nutshell, site.xml lists the features of your project and provides a category (a logical grouping of features) for your project.</p>"},{"location":"doc/articles/labsupdatesite/#set-up-ci","title":"Set up CI","text":"<p>Go to CircleCi and log in using your Github credentials (for simple configuration of the project).</p>"},{"location":"doc/articles/labsupdatesite/#add-your-project-to-circleci","title":"Add your project to CircleCI","text":"<ul> <li>In the top left corner select the epsilonlabs organization.</li> <li>Click on Add Project</li> <li>Click on Setup Project</li> <li>In Language select Maven(Java)</li> <li>Skip the circli configuration (we will show you this next)</li> <li>Click on Start Building</li> </ul>"},{"location":"doc/articles/labsupdatesite/#set-up-epsilonlabs-build-trigger","title":"Set up EpsilonLabs build Trigger","text":"<p>Open the epsilonlabs CircleCI project</p> <ul> <li>Go to settings</li> <li>Go to API Permisssions</li> <li>Copy the token value of the TRIGGER_TOKEN</li> </ul> <p>Go to your project</p> <ul> <li>Go to settings</li> <li>Go to Environment Variables</li> <li>Add variable: Name: TRIGGER_BUILD, Value: Paste the TRIGGER_TOKEN value</li> </ul>"},{"location":"doc/articles/labsupdatesite/#configure-circleci-for-your-project","title":"Configure CircleCI for your project","text":"<ul> <li>Create a .circleci folder in the root of your project</li> <li>Create a new config.yml file</li> </ul> <p>Use the template provided (here or in the EpsilonLabs updatesite repository) and make sure you add an store_artifacts entry for each plugin and feature JAR. Note: The path information points to the target folder which will be populated by maven (see next).</p>"},{"location":"doc/articles/labsupdatesite/#use-maven-tycho-to-build-your-project","title":"Use Maven + Tycho to build your project","text":"<p>We will use a pom-less configuration to build your project with maven and Tycho. Create a POM for your project. If you divide your projects into plugins, features, tests folders (btw, you should) you need to create a parent pom, and then a pom for each folder. A pom-less build avoids having a pom for each project, but still needs the structure ones. Use the provided template(s), change the artifact id and add your plugins and features to the modules section. The templates are here or in the EpsilonLabs updatesite repository) To enable the pomless build, copy the extensions.xml (or in the repository) file to a .mvn folder in your project.</p>"},{"location":"doc/articles/labsupdatesite/#local-maven-build","title":"Local maven build","text":"<p>Install Maven and build your project to test that your poms are correct. You should also make sure that any tests you have coded are executed as part of the Maven build.</p> <pre><code>  mvn clean install\n</code></pre> <p>Check that the required JARs have been created in the target folder.</p>"},{"location":"doc/articles/labsupdatesite/#test-your-ci-build","title":"Test your CI build","text":"<p>Merge your repository changes (new files) to your main branch and push to GitHub. This should trigger a new build. Go to CircleCI and verify that your build completed without errors. CircleCI will simply execute a maven build so if your local build succeeded the CircleCi should too.</p> <p>Additionally check that all the JARs have been stored as artifacts. In your project's build information page click on the Artifacts tab:</p> <p></p>"},{"location":"doc/articles/labsupdatesite/#add-your-project-to-the-epsilonlabs-update-site","title":"Add your project to the EpsilonLabs update site","text":"<p>Fork the EpsilonLabs update site repository and add your project in two places:</p> <p>Add a new entry(line) to the projects.txt file. The line should have your project name (the name of the project in GitHub) and the target platform information. In most cases this can be Any. If you only support a specific platform you should provide the correct values.</p> <p>Add a new local repository to the updasite's root pom (the project name should match the entry in the projects file):</p> <pre><code>&lt;repository&gt;\n&lt;id&gt;epsilonlabs-{project}&lt;/id&gt;\n&lt;url&gt;file:///${main.basedir}/repository/{project}}&lt;/url&gt;\n&lt;layout&gt;p2&lt;/layout&gt;\n&lt;/repository&gt;\n</code></pre> <ul> <li>Make a pull request to the main EpsilonLabs update site project.</li> <li>After your request has been merged you should see your project in the update site.</li> </ul>"},{"location":"doc/articles/labsupdatesite/#additional-resources","title":"Additional resources","text":"<ul> <li>Eclipse p2 publisher</li> </ul>"},{"location":"doc/articles/lambda-expressions/","title":"Native lambda expressions","text":"<p>Whilst EOL has many useful declarative operations built in, some applications and developers may benefit from using alternative implementations, such as the Java Streams API.</p> <p>Epsilon now allows you to invoke functional interfaces using EOL first-order operation syntax. Provided that the method being invoked takes one or more functional interfaces as a parameter and the correct number of parameters are supplied to each interface, this integration should work seamlessly as with regular first-order operation call expressions. For lambda expressions which do not require a parameter, you can either omit the parameter, use <code>null</code> or <code>_</code> in place of the parameter, like so:</p> <pre><code>  var optional = Native(\"java.util.stream.IntStream\")\n    .range(0, 16)\n    .filter(i | i / 4 &gt;= 2)\n    .findFirst();\n\n  optional.orElse(64/4);  // No lambda - literal value always calculated even if not present.\n  optional.orElseGet(null | someIntensiveCalculation());  // Evaluation only occurs if no value is present.\n  optional.orElseThrow(| new Native(\"org.eclipse.epsilon.eol.exceptions.EolRuntimeException\"));</code></pre> <p>Here is an example of how one could use Java Streams and the equivalent approach using EOL (i.e. without native delegation):</p> <pre><code>  var Collectors = Native(\"java.util.stream.Collectors\");\n\n  var testData = Sequence{-1024..1024};\n\n  var positiveOddsSquaredEol = testData\n    .select(i | i &gt;= 0 and i.mod(2) &gt; 0)\n    .collect(i | i * i)\n    .asSet();\n\n  var positiveOddsSquaredJava = testData.stream()\n    .filter(i | i &gt;= 0 and i.mod(2) &gt; 0)\n    .map(i | i * i)\n    .collect(Collectors.toSet());\n\n  assertEquals(positiveOddsSquaredEol, positiveOddsSquaredJava);</code></pre> <p>One benefits of using Streams is lazy evaluation, which allows you to chain a series of operations without executing the entire pipeline on all elements. This can be more efficient since streams are not materialised in intermediate operations, unlike EOL first-order operations which always return a collection and are thus evaluated eagerly. As with built-in EOL operations, Streams also support parallel execution, although this must be explicitly specified with the <code>.parallel()</code> property on the stream.</p> <p>Currently EOL does not support operations which require a simple variable and non-functional interface as a parameter, such as the iterate operation. To work around this, you can assign lambda expressions to variables, deriving them by calling a built-in operation to obtain the desired type.</p> <pre><code>  // UnaryOperator\n  var doubler = unary(i | i * 2);\n  assertEquals(16, doubler.apply(8));\n\n  // Predicate\n  var isEvenTester = predicate(i | i.mod(2) == 0);\n  assertFalse(predicate.test(3));\n\n  // Function\n  var hasher = func(x | x.hashCode());\n  assertEquals(-1007761232, hasher.apply(\"a string\"));\n\n  // Consumer\n  var printer = consumer(x | x.println());\n  printer.accept(\"Testing...\");\n\n  // Supplier\n  var threadSafeCollectionMaker = supplier( | new Native(\"java.util.concurrent.ConcurrentLinkedDeque\"));\n  var deque = threadSafeCollectionMaker.get();\n\n  // Runnable\n  var sayHi = runnable( | \"Hello, World!\".println());\n  sayHi.run();</code></pre>"},{"location":"doc/articles/lambda-expressions/#streams-vs-eol-cheat-sheet","title":"Streams vs EOL cheat sheet","text":"<p>Aside from the fact that streams are lazy and Epsilon operations are eager, there is some inevitable overlap in their functionality. This section provides an equivalence mapping from Epsilon to Java Streams to help you migrate from one to the other.</p> <ul> <li><code>select</code> =&gt; <code>filter</code></li> <li><code>collect</code> =&gt; <code>map</code></li> <li><code>forAll</code> =&gt; <code>allMatch</code></li> <li><code>exists</code> =&gt; <code>anyMatch</code></li> <li><code>none</code> =&gt; <code>noneMatch</code></li> <li><code>nMatch</code> =&gt; No efficient short-circuiting equivalent, but result     can be achieved using <code>filter</code> followed by <code>.count() == n</code></li> <li><code>count</code> =&gt; <code>count</code></li> <li><code>one</code> =&gt; Same as <code>nMatch</code> with n = 1</li> <li><code>selectOne</code> =&gt; <code>filter</code> followed by <code>.findAny()</code> / <code>.findFirst()</code>     then <code>.orElse(null)</code> if the desired absence of a result is null</li> <li><code>reject</code> =&gt; same as <code>select</code> with negated predicate</li> <li><code>sortBy</code> =&gt; <code>sorted</code></li> <li><code>mapBy</code> =&gt; <code>.collect(Collectors.groupingBy)</code></li> <li><code>aggregate</code> =&gt; <code>.collect(Collectors.toMap)</code></li> </ul> <p>In addition, non-first-order operations on Epsilon collection types can be simulated as follows for streams:</p> <ul> <li><code>flatten</code> =&gt; <code>.flatMap(c | c.stream())</code> -- please note that     <code>flatten</code> is recursive whilst <code>flatMap</code> is not</li> <li><code>sum</code> =&gt; <code>.filter(e | e.isInteger()).mapToInt(i | i).sum()</code> --     replace Int/Integer with appropriate type (Long, Double etc.)</li> <li><code>min / max</code> =&gt; Same as sum but replace the last call with min or     max as required</li> <li><code>product</code> =&gt; Same as <code>sum</code> but replace the last call with     <code>.reduce(i1, i2 | i1 * i2).getAsLong()</code> -- replace Long with     appropriate type</li> <li><code>asBag</code> =&gt; <code>.collect(Collectors.toCollection(| new Bag))</code></li> <li><code>asSequence</code> / <code>asSet</code> / <code>asOrderedSet</code> =&gt; Same as <code>asBag</code> but     replace Bag with desired type</li> </ul> <p>Please note that streams are one-shot and the pipeline cannot be re-used once a terminal operation is invoked (see the API for details).</p>"},{"location":"doc/articles/manage-the-epsilon-website-locally/","title":"Manage the Epsilon web site locally","text":"<p>This article provides a step-by-step guide for obtaining a local copy of the Epsilon website. The website is managed using the mkdocs library. The content is organised in different Markdown files, from which a static website can be generated.</p>"},{"location":"doc/articles/manage-the-epsilon-website-locally/#setting-up-your-environment","title":"Setting up your environment","text":"<ul> <li>Clone the Git repository at https://github.com/eclipse/epsilon-website.</li> <li>Download and install virtualenv.</li> <li>Navigate to the <code>mkdocs</code> folder, and run <code>./serve.sh</code> from a terminal. The first time this command is run, a Python virtual environment will be created unther the <code>mkdocs/env</code> directory. After the environment is ready (and on subsequent calls to <code>./serve.sh</code>), a local web server containing the Epsilon website will be running at http://localhost:8000.</li> </ul>"},{"location":"doc/articles/manage-the-epsilon-website-locally/#real-time-modification-of-the-website","title":"Real-time modification of the website","text":"<p>All the Markdown sources of the website are contained in the <code>mkdocs</code> folder. After running the <code>./serve.sh</code> command, we can alter these sources, and the changes will be reflected automatically in the local website. This is very useful to get quick feedback of our changes, as we do not have to regenerate the website each time we make a modification.</p> <p>To shutdown the local web server at any time, hit <code>CTRL + C</code> on the terminal you used to launch it in the first place.</p>"},{"location":"doc/articles/manage-the-epsilon-website-locally/#building-the-static-site","title":"Building the static site","text":"<p>Once you've happy with the changes you've made to the Markdown sources, you can re-generate the static website. To do so, run <code>./build.sh</code> and wait for it to finish.</p>"},{"location":"doc/articles/manage-the-epsilon-website-locally/#updating-the-website-contents","title":"Updating the website contents","text":"<p>As a convention for project commiters, introducing a change in the website is usually separated in two commits: the first one contains any changes to the Markdown sources, while the second one includes the result of building again the static site as described in the previous section.</p> <p>If you are not a commiter, but you find any typos or parts of the website that do not work as they should, thanks for letting us know!</p>"},{"location":"doc/articles/manage-the-epsilon-website-locally/#pushing-your-changes","title":"Pushing your changes","text":"<p>There is a <code>publish.sh</code> script in the repo, which creates separate commits for the changes to <code>mkdocs</code> and the changes to the generated static files, and then pushes both commits to the remote repo. You can use it as follows: <code>./publish.sh \"Added new article\"</code>.</p>"},{"location":"doc/articles/manage-the-epsilon-website-locally/#finding-broken-links","title":"Finding broken links","text":"<p><code>wget</code> and <code>grep</code> can be used to find broken links in the Epsilon website. First, run the website locally by executing the <code>./serve.sh</code> command as described above. Then, we will traverse the website using <code>wget</code> with this command:</p> <pre><code>wget -e robots=off --spider -r --no-parent -o wget_errors.txt http://localhost:8000\n</code></pre> <p>We have used these options:</p> <ul> <li><code>-e robots=off</code> makes <code>wget</code> ignore <code>robots.txt</code>. This is OK in this case, as we're running the spider on our own local server.</li> <li><code>--spider</code> prevents <code>wget</code> from downloading page requisites that do not contain links</li> <li><code>-r</code> makes <code>wget</code> traverse through links</li> <li><code>--no-parent</code> prevents <code>wget</code> from leaving <code>/gmt/epsilon/</code></li> <li><code>-o wget_errors.txt</code> collects all messages in the <code>wget_errors.txt</code> file</li> </ul> <p>Once it's done, we can simply search for the word \"404\" in the log, with:</p> <pre><code>grep -B2 -w 404 wget_errors.txt\n</code></pre> <p>We will get a list of all the URLs which reported 404 (Not Found) HTTP error codes.</p>"},{"location":"doc/articles/maven-release/","title":"Releasing Epsilon to Maven Central","text":"<p>This article describes the overall process required to release a new stable release of Epsilon to Maven Central. There are a few steps involved, some of which are outside our control. The guide will describe the steps that we do control, and point you to the relevant resources for the others.</p>"},{"location":"doc/articles/maven-release/#preparation","title":"Preparation","text":"<p>The first step is to gain deploy rights to our <code>org.eclipse.epsilon</code> groupId in the Sonatype OSS Nexus repository. To do this, please register at the Sonatype JIRA and give your JIRA username to the Epsilon release engineer(s), so we may file a ticket to have deploy rights granted to you.</p>"},{"location":"doc/articles/maven-release/#testing-the-plain-maven-build","title":"Testing the Plain Maven build","text":"<p>Our plain Maven artifacts are built through a parallel hierarchy of <code>pom-plain.xml</code> files, starting from the root of the Epsilon repository. To do a plain Maven compilation + test build from scratch, simply run this:</p> <pre><code>mvn -f pom-plain.xml clean test\n</code></pre> <p>Keep in mind that plain Maven builds do not run unit tests, as we already run those in the Tycho build. Make sure that all tests pass in the Tycho build first.</p> <p>Double check the dependencies in the various <code>pom-plain.xml</code> files, especially those related to external libraries.</p> <p>Check the project metadata in the <code>pom-plain.xml</code> file, which lists the current developers, SCM URLs, and other details.</p>"},{"location":"doc/articles/maven-release/#preparing-a-maven-release","title":"Preparing a Maven release","text":"<p>Set the version in the <code>pom-plain.xml</code> files:</p> <pre><code>mvn -f pom-plain.xml versions:set\n</code></pre> <p>Enter the version number of the release, and create a commit for it:</p> <pre><code>git add ...\ngit commit -m \"Set pom-plain versions to X.Y.Z\"\n</code></pre> <p>Push the commit to Jenkins:</p> <pre><code>git push\n</code></pre> <p>Here is an example commit. Typically this would be the last thing you do before tagging the release. After you've pushed this and tagged the repository with the Epsilon version, remember to bump the version to the next SNAPSHOT.</p>"},{"location":"doc/articles/maven-release/#release-to-maven-central","title":"Release to Maven Central","text":"<p>The Jenkins build will automatically sign the plain Maven JARs and create a new staging repository in the OSSRH Sonatype Nexus server. It will also attempt to \"close\" it to modification, which will trigger the Maven Central validation rules. If one of these rules fail, the repository will be left open: the violations will be recorded in the Jenkins build logs, and you can try to manually close the repository and see those checks applied once more.</p> <p>As a precaution, we require all staging repositories to be manually checked before we release them to Maven Central. Once the Jenkins build passes, log into Sonatype OSS with your JIRA credentials and check the \"Staging Repositories\" section. Search for \"epsilon\" and you should be able to see the newly created staging repository.</p> <p>Select the repository and check in the \"Contents\" tab that everything is in order. If you are not happy with it, you can drop the repository, add more commits to the Maven release branch, and retry the upload. If you are happy with the contents, click on \"Release\" and enter an appropriate message in the \"Reason\" field (usually, \"Stable release RELEASE of Eclipse Epsilon\" suffices).</p> <p>After about an hour or so, the staging repository will disappear, and after a few hours the contents of the repository should be available from Maven Central. This may take up to a day, so be patient!</p>"},{"location":"doc/articles/minimal-examples/","title":"Constructing a Helpful Minimal Example","text":"<p>From time to time, you may run into a problem when using Epsilon or find a bug. In these instances, we're happy to provide technical support and we endeavour to ensure that no question on our forum goes unanswered.</p> <p>We often ask users to supply a minimal example that we can use to reproduce the problem on our machine. A high quality example often allows to send a much quicker and more accurate response. This article describes how to put together a useful example.</p> <p>Constructing Minimal Examples in the Epsilon Playground</p> <p>In many cases, the easiest way to create and share a minimal example is through the Epsilon Playground. Once you have put together your example, just click on the \"Share\" button and include the short link that pops up in your message on the forum.</p> <p>Please include the following:</p> <ul> <li>The version of Epsilon that you're running.</li> <li>Instructions for reproducing the problem</li> <li>A minimal version of all of the artefacts needed to reproduce the problem: models, metamodels (e.g. .ecore files), Epsilon programs (e.g. .eol, .evl, .etl, .egl files)</li> <li>Where applicable, Eclipse launch configurations or Ant build files for your Epsilon programs.</li> <li>An Eclipse project containing the minimal artefacts (and launch configurations or Ant build files). Please refrain from including files and folders that are not part of an Eclipse project as it is not always clear what we are expected to do with them.</li> </ul> <p>The remainder of this article contains hints and tips for each of the above. Once you have a minimal example, please attach it to a message in the forum or email it to us.</p>"},{"location":"doc/articles/minimal-examples/#finding-the-version-of-epsilon","title":"Finding the version of Epsilon","text":"<p>When developing and maintaining Epsilon, we often work on several versions of Epsilon at once: we maintain separate interim and stable versions, and we often use separate development branches for experimental features. Consequently, we need to ensure that we're running the same version of Epsilon as you in order to reproduce your problem. To identify which version of Epsilon you have:</p> <ol> <li>Click Help\u2192About Eclipse (on Mac OS X click Eclipse\u2192About Eclipse).</li> <li>Click the Installation Details button</li> <li>Depending on how Epsilon has been installed, its version number may appear on the list of Installed Software:</li> </ol> <p></p> <ol> <li>If not, click Plug-ins.</li> <li>Sort the list by the Plug-in id column by clicking the column title.</li> <li>Locate the row with org.eclipse.epsilon.eol.engine as its plug-in id, as shown below.</li> </ol> <p></p>"},{"location":"doc/articles/minimal-examples/#instructions-for-reproducing-the-problem","title":"Instructions for reproducing the problem","text":"<p>When reproducing your problem requires more than one or two steps, a short set of instructions is a great help for us. Please try to provide a list of steps that we can follow to reproduce the problem. For example:</p> <ol> <li>Open Example.model, and add a new Node with name \"foo\".</li> <li>Run the Foo2Bar.etl transformation with the supplied launch configuration.</li> <li>Open Example.model.</li> <li>Note that the Node that you added has not changed: it has not been transformed! The Node named \"foo\" should now be named \"bar\".</li> </ol>"},{"location":"doc/articles/minimal-examples/#a-minimal-version","title":"A minimal version","text":"<p>Often, Epsilon users are manipulating large models with many thousands of elements, or executing Epsilon programs with many hundreds of lines of code. When investigating a problem or fixing a bug, it is extremely helpful for us to receive a minimal project that focuses exactly on the problem that you are encountering. In particular, please provide:</p> <ul> <li>A small number of models, metamodels and Epsilon programs (ideally 1 of each).</li> <li>Small models and metamodels (ideally with very few model elements).</li> <li>Small programs (ideally containing only the code required to reproduce the problem).</li> </ul> <p>No code screenshots or dumps, please</p> <p>Although it can take a little extra time for you to produce a minimal example, we really appreciate it. A minimal example allows us to spend more time fixing the problem and providing advice, and much less time trying to reproduce the problem on our end. Also, based on our experience, messages that provide a minimal example tend to get answered much faster. On the other hand, examples which indicate little/no effort from the reporter's side to narrow down (e.g. complete code dumps) or to help us reproduce (e.g. screenshots of code that we'd have to retype) the problem tend to be pushed back to the end of the queue and can take significantly longer to investigate.</p> <p>In some cases, building a minimal example is a great way to troubleshoot the problem that you're experiencing, and you may even find a solution to the problem while doing so.</p>"},{"location":"doc/articles/minimal-examples/#epsilon-launch-configurations","title":"Epsilon launch configurations","text":"<p>When launching an Epsilon program from within Eclipse, it is common to produce a launch configuration, which defines the models on which an Epsilon program is executed. By default, Eclipse does not store these launch configurations in your workspace and hence they are not included in projects that are exported from your workspace.</p> <p>To store an existing launch configuration in your workspace:</p> <ol> <li>Click Run\u2192Run Configurations.</li> <li>Select the Epsilon program for which you wish to store a launch configuration from the left-hand pane.</li> <li>Select the Common tab.</li> <li>By default, under Save as the Local option is selected. Click Shared file and then Browse.</li> <li>Select the project that contains the Epsilon program from the dialogue box, and then click Ok, as shown below.</li> <li>Click Apply.</li> <li>Close the Run Configurations dialogue box.</li> </ol> <p></p> <p>Eclipse will create a new .launch file in your project, which contains all of the information needed to launch your Epsilon program, as shown below.</p> <p></p>"},{"location":"doc/articles/minimal-examples/#exporting-an-eclipse-project-from-your-workspace","title":"Exporting an Eclipse project from your workspace","text":"<p>Once you have created a project containing a minimal example (and launch configurations or Ant scripts), you can create an archive file which can be emailed to us:</p> <ol> <li>Right-click your Project</li> <li>Click Export...</li> <li>Under the General category, select Archive File and click Next.</li> <li>Ensure that the project(s) that you wish to export are checked in the left-hand pane.</li> <li>Supply a file name in the To archive file text box.</li> <li>Click Finish.</li> </ol> <p>Please email the resulting archive file to us.</p>"},{"location":"doc/articles/modular-flexmi/","title":"Modularity Mechanisms in Flexmi","text":""},{"location":"doc/articles/monitoring-and-instrumenting-epsilon-programs/","title":"Monitoring and Instrumenting Epsilon Programs","text":"<p>Epsilon interpreters provide support for hooking into the execution of model management programs. This can be useful for monitoring and instrumenting Epsilon programs at runtime, and for computing metrics (e.g. model/metamodel/statement coverage, performance metrics) of interest.</p> <p>The listing below demonstrates parsing an EOL program and adding an <code>IExecutionListener</code> to its interpreter, which prints the program's statements/expressions to the console as soon as they are executed.</p> <pre><code>public static void main(String[] args) throws Exception {\n\nEolModule module = new EolModule();\nmodule.parse(\"for (i in 1.to(10)) { i.println(); }\");\nmodule.getContext().getExecutorFactory().addExecutionListener(\nnew IExecutionListener() {\n\n@Override\npublic void finishedExecutingWithException(ModuleElement me, EolRuntimeException exception, IEolContext context) {}\n\n@Override\npublic void finishedExecuting(ModuleElement me, Object result, IEolContext context) {\n\nSystem.out.println(me);\n}\n\n@Override\npublic void aboutToExecute(ModuleElement me, IEolContext context) {}\n}\n);\nmodule.execute();\n}\n</code></pre> <p>To monitor the execution of an ETL transformation, EVL constraints etc. you can replace <code>EolModule</code> with <code>EtlModule</code>, <code>EvlModule</code> etc.</p>"},{"location":"doc/articles/parallel-execution/","title":"Multi-threaded execution of Epsilon programs","text":"<p>Some of Epsilon's languages support parallel execution, which can leverage multiple hardware threads to improve performance. To enable this, head to the Advanced tab and select a parallel implementation. Where there are multiple implementations, prefer the \"Elements\" or \"Atom\" ones. An \"Atom\" is a tuple of a module element and model element, so for example a \"ContextAtom\" in EVL is context-element pair - that is, the granularity of parallelisation will be at the model element level (one job for every model element).</p> <p></p> <p>Note that the modelling technology must also be able to handle concurrent query operations. Most modelling technologies will likely be supported for read-only model management tasks such as validation and code generation, however some which rely on external tools e.g. Simulink cannot handle concurrent operations. In any case, since most models support caching, the cache must be set up to support concurrency. You should ensure that the appropriate concurrency support option is checked in the model configuration.</p> <p></p> <p>Note that when choosing a parallel implementation, first-order operations such as <code>select</code>, <code>exists</code> etc. will also be parallelised automatically where appropriate. This applies in particular to the parallel EOL implementation.</p>"},{"location":"doc/articles/parallel-execution/#annotation-based-parallelism","title":"Annotation-based parallelism","text":"<p>In cases where an \"Annotation-based\" implementation is available, you can choose which rules are parallelised with the <code>@parallel</code> annotation. For example in EVL:</p> <pre><code>context ModelElementType {\n  @parallel\n  constraint Invariant {\n    check {\n      // ...\n    }\n  }</code></pre> <p>If further control is required, you can also choose whether a rule will be executed in parallel on a per-element basis using an executable annotation. This allows you to write a Boolean EOL expression to determine whether a given model element should be executed in parallel for the annotated rule. You can access the model element in the annotation with <code>self</code> as usual, and also any operations or variables in scope. Any rules not annotated will be executed sequentially.</p> <pre><code>pre {\n  var parallelThreshold = 9001;\n}\ncontext ModelElementType {\n  $parallel self.children.size() &gt; parallelThreshold;\n  constraint Invariant {\n    check {\n      // ...\n    }\n  }</code></pre>"},{"location":"doc/articles/parallel-execution/#limitations","title":"Limitations","text":"<p>Currently Epsilon does not support assignment of extended properties when executing in parallel. Parallel operations also cannot be nested.</p>"},{"location":"doc/articles/picto-embedded-views/","title":"Embedding Picto views in a static Markdown or HTML document","text":"<p>It is possible to include other Picto views in a static Markdown or HTML document. This feature is very useful to e.g. create on-the-fly reports concerning one or more models that can be later exported and shared for discussion.</p> <p>We will reuse the social network example depicted in the Picto documentation. The complete source code of this example is available here.</p> <p></p> <p>The screenshot above depicts a visusalisation of a social network model. The Picto window shows a \"Readme\" view that is written in Markdown, and that contains other views from Picto's view tree.</p>"},{"location":"doc/articles/picto-embedded-views/#static-views-in-picto","title":"Static views in Picto","text":"<p>Although it is possible to embed Picto views in any type of Picto visualisation, this embedding becomes specially useful in statically defined views, which are briefly introduced in the following.</p> <p>By default, the views that are included in the tree of a Picto visualisation are determined by the transformation selected in the <code>.picto</code> configuration file, which is generally an special EGX transformation. It is possible to add extra views by using the <code>&lt;view&gt;</code> tag in a Picto file:</p> <pre><code>&lt;?nsuri picto?&gt;\n&lt;picto format=\"egx\" transformation=\"picto/socialnetwork.egx\"&gt;\n&lt;view path=\"Custom, Alice and Bob\" icon=\"diagram-ff00ff\" type=\"Persons2Graphviz\"&gt;\n&lt;parameter name=\"names\" values=\"Alice, Bob\"/&gt;\n&lt;/view&gt;\n\n&lt;view path=\"Readme\" icon=\"document\" format=\"markdown\" source=\"socialnetwork/readme.md\" position=\"0\"/&gt;\n&lt;/picto&gt;\n</code></pre> <p>The snippet above shows the contents of the <code>socialnetwork.model.picto</code> file. The <code>&lt;picto&gt;</code> tag specifies the EGX transformation to use via the <code>format</code> and <code>transformation</code> attributes. Additionally, two <code>&lt;view&gt;</code> elements are added, of which we focus on the second one in this article, which is a static Picto view.</p> <p>A static Picto view depicts the contents of a static file. It can be defined by specifying its location in Picto's view tree (via the <code>path</code> and <code>position</code> attributes of the <code>&lt;view&gt;</code> tag) and the <code>source</code> and <code>format</code> of the file. In the example snippet, the \"Readme\" view appears first in the view tree (<code>position=\"0\"</code>), and it is using the <code>socialnetwork/readme.md</code> file of the example project, whose contents are depicted below:</p> <pre><code># Social network\n\nThis is a simple way to represent network connections.\n\n## Alice's network &lt;a href=\"javascript:showView(['Social Network', 'Alice'])\"&gt;(Go to Alice)&lt;/a&gt;\n\n&lt;picto-view path=\"Social Network, Alice\"/&gt;\n\n## Embedded \"stats\" table view\n\n&lt;picto-view path=\"Stats\" autoresize=\"true\"/&gt;\n\n## Embedded PlantUML (escaped backticks)\n\n\\```render-plantuml\n@startuml\nAlice -&gt; Bob : Hello\n@enduml\n\\```\n\n## Static image\n\n![Epsilon logo](socialnetwork/epsilon.png)\n</code></pre>"},{"location":"doc/articles/picto-embedded-views/#using-the-picto-view-tag","title":"Using the <code>&lt;picto-view&gt;</code> tag","text":"<p>Embedding a Picto view is as easy as using the <code>&lt;picto-view&gt;</code> tag, specifying as <code>path</code> attribute the path of the view to be embedded in Picto's view tree. The Markdown file depicted above embeds two Picto views: the first one is Alice's social network (present in the <code>Social Network &gt; Alice</code> path in the view tree), while the second one is the stats table of the whole model.</p> <p>As mentioned, the use of the <code>&lt;picto-view&gt;</code> tag is not limited to static views such as the one of the example, and can be used inside any kind of views (e.g. those created with EGL transformations).</p>"},{"location":"doc/articles/picto-embedded-views/#iframes-and-dynamic-resizing-of-embedded-views","title":"Iframes and Dynamic resizing of embedded views","text":"<p>By default, an embedded picto view becomes as tall as the height of the contents that are originally rendered. However, the height of such contents might change dynamically, as it is the case of the stats table view: we can modify the number of elements shown in each page of the table, thus altering the required vertical space.</p> <p>For those cases where the height of a view might change dynamically, the <code>autoresize</code> attribute can be added to the <code>&lt;picto-view&gt;</code> tag to automatically adapt to such changes. In the example above, <code>autoresize</code> is set to <code>true</code> for the \"Stats\" view, so that pagination changes do not cause vertical cropping issues.</p> <p>If we only want to ensure that embedded views do not affect the host visualisation, we can enforce the use of an iframe by setting the <code>iframe</code> attribute to <code>true</code>. Note that setting <code>autoresize</code> to true also implies that an iframe will be used, so it is not necessary to specify both.</p>"},{"location":"doc/articles/picto-sequence-diagrams/","title":"Drill-Down Sequence Diagrams with Picto","text":"<p>This article demonstrates using Picto and its PlantUML integration to generate drill-down sequence diagrams from models conforming to a minimal EMF-based sequence diagram language.</p>"},{"location":"doc/articles/picto-sequence-diagrams/#metamodel","title":"Metamodel","text":"<p>Below is the metamodel of our mini sequence-diagram (<code>minisd</code>) DSL (in Emfatic). In our language, a scenario consists of a number of interactions between participants, and alternative execution paths (<code>Alt</code>).</p> <pre><code>@namespace(uri=\"minisd\", prefix=\"\")\npackage minisd;\n\nclass Scenario extends Block {}\n\nclass Participant {\n    attr String name;\n}\n\nabstract class Step {}\n\nclass Block extends Step {\n    attr String title;\n    val Step[*] steps;\n}\n\nclass Alt extends Step {\n    attr String title;\n    val Block[*] blocks;\n}\n\nclass Interaction extends Step {\n    ref Participant from;\n    ref Participant to;\n    attr String message;\n}</code></pre>"},{"location":"doc/articles/picto-sequence-diagrams/#customer-atm-model","title":"Customer-ATM Model","text":"<p>Below is a Flexmi model that conforms to the minisd DSL and captures the interaction between a customer and an ATM.</p> <pre><code>&lt;?nsuri minisd?&gt;\n&lt;?render-egx minisd2plantuml.egx?&gt;\n&lt;_&gt;\n&lt;participant name=\"Customer\"/&gt;\n&lt;participant name=\"ATM\"/&gt;\n\n&lt;scenario title=\"Customer-ATM\"&gt;\n&lt;int from=\"Customer\" to=\"ATM\" msg=\"Insert card\"/&gt;\n&lt;int from=\"ATM\" to=\"Customer\" msg=\"Request PIN\"/&gt;\n&lt;int from=\"Customer\" to=\"ATM\" msg=\"Enter PIN\"/&gt;\n&lt;alt title=\"Check PIN\"&gt;\n&lt;block title=\"PIN valid\"&gt;\n&lt;int from=\"ATM\" to=\"Customer\" msg=\"Display options\"/&gt;\n&lt;alt title=\"Options\"&gt;\n&lt;block title=\"Cash withdrawal\"&gt;\n&lt;int from=\"Customer\" to=\"ATM\" msg=\"Select cash withdrawal\"/&gt;\n&lt;int from=\"ATM\" to=\"Customer\" msg=\"Ask for amount\"/&gt;\n&lt;int from=\"Customer\" to=\"ATM\" msg=\"Enter amount\"/&gt;\n&lt;alt title=\"Check funds\"&gt;\n&lt;block title=\"Sufficient funds\"&gt;\n&lt;int from=\"ATM\" to=\"Customer\" msg=\"Produce cash\"/&gt;\n&lt;/block&gt;\n&lt;block title=\"Insufficient funds\"&gt;\n&lt;int from=\"ATM\" to=\"Customer\" msg=\"Produce error message\"/&gt;\n&lt;/block&gt;\n&lt;/alt&gt;\n&lt;/block&gt;\n&lt;block title=\"Balance display\"&gt;\n&lt;int from=\"Customer\" to=\"ATM\" msg=\"Select balance display\"/&gt;\n&lt;int from=\"ATM\" to=\"Customer\" msg=\"Display balance\"/&gt;\n&lt;int from=\"ATM\" to=\"Customer\" msg=\"Return card\"/&gt;\n&lt;/block&gt;\n&lt;/alt&gt;\n&lt;/block&gt;\n&lt;block title=\"PIN invalid\"&gt;\n&lt;int from=\"ATM\" to=\"Customer\" msg=\"Try again\"/&gt;\n&lt;/block&gt;\n&lt;/alt&gt;\n&lt;/scenario&gt;\n&lt;/_&gt;\n</code></pre>"},{"location":"doc/articles/picto-sequence-diagrams/#visualisation-transformation","title":"Visualisation Transformation","text":"<p>To visualise models that conform to the minisd DSL (such as the Customer-ATM model above) in Picto, we have written a model-to-text transformation in EGL, that transforms such models into a series of PlantUML sequence diagrams.</p> <p>In particular, the transformation produces one sequence diagram for the entire model, and one sequence diagram for each execution path in it. The EGX orchestration program and the EGL template are shown below.</p> minisd2plantuml.egxminisd2plantuml.egl <pre><code>rule Scenario2PlantUml \n    transform s : Scenario {\n\n    template : \"minisd2plantuml.egl\"\n\n    parameters : Map {\n        \"mainBlock\" = null,\n        \"format\" = \"plantuml\",\n        \"path\" = List{s.title},\n        \"icon\" = \"sequence\"\n    }\n\n}\n\nrule Block2PlantUml \n    transform b : Block {\n\n    guard : b.eContainer.isTypeOf(Alt)\n\n    template : \"minisd2plantuml.egl\"\n\n    parameters : Map {\n        \"mainBlock\" = b,\n        \"format\" = \"plantuml\",\n        \"path\" = b.closure(p|p.eContainer).invert().including(b).title,\n        \"icon\" = \"block\"\n    }\n\n}\n\nrule Alt2PlantUml \n    transform a : Alt {\n\n    parameters : Map {\n        \"format\" = \"text\",\n        \"path\" =  a.closure(p|p.eContainer).invert().including(a).title,\n        \"icon\" = \"alt\"\n    }\n\n}</code></pre> <pre><code>@startuml\n[%\nvar excludedBlocks = Sequence{};\nif (mainBlock.isDefined()) {\n    var ancestors = mainBlock.closure(b|b.eContainer()).select(b|b.isTypeOf(Block)).including(mainBlock);\n    for (a in ancestors) {\n        if (a.eContainer().isDefined() and a.eContainer().isTypeOf(Alt)) {\n            excludedBlocks.addAll(a.eContainer().blocks.excluding(a));\n        }\n    }\n}\n%]\n[%=Scenario.all.first().toPlantUml()%]\n@enduml\n\n[%\noperation Scenario toPlantUml() {\n    return self.steps.collect(s|s.toPlantUml()).concat(\"\\n\");\n}\n\noperation Interaction toPlantUml() {\n    return self.from.name + \"-&gt;\" + self.to.name + \": \" + self.message + \"\\n\";\n}\n\noperation Alt toPlantUml() {\n    var plantUml = \"\";\n    var visibleBlocks = self.blocks.excludingAll(excludedBlocks);\n    for (b in visibleBlocks) {\n        if (loopCount == 1) {\n            plantUml += \"alt\";\n            if (mainBlock.isDefined() and mainBlock.eContainer == self) {\n                plantUml += \" #azure\";\n            }\n        }\n        else plantUml += \"else \";\n        plantUml += \" \" + b.title;\n        plantUml += \"\\n\" + b.toPlantUml();\n    }\n    if (visibleBlocks.notEmpty()) plantUml += \"\\nend\\n\";\n    return plantUml;\n}\n\noperation Block toPlantUml() {\n    if (excludedBlocks.contains(self)) return \"\";\n    return self.steps.collect(s|s.toPlantUml()).concat(\"\");\n}\n%]</code></pre>"},{"location":"doc/articles/picto-sequence-diagrams/#drill-down-sequence-diagrams","title":"Drill-Down Sequence Diagrams","text":"<p>The result is a set of sequence diagrams that we can navigate to drill down the alternative interaction paths. Notice how selecting an alternative (e.g. <code>Sufficient funds</code>) hides all irrelevant information from the sequence diagram (e.g. <code>Balance display</code>, <code>PIN invalid</code>).</p> <p></p> <p>Source code</p> <p>The complete source code for this example is in Epsilon's Git repository.</p>"},{"location":"doc/articles/picto-tables/","title":"Generating table views in Picto","text":"<p>This article shows how Picto is able to render CSV files as enhanced HTML tables provided by the Metro UI library, which include table styling, pagination, column sorting, and search capabilities. It also shows how the Pinset language can be used to create these table views without having to generate CSVs through a general-purpose model-to-text transformation.</p>"},{"location":"doc/articles/picto-tables/#rendering-csv-files-in-the-workspace","title":"Rendering CSV files in the workspace","text":"<p>Picto can be used to render CSV files present in an Eclipse project. The following figure shows the table generated for one of the output CSV files of the Pinset grading example:</p> <p></p> <p>To automatically render CSV files in Picto, the <code>Render verbatim sources</code> option needs to be enabled. This option can be turned on temporarily in the top-right hamburger menu option of the Picto window, or it can be permanently set in the Eclipse preferences (Epsilon &gt; Picto).</p>"},{"location":"doc/articles/picto-tables/#generating-table-views-with-a-pinset-transformation","title":"Generating table views with a Pinset transformation","text":"<p>Pinset is a domain-specific transformation language that allows extracting tabular datasets from models. Initially devised for data analysis purposes, this language can be used along Picto to generate table-based model visualisations.</p> <p>In the Social Network example that can be found in the Picto documentation, one of the views is generated with the following Pinset dataset rule:</p> <pre><code>dataset personStats over person : Person {\n    properties[name]\n\n    column liked_by : Person.all.select(p |\n            p.likes.includes(person)).size()\n    column liking : person.likes.size()\n\n    column disliked_by : Person.all.select(p |\n            p.dislikes.includes(person)).size()\n    column disliking : person.dislikes.size()\n\n    column like_meter : liked_by - disliked_by\n}</code></pre> <p>Briefly, a Pinset dataset rule contains EOL-based definitions of the different columns of the output dataset. These columns operate over elements of the input model (such as the <code>Person</code> elements in the rule above) to create the dataset rows. In the example, likes and dislikes counts are obtained for each <code>Person</code> element in the dataset. Check the Pinset documentation for more information about other features of the language such as advanced column generators.</p> <p>To use the above Pinset rule to create a Picto view in the social network model visualisation, the following EGX rule is present in the <code>picto/socialnetwork.egx</code> file:</p> <pre><code>rule Persons2Table {\n\n    template : \"persons2table.pinset\"\n\n    parameters : Map {\n        \"path\" = Sequence{\"Stats\"},\n        \"icon\" = \"table\",\n        \"format\" = \"csv\"\n\n        // ,\"pinsetrule\" = \"otherStats\"\n    }\n}</code></pre> <p>The EGX rule above is very similar to the ones normally used for EGL templates. As differences, the rule points to a <code>.pinset</code> template file where the Pinset dataset rules are contained, and the defined icon and format are <code>table</code> and <code>csv</code> respectivelly. Lastly, as a Pinset file can contain several dataset rules, it is possible to select which rule to use in the visualisation with the <code>pinsetrule</code> parameter (commented out in the rule above).</p> <p>The above EGX and Pinset rules generate the following table view:</p> <p></p>"},{"location":"doc/articles/picto-xtext/","title":"Visualising Xtext Models with Picto","text":"<p>This article shows how Picto can be used to produce graphical views from Xtext-based models. To demonstrate the Picto/Xtext integration, we use the Entity DSL showcased in the 15' Xtext tutorial.</p> <p></p>"},{"location":"doc/articles/picto-xtext/#setup","title":"Setup","text":"<ul> <li>Import the projects below from the <code>examples</code> folder of the Epsilon Git repository<ul> <li><code>org.eclipse.epsilon.examples.picto.xtext.domainmodel</code></li> <li><code>org.eclipse.epsilon.examples.picto.xtext.domainmodel.ide</code></li> <li><code>org.eclipse.epsilon.examples.picto.xtext.domainmodel.ui</code></li> <li><code>org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto</code></li> </ul> </li> <li>Right-click on <code>Domainmodel.xtext</code> and select <code>Run As</code> \u2192 <code>Generate Xtext Artefacts</code></li> <li>Run a nested Eclipse instance.</li> <li>In the nested Eclipse instance workspace, create a new file named <code>blog.dmodel</code> with the content below:</li> </ul> <pre><code>datatype String\n\nentity Blog {\n    title: String\n    many posts: Post\n}\n\nentity HasAuthor {\n    author: String\n}\n\nentity Post extends HasAuthor {\n    title: String\n    content: String\n    many comments: Comment\n}\n\nentity Comment extends HasAuthor {\n    content: String\n    many responses: Comment\n}\n</code></pre> <ul> <li>Open the Picto view from the Window \u2192 Show View menu.</li> <li>Go through the produced graphical views as shown in the image above.</li> </ul>"},{"location":"doc/articles/picto-xtext/#the-picto-xtext-integration-plugin-project","title":"The Picto-Xtext Integration Plugin Project","text":"<p>We now dive into the <code>org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto</code> project which contains the Picto-Xtext integration code (the rest of the projects are standard Xtext projects).</p>"},{"location":"doc/articles/picto-xtext/#the-dmodelpictosource-class","title":"The DmodelPictoSource class","text":"<p>This class extends Picto's built-in <code>EglPictoSource</code> class and produces graphical views in Picto from <code>*.dmodel</code> files edited in an Xtext-based editor. In particular:</p> <ul> <li>The <code>supportsEditorType</code> method specifies that this class contributes visualisation capabilities to Xtext-based editors, the title of which ends with <code>.dmodel</code></li> <li>The <code>getRenderingMetadata</code> method specifies the EGL transformation that produces the graphical views every time an editor of interest is opened, activated or saved.</li> <li>The <code>getFile</code> and <code>getResource</code> methods extract an <code>IFile</code> and an EMF <code>Resource</code> from the editor of interest and should be reusable without changes for other Xtext-based languages too.</li> <li>The <code>showElement</code> method reveals and highlights the element with the specified <code>id</code> in the Xtext editor, enabling navigation back to the source model of the view.</li> </ul> <pre><code>package org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto;\n\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.emf.ecore.resource.Resource;\nimport org.eclipse.epsilon.picto.dom.Picto;\nimport org.eclipse.epsilon.picto.dom.PictoFactory;\nimport org.eclipse.epsilon.picto.source.EglPictoSource;\nimport org.eclipse.jface.text.source.ISourceViewer;\nimport org.eclipse.ui.IEditorInput;\nimport org.eclipse.ui.IEditorPart;\nimport org.eclipse.ui.IFileEditorInput;\nimport org.eclipse.ui.PlatformUI;\nimport org.eclipse.xtext.nodemodel.ICompositeNode;\nimport org.eclipse.xtext.nodemodel.util.NodeModelUtils;\nimport org.eclipse.xtext.resource.XtextResource;\nimport org.eclipse.xtext.ui.editor.XtextEditor;\nimport org.eclipse.xtext.ui.workspace.WorkspaceLockAccess.Result;\nimport org.eclipse.xtext.util.concurrent.IUnitOfWork;\n\npublic class DmodelPictoSource extends EglPictoSource {\n\n@Override\nprotected Picto getRenderingMetadata(IEditorPart editorPart) {\nPicto metadata = PictoFactory.eINSTANCE.createPicto();\nmetadata.setTransformation(\"platform:/plugin/org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto/dmodel.egx\");\nreturn metadata;\n}\n\n@Override\nprotected Resource getResource(IEditorPart editorPart) {\nXtextEditor editor = (XtextEditor) editorPart;\nfinal XtextResourceHolder holder = new XtextResourceHolder();\neditor.getDocument().readOnly(new IUnitOfWork&lt;Result, XtextResource&gt;() {\npublic Result exec(XtextResource state) throws Exception {\nholder.setResource(state);\nreturn null;\n};\n});\n\nreturn holder.getResource();\n}\n\n@Override\nprotected IFile getFile(IEditorPart editorPart) {\nIEditorInput editorInput = ((XtextEditor) editorPart).getEditorInput();\nif (editorInput instanceof IFileEditorInput) {\nreturn ((IFileEditorInput) editorInput).getFile();\n}\nreturn null;\n}\n\n@Override\nprotected boolean supportsEditorType(IEditorPart editorPart) {\nreturn editorPart instanceof XtextEditor &amp;&amp; editorPart.getTitle().endsWith(\".dmodel\");\n}\n\n@Override\npublic void showElement(String id, String uri, IEditorPart editor) {\nICompositeNode node = NodeModelUtils.getNode(getResource(editor).getEObject(id));\nif (node != null) {\nISourceViewer textViewer = ((XtextEditor) editor).getInternalSourceViewer();\nint offset = node.getOffset();\nint length = node.getLength();\ntextViewer.setRangeIndication(offset, length, true);\ntextViewer.revealRange(offset, length);\ntextViewer.setSelectedRange(offset, length);\nPlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().activate(editor);\n}\n}\n\n}\n</code></pre> <p>Picto is made aware of this class through the <code>org.eclipse.epsilon.picto.pictoSource</code> extension in the project's <code>plugin.xml</code>.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;?eclipse version=\"3.4\"?&gt;\n&lt;plugin&gt;\n&lt;extension\npoint=\"org.eclipse.epsilon.picto.pictoSource\"&gt;\n&lt;pictoSource\nclass=\"org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto.DmodelPictoSource\"&gt;\n&lt;/pictoSource&gt;\n&lt;/extension&gt;\n\n&lt;/plugin&gt;\n</code></pre>"},{"location":"doc/articles/picto-xtext/#the-visualisation-transformation","title":"The Visualisation Transformation","text":"<p>The visualisation transformation has been implemented using Epsilon's EGL model-to-text transformation language and produces Graphviz-based class diagrams from the active entity model. The transformation consists of the <code>dmodel.egx</code> coordination rules, and the <code>entity2graphviz.egl</code> template shown below. The transformation produces one view for each entity in the model, which consists of the entity itself, any super/sub-types it may have, as well as other entities that it is related to. </p> dmodel.egxentity2graphviz.egl <pre><code>rule Entity2Graphviz\n    transform e : Entity {\n\n    template : \"entity2graphviz.egl\"\n\n    parameters : Map{\n        \"path\" = Sequence{\"Model\", e.name},\n        \"icon\" = \"diagram-ffffff\",\n        \"format\" = \"graphviz-dot\"\n    }\n\n}</code></pre> <pre><code>digraph G {\n    graph[splines=ortho]\n    node[fontname=Arial, fontsize=10, shape=record]\n    edge[fontname=Arial, fontsize=10]\n\n[%var entities = getVisibleEntities();%]\n\n[%for (e in entities){%]\n    [%=e.getNodeName()%][shape=none, margin=0, label=&lt;[%=e.getLabel()%]&gt;]\n[%}%]\n\n[%for (f in e.features.flatten().select(f|f.type.isTypeOf(Entity) and f.type &lt;&gt; e)){%]\n    [%=f.eContainer.getNodeName()%]-&gt;[%=f.type.getNodeName()%][arrowhead=[%=f.getArrow()%],arrowtail=none,tooltip=\"[%=f.name%]\"];\n[%}%]\n\n[%if (e.superType.isDefined()){%]\n    [%=e.superType.getNodeName()%]-&gt;[%=e.getNodeName()%][arrowhead=none,arrowtail=empty,dir=back];\n[%}%]\n\n[%for (s in Entity.all.select(en|en.superType = e)){%]\n    [%=e.getNodeName()%]-&gt;[%=s.getNodeName()%][arrowhead=none,arrowtail=empty,dir=back];\n[%}%]\n\n}\n\n[%\noperation Entity getLabel() {\n\n    var onClick = \"top.showView(['Model','\" + self.name + \"'])\";\n\n    if (self == e) {\n        onClick = \"top.showElement('\" + self.id + \"', '\" + self.eResource.uri + \"')\";\n    }\n\n    var label = \"&lt;table cellspacing='0' cellborder='0' cellpadding='1' bgcolor='\" + self.getColour() + \"'&gt;\";\n    label += \"&lt;tr&gt;&lt;td sides='B' colspan='2' border='1' cellpadding='0'&gt;\" + \n        \"&lt;table border='0' cellspacing='0' cellborder='0'&gt;\" + \n        \"&lt;tr&gt;&lt;td align='right' valign='middle'&gt;&lt;img src='\" + self.getIcon()+ \"'&gt;&lt;/img&gt;&lt;/td&gt;\" + \n        \"&lt;td align='left' valign='middle' href=\\\"javascript:\" + onClick + \"\\\" tooltip='Go'&gt;\" + self.name + \" &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;\";\n\n    label += \"&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;\";\n\n    for (f in self.features.sortBy(a|a.name.toLowerCase())) {\n        label += \"&lt;tr&gt;\";\n        label += \"&lt;td&gt;&lt;img src='\" + f.getIcon() + \"'&gt;&lt;/img&gt;&lt;/td&gt;&lt;td align='left'&gt;\" + f.getLabel() + \"&lt;/td&gt;\";\n        label += \"&lt;/tr&gt;\";\n    }\n\n\n    if (self.features.isEmpty()){\n        label += \"&lt;tr&gt;\";\n        label += \"&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;\";\n        label += \"&lt;/tr&gt;\";\n    }\n\n    label += \"&lt;/table&gt;\";\n    return label;\n}\n\noperation Entity getIcon() {\n    return getImage(\"icons/entity.gif\");\n}\n\noperation Feature getLabel() {\n    return self.name + \" : \" + self.type?.name + (self.many ? \"[\"+\"*\"+\"]\" : \"\") ;\n}\n\noperation Feature getIcon() {\n    return getImage(\"icons/attribute.gif\");\n}\n\noperation Entity getNodeName() {\n    return \"_Entity\" + Entity.all.indexOf(self);\n}\n\noperation Feature getArrow() {\n    if (self.many) {\n        return \"crow\";\n    }\n    else {\n        return \"open\";\n    }\n}\n\noperation getVisibleEntities() {    \n    var visibleEntities : Set;\n    visibleEntities.add(e);\n    visibleEntities.addAll(e.features.select(f|f.type.isTypeOf(Entity)).collect(f|f.type));\n    if (e.superType.isDefined()) visibleEntities.add(e.superType);\n    visibleEntities.addAll(Entity.all.select(en|en.superType = e));\n    return visibleEntities;\n}\n\noperation Entity getColour() {\n    if (self == e) return \"#fff2d2\";\n    else return \"#fffcdc\";\n}\n%]</code></pre>"},{"location":"doc/articles/picto-xtext/#interactive-diagrams","title":"Interactive Diagrams","text":"<p>As shown below, you can navigate between diagrams and back to the Xtext editor using Picto's built-in <code>showElement</code> and <code>showView</code> JavaScript functions.</p> <p></p>"},{"location":"doc/articles/picto-xtext/#lazy-execution","title":"Lazy Execution","text":"<p>Since Picto executes EGL transformations lazily when the entity model is saved, only the view that is currently visible is regenerated immediately, which is useful when working with large models.</p>"},{"location":"doc/articles/plain-xml/","title":"Scripting XML documents using Epsilon","text":"<p>In this article we demonstrate how you can create, query and modify plain standalone XML documents (i.e. no XSD/DTD needed) in Epsilon programs using the PlainXML driver added in version 0.8.9. All the examples in this article demonstrate using EOL to script XML documents. However, it's worth stressing that XML documents are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models - XML or EMF-based -, or to text), compare and merge your XML documents.</p>"},{"location":"doc/articles/plain-xml/#querying-an-xml-document","title":"Querying an XML document","text":"<p>We use the following <code>library.xml</code> as a base for demonstrating the EOL syntax for querying XML documents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;library&gt;\n&lt;book title=\"EMF Eclipse Modeling Framework\" pages=\"744\"&gt;\n&lt;author&gt;Dave Steinberg&lt;/author&gt;\n&lt;author&gt;Frank Budinsky&lt;/author&gt;\n&lt;author&gt;Marcelo Paternostro&lt;/author&gt;\n&lt;author&gt;Ed Merks&lt;/author&gt;\n&lt;published&gt;2009&lt;/published&gt;\n&lt;/book&gt;\n&lt;book title=\"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages=\"736\"&gt;\n&lt;author&gt;Richard Gronback&lt;/author&gt;\n&lt;published&gt;2009&lt;/published&gt;\n&lt;/book&gt;\n&lt;book title=\"Official Eclipse 3.0 FAQs\" pages=\"432\"&gt;\n&lt;author&gt;John Arthorne&lt;/author&gt;\n&lt;author&gt;Chris Laffra&lt;/author&gt;\n&lt;published&gt;2004&lt;/published&gt;\n&lt;/book&gt;\n&lt;/library&gt;\n</code></pre>"},{"location":"doc/articles/plain-xml/#queryingmodifying-xml-documents-in-eol","title":"Querying/modifying XML documents in EOL","text":"<p>The PlainXML driver uses predefined naming conventions to allow developers to programmatically access and modify XML documents in a concise way. This section outlines the supported conventions in the form of questions and answers followed by relevant examples.</p>"},{"location":"doc/articles/plain-xml/#how-can-i-access-elements-by-tag-name","title":"How can I access elements by tag name?","text":"<p>The <code>t_</code> prefix in front of the name of the tag is used to represent a type, instances of which are all the elements with that tag. For instance, <code>t_book.all</code> can be used to get all elements tagged as <code>&lt;book&gt;</code> in the document, <code>t_author.all</code> to retrieve all <code>&lt;author&gt;</code> elements etc. Also, if <code>b</code> is an element with a <code>&lt;book&gt;</code> tag, then <code>b.isTypeOf(t_book)</code> shall return true. If the tag name contains hyphens, underscores, and/or periods, you must escape the complete type name inside back ticks: <code>`t_first-name`</code> </p> <pre><code>// Get all &lt;book&gt; elements\nvar books = t_book.all;\n\n// Get a random book\nvar b = books.random();\n\n// Check if b is a book\n// Prints 'true'\nb.isTypeOf(t_book).println();\n\n// Check if b is a library\n// Prints 'false'\nb.isTypeOf(t_library).println();</code></pre>"},{"location":"doc/articles/plain-xml/#how-can-i-get-the-tag-name-of-an-element","title":"How can I get the tag name of an element?","text":"<p>You can use the <code>.name</code> property for this purpose. For instance, if <code>b</code> is an element tagged as <code>&lt;book&gt;</code>, <code>b.name</code> shall return <code>book</code>. The <code>name</code> property is read-only.</p> <pre><code>// Get a random &lt;book&gt; element\nvar b = t_book.all.random();\n\n// Print its tag\n// Prints 'book'\nb.name.println();</code></pre> <p>tagName property is deprecated</p> <p>Previously the <code>tagName</code> property was suggested for getting the tag name of an element. Due to the introduction of modules in Java 9 accessing this property is deprecated and future use can result in run time exceptions.</p>"},{"location":"doc/articles/plain-xml/#how-can-i-getset-the-attributes-of-an-element","title":"How can I get/set the attributes of an element?","text":"<p>You can use the attribute name as a property of the element object, prefixed by <code>a_</code>. For example, if <code>b</code> is the first book of <code>library.xml</code>, <code>b.a_title</code> will return <code>EMF Eclipse Modeling Framework</code>. Attribute properties are read/write.</p> <p>In this example, <code>b.a_pages</code> will return <code>744</code> as a string. For <code>744</code> to be returned as an integer instead, the <code>i_</code> prefix should be used instead (i.e. <code>b.i_pages</code>. The driver also supports the following prefixes: <code>b_</code> for boolean, <code>s_</code> for string (alias of <code>a_</code>) and <code>r_</code> for real values. </p> <pre><code>// Print all the titles of the books in the library\nfor (b in t_book.all) {\n    b.a_title.println();\n}\n\n// Print the total number of pages of all books\nvar total = 0;\nfor (b in t_book.all) {\n    total = total + b.i_pages;\n}\ntotal.print();\n\n// ... the same using collect() and sum() \n// instead of a for loop\nt_book.all.collect(b|b.i_pages).sum();</code></pre>"},{"location":"doc/articles/plain-xml/#how-can-i-getset-the-text-of-an-element","title":"How can I get/set the text of an element?","text":"<p>You can use the <code>.text</code> read-write property for this.</p> <pre><code>for (author in t_author.all) {\n    author.text.println();\n}</code></pre>"},{"location":"doc/articles/plain-xml/#how-do-i-get-the-parent-of-an-element","title":"How do I get the parent of an element?","text":"<p>You can use the <code>.parentNode</code> read-only property for this.</p> <pre><code>// Get a random book\nvar b = t_book.all.random();\n\n// Print the tag of its parent node\n// Prints 'library'\nb.parentNode.name.println();</code></pre>"},{"location":"doc/articles/plain-xml/#how-do-i-get-the-children-of-an-element","title":"How do I get the children of an element?","text":"<p>You can use the <code>.children</code> read-only property for this.</p> <pre><code>// Get the &lt;library&gt; element\nvar lib = t_library.all.first();\n\n// Iterate through its children\nfor (b in lib.children) {\n    // Print the title of each child\n    b.a_title.println();\n}</code></pre>"},{"location":"doc/articles/plain-xml/#how-do-i-get-child-elements-with-a-specific-tag-name","title":"How do I get child elements with a specific tag name?","text":"<p>Using what you've learned so far, you can do this using a combination of the <code>.children</code> property and the <code>select()</code>/<code>selectOne()</code> operations. However, the driver also supports <code>e_</code> and <code>c_</code>-prefixed shorthand properties for accessing one or a collection of elements with the specified name respectively. <code>e_</code> and <code>c_</code> properties are read-only.</p> <pre><code>// Get a random book\nvar b = t_book.all.random();\n\n// Get its &lt;author&gt; children using the \n// .children property\nvar authors = b.children.select(a|a.name = \"author\");\n\n// Do the same using the shorthand\nauthors = b.c_author;\n\n// Get its &lt;published&gt; child and print\n// its text using the\n// .children property\nb.children.selectOne(p|p.name = \"published\").text.println();\n\n// Do the same using the shorthand\n// (e_ instead of c_ this time as \n// we only want one element, \n// not a collection of them)\nb.e_published.text.println();</code></pre>"},{"location":"doc/articles/plain-xml/#how-do-i-create-an-element","title":"How do I create an element?","text":"<p>You can use the <code>new</code> operator for this. </p> <pre><code>// Check how many &lt;books&gt; are in the library\n// Prints '3'\nt_book.all.size().println();\n\n// Creates a new book element\nvar b = new t_book;\n\n// Check again\n// Prints '4'\nt_book.all.size().println();</code></pre>"},{"location":"doc/articles/plain-xml/#how-can-i-add-a-child-to-an-existing-element","title":"How can I add a child to an existing element?","text":"<p>You can use the <code>.appendChild(child)</code> operation for this.</p> <pre><code>// Create a new book\nvar b = new t_book;\n\n// Get the library element\nvar lib = t_library.all.first();\n\n// Add the book to the library\nlib.appendChild(b);</code></pre>"},{"location":"doc/articles/plain-xml/#how-can-i-set-the-root-element-of-an-xml-document","title":"How can I set the root element of an XML document?","text":"<p>You can use the <code>.root</code> property for this.</p> <pre><code>XMLDoc.root = new t_library;</code></pre> <p>Root element is required</p> <p>When writing scripts that create new XML documents, e.g. ETL, the root element must be set on the output model. This can be done in a <code>pre</code> block (e.g. if the root is not created by a transformation rule) or in a rule/operation/other. For the Library example above (where <code>lib</code> is the model name):  <pre><code>pre {\n    var root = new t_library;\n    lib.root = root;\n}</code></pre> If a root element is not assigned, then the output file will be empty.</p>"},{"location":"doc/articles/plain-xml/#using-xml-attributes-as-references","title":"Using XML attributes as references","text":"<p>The XML model type allows XML attributes to be used as references by using the attribute value as a \"key\" of another element. For example, we could extend the library example to include an author and editor reference on each book, and move authors to the root:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;library&gt;\n&lt;book title=\"EMF Eclipse Modeling Framework\" pages=\"744\" authors=\"DS,FB,MP,EM\" editor=\"EG\"&gt;\n\n&lt;published&gt;2009&lt;/published&gt;\n&lt;/book&gt;\n&lt;book title=\"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages=\"736\" authors=\"RG\"&gt;\n&lt;published&gt;2009&lt;/published&gt;\n&lt;/book&gt;\n&lt;book title=\"Official Eclipse 3.0 FAQs\" pages=\"432\"&gt;\n&lt;author&gt;John Arthorne&lt;/author&gt;\n&lt;author&gt;Chris Laffra&lt;/author&gt;\n&lt;published&gt;2004&lt;/published&gt;\n&lt;/book&gt;\n&lt;author id=\"DS\"&gt;Dave Steinberg&lt;/author&gt;\n&lt;author id=\"FB\"&gt;Frank Budinsky&lt;/author&gt;\n&lt;author id=\"MP\"&gt;Marcelo Paternostro&lt;/author&gt;\n&lt;author id=\"EM\"&gt;Ed Merks&lt;/author&gt;\n&lt;author id=\"RG\"&gt;Richard Gronback&lt;/author&gt;\n&lt;editor id=\"EG\"&gt;Erich Gamma&lt;/editor&gt;\n&lt;/library&gt;\n</code></pre> <p>Note that the attributes used for references must be a comma-separated list of \"keys\".</p> <p>For enabling the references, we need to add the desired bindings to the model. The <code>bind</code> method has the following signature: <code>bind(String sourceTag, String sourceAttribute, String targetTag, String targetAttribute, boolean many)</code>. Thus, for the library example, in EOL this can be done like this:</p> <pre><code>model.bind(\"book\", \"authors\", \"author\", \"id\", true);\nmodel.bind(\"book\", \"editor\", \"editor\", \"name\", false);</code></pre> <p>where <code>model</code> is the name of the model (as specified in the run configuration). These statements should be at the top of the EOL file so the bindings are added before any other code executes. For rule-based languages, this could be done in a <code>pre</code> block. If invoking from java) the bind method can be called on the model variable.</p> <p>After the bindings are in place, we can use them:</p> <pre><code>var lib = t_library.all.first();\n// Prints 4\nlib.c_book.first().authors.size().println();\n// Prints Frank Budinsky\nlib.c_book.first().authors.second().text.println();</code></pre>"},{"location":"doc/articles/plain-xml/#adding-an-xml-document-to-your-launch-configuration","title":"Adding an XML document to your launch configuration","text":"<p>To add an XML document to your Epsilon launch configuration, you need to select \"Plain XML document\" from the list of available model types.</p> <p></p> <p>Then you can configure the details of your document (name, file etc.) in the screen that pops up. To load an XML document that is not in the Eclipse workspace, untick the \"Workspace file\" check box and provide a full URI for your document (e.g. <code>http://api.twitter.com/1/statuses/followers/epsilonews.xml</code> or <code>file:/c:/myxml.xml</code>).</p> <p></p>"},{"location":"doc/articles/plain-xml/#loading-an-xml-document-in-your-ant-buildfile","title":"Loading an XML document in your ANT buildfile","text":"<p>The following ANT build file demonstrates how you can use ANT to load/store and process XML documents with Epsilon.</p> <pre><code>&lt;project default=\"main\"&gt;\n&lt;target name=\"main\"&gt;\n\n&lt;epsilon.xml.loadModel name=\"XMLDoc\" file=\"library.xml\"\nread=\"true\" store=\"false\"/&gt;\n&lt;/epsilon.xml.loadModel&gt;\n\n&lt;epsilon.eol src=\"my.eol\"&gt;\n&lt;model ref=\"XMLDoc\"/&gt;\n&lt;/epsilon.eol&gt;\n\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"doc/articles/plain-xml/#loading-an-xml-document-through-java-code","title":"Loading an XML document through Java code","text":"<p>The following excerpt demonstrates using XML models using Epsilon's Java API.</p> <pre><code>EolModule module = new EolModule();\nmodule.parse(new File(\"...\"));\n\nPlainXmlModel model = new PlainXmlModel();\nmodel.setName(\"M\");\nmodel.setFile(new File(\"...\"));\nmodel.load();\n\nmodule.getContext().getModelRepository().addModel(model);\nmodule.getContext().setModule(module);\nmodule.execute();\n</code></pre>"},{"location":"doc/articles/plain-xml/#additional-resources","title":"Additional resources","text":"<ul> <li>http://java.sun.com/javase/6/docs/api/org/w3c/dom/Element.html: Complete list of the operations that are applicable to XML elements</li> </ul>"},{"location":"doc/articles/playground/","title":"Epsilon Playground","text":"<p>The Epsilon Playground is a web application for fiddling with metamodelling, modelling and automated model management using Emfatic, Flexmi and Epsilon's languages. Its back-end is implemented using Google Cloud Platform Functions and the front-end builds heavily on the Metro 4 framework. Diagrams are rendered using PlantUML and Kroki.</p>"},{"location":"doc/articles/playground/#emfatic-metamodels-in-the-playground","title":"Emfatic Metamodels in the Playground","text":"<p>For metamodelling, the Playground uses Ecore's Emfatic textual syntax, augmented with a couple of annotations to control the graphical appearance of the metamodels.</p> <ul> <li><code>@diagram(direction=\"up/down/left/right/none\")</code>: Can be attached to references (<code>val</code>/<code>ref</code>) and to attributes of enumeration type to specify the direction of the respective edge in the diagram (<code>right</code> by default for non-containment references, <code>left</code> for enumeration-typed attributes, and <code>down</code> for containment references). Setting the direction to <code>none</code> hides the edge.</li> <li><code>@diagram(inheritance.direction=\"up/down/left/right/none\")</code>: Can be attached to classes to specify the direction of its inheritance edges in the diagram (<code>up</code> by default).</li> <li><code>@diagram(color=\"&lt;color&gt;\")</code>: Can be attached to classes and enumerations to specify their color. Specified colors need to follow one of the PlantUML color formats.</li> <li><code>@diagram(monochrome=\"true/false/&lt;color&gt;\")</code>: Can be attached to packages to specify that all their classes/enumerations should be displayed with the same color.</li> </ul> <p>For example, the plain Emfatic metamodel below is rendered as follows:</p> <pre><code>package ptl;\n\nclass Project {\n    attr String name;\n    val Task[*] tasks;\n    val Person[*] people;\n}\n\nabstract class Task {\n    attr String name;\n}\n\nclass ManualTask extends Task {\n    ref Person person;\n}\n\nclass AutomatedTask extends Task {\n\n}\n\nclass Person {\n    attr String name;\n}</code></pre> <p></p> <p>while its annotated version produces the diagram below.</p> <pre><code>package ptl;\n\nclass Project {\n    attr String name;\n    val Task[*] tasks;\n    val Person[*] people;\n}\n\nabstract class Task {\n    attr String name;\n}\n\nclass ManualTask extends Task {\n    @diagram(direction=\"up\")\n    ref Person person;\n}\n\n@diagram(inheritance.direction=\"down\")\nclass AutomatedTask extends Task {\n\n}\n\nclass Person {\n    attr String name;\n}</code></pre> <p></p> <p>Changing the first line to</p> <pre><code>@diagram(monochrome=\"true\")\npackage ptl;</code></pre> <p>produces the monochrome diagram below.</p> <p></p>"},{"location":"doc/articles/playground/#save-and-share-your-work","title":"Save and share your work","text":"<p>To share your work, click the <code>Share</code> button. This will create a short link that you can copy to your clipboard. Please note that the contents of the editors will be stored in the back-end of the Epsilon Playground so that they can be retrieved when you visit that link again later.</p>"},{"location":"doc/articles/playground/#download-your-work","title":"Download your work","text":"<p>To download a zipped archive of your work, click the <code>Download</code> button. Depending on your selection, the zipped archived will contain the model management program(s), the models and metamodels of the example, a <code>readme.md</code> file with instructions as well as:</p> <ul> <li><code>Gradle</code>/<code>Maven</code>: a <code>build.gradle</code> or <code>pom.xml</code> file that includes the Epsilon dependencies and the ANT tasks you need to run the example from the command line</li> <li><code>Ant (Eclipse)</code>: a <code>build.xml</code> file that in includes the ANT tasks you need to run the example from within Eclipse</li> <li><code>Java (Gradle)</code>/<code>Java (Maven)</code>: a Java class that runs the model management program using Epsilon's API, and a <code>build.gradle</code> or <code>pom.xml</code> file that includes the Epsilon dependencies</li> </ul>"},{"location":"doc/articles/playground/#custom-examples","title":"Custom examples","text":"<p>You can launch the Playground with a custom set of examples by appending an <code>examples</code> parameter to the URL, which points to a JSON file that contains your own examples. For instance, this link below launches the Playground with its default set of examples.</p> <p>https://eclipse.org/epsilon/playground/?examples=https://raw.githubusercontent.com/eclipse/epsilon-website/master/mkdocs/docs/playground/examples/examples.json</p> <p>The structure of examples.json should be self-explanatory but if you have any questions, please let us know.</p>"},{"location":"doc/articles/playground/#settings","title":"Settings","text":"<p>Through the <code>Settings</code> dialog, you can show/hide the different panels of the playground as well as line numbers in editors. You can also hide a panel by middle-clicking and maximise/restore it by double-clicking on its title.</p> <p>If you hide the program panel, you can still run the program it contains using the Ctrl+S or Cmd+S keyboard shortcut.</p>"},{"location":"doc/articles/playground/#docker-container","title":"Docker container","text":"<p>If the Playground is a critical dependency for you (e.g. to support a training course), you may want to run your own instance through a Docker container. Despite using automated testing with Cypress, as we are evolving the Playground, we may indadvertedly introduce regressions that break the Playground and make (parts of it) unusable for a period of time.</p>"},{"location":"doc/articles/playground/#fair-usage-policy","title":"Fair usage policy","text":"<p>The cost of running Epsilon Playground is proportional to the number of requests made to its Google Cloud Platform back-end (i.e. execution of programs and rendering of diagrams). With fair usage we can comfortably afford this cost and keep the Playground operational, but in case of excessive use we may have to take it down with no notice. To keep costs down, server-side operations that take more than 60 seconds to complete are automatically terminated. For extensive use, large models, or complex programs, please use the development tools / Java libraries provided on the Epsilon website instead, or run your own instance of the Epsilon Playground in a Docker container.</p>"},{"location":"doc/articles/playground/#reporting-bugs-and-requesting-help","title":"Reporting bugs and requesting help","text":"<p>Please submit bug reports using GitHub Issues and ask for help in Epsilon's forum. You can submit feature requests too but please keep in mind that the Playground is not a replacement for Epsilon's Eclipse-based development tools. The Playground has been tested on recent versions of Firefox and Chrome. It's unlikely that we'll be able to invest too much effort in making it compatible with older/other browsers but any pull requests you may be able to contribute are always welcome.</p>"},{"location":"doc/articles/preparing-the-macosx-distribution/","title":"Preparing the MacOSX distribution","text":"<ul> <li>Build the distribution locally</li> <li>Compress it using the following terminal command <code>zip -r -X epsilon-1.x-unsigned.zip Eclipse.app/</code></li> <li>Upload the zip file to build.eclipse.org</li> <li>Update and run the https://ci.eclipse.org/epsilon/job/macosx-app-signing</li> <li>Download the signed zip file locally</li> <li>Extract the signed Eclipse.app from the zip file using the following terminal command <code>unzip epsilon-1.5-signed.zip</code></li> <li>Use Disk Utility to create a .dmg image that contains the extracted Eclipse.app</li> </ul>"},{"location":"doc/articles/profiled-uml-models/","title":"Managing Profiled UML Models in Epsilon","text":"<p>This article shows how to create and query profiled Eclipse UML models using Epsilon's core language (EOL). For our example we will use a profile called <code>ActivityFunctions</code> which contains a single <code>Function</code> stereotype that applies to UML activities, and has a single <code>body</code> String property.</p>"},{"location":"doc/articles/profiled-uml-models/#creating-a-profiled-uml-model","title":"Creating a Profiled UML Model","text":"<p>In the run configuration of our EOL program we need to add two models of type UML</p> <ul> <li><code>UML</code>: The profiled model we wish to create. This model should not be read on load but should be stored on disposal (i.e. when the EOL program finishes).</li> <li><code>ActivityFunctionsProfile</code>: The model containing the <code>ActivityFunctions</code> profile that we wish to apply to the <code>UML</code> model. This model should be read on load but not stored on disposal (since we don't really want to make any changes to it).</li> </ul> <p>The EOL program that creates and populates our <code>UML</code> model looks as follows.</p> <pre><code>// Get hold of the ActivityFunctions profile\n// that contains the Function stereotype\nvar profile = ActivityFunctionsProfile!Profile.all.first();\n\n// Get hold of the Function stereotype\nvar functionStereotype = profile.getPackagedElement(\"Function\");\n\n// Create a new plain UML Model element\nvar newModel : new UML!Model(name=\"NewModel\");\n// Apply the ActivityFunctions profile to it\nnewModel.applyProfile(profile);\n\n// Create a new plain UML Activity element\nvar newActivity : new UML!Activity(name=\"NewActivity\");\n// ... add it as a child of the Model created above\nnewModel.packagedElement.add(newActivity);\n\n// ... and apply the Function stereotype to it\nvar newFunction = newActivity.applyStereotype(functionStereotype);\n// Set the value of the body property of the Function stereotype\nnewFunction.body = \"return 42;\";</code></pre> <p>At this point, if we try to query <code>Function.all</code>, the call will fail as the <code>UML</code> model is unaware of the <code>Function</code> type. To remedy this, we need to get hold of the <code>EPackage</code> representation of the <code>ActivityProfile</code> and add it to the package registry of the <code>UML</code> model as follows.</p> <pre><code>// Get hold of the EPackage representation of the ActivityProfile\nvar profileEPackage = newModel.profileApplications.first().appliedDefinition;\n// ... and add it to the package registry of our UML model\nUML.resource.resourceSet.packageRegistry.\n    put(profileEPackage.nsURI, profileEPackage);</code></pre> <p>Once we have done this, we can query use all the stereotypes in the profile (i.e. <code>Function</code> in this case) as regular types, as shown below.</p> <pre><code>// Gets hold of the Function stereotype\n// application we created above\nnewFunction = UML!Function.all.first();\nnewFunction.body.println();\n\n// The function and its underlying activity are still\n// two separate elements in the model, linked via\n// the function's base_Activity reference\nnewFunction.base_Activity.name.println();</code></pre>"},{"location":"doc/articles/profiled-uml-models/#querying-a-profiled-uml-model","title":"Querying a Profiled UML Model","text":"<p>Querying a profiled UML model (such as the one we created using the program above) is much simpler as the <code>EPackage</code> representations of its applied profiles are automatically put in the package registry of the model during loading. As such we, can query the model as follows.</p> <pre><code>var func = Function.all.first();\nfunc.body.println();\nvar activity = func.base_Activity;\nactivity.name.println();</code></pre>"},{"location":"doc/articles/profiled-uml-models/#plugin-based-profiles","title":"Plugin-Based Profiles","text":"<p>In our example, the profile we wish to apply to our model is located in a file that resides in the same workspace as our <code>UML</code> model. If we need to use a profile contributed by a plugin instead (e.g. the built-in UML Ecore profile), this can be achieved as follows.</p> <pre><code>var umlTool : new Native(\"org.eclipse.epsilon.emc.uml.dt.UMLTool\");\nvar ecoreProfile = umlTool.getProfile\n    (\"http://www.eclipse.org/uml2/schemas/Ecore/5\");\n// or \n// var ecoreProfile = umlTool.getProfileFromPathmapUri\n//  (\"pathmap://UML_PROFILES/Ecore.profile.uml\").println();\n</code></pre>"},{"location":"doc/articles/profiled-uml-models/#profiled-uml-models-in-rule-based-epsilon-languages","title":"Profiled UML Models in Rule-Based Epsilon Languages","text":"<p>In rule-based languages such as ETL and EVL, any required profiles must be applied in a <code>pre</code> block, before any of the rules (e.g. transformation rules, validation constraints) that refer to types in the profile are executed.</p>"},{"location":"doc/articles/profiled-uml-models/#resources","title":"Resources","text":"<p>The complete source code for this example is available in Epsilon's Git repository.</p>"},{"location":"doc/articles/profiling/","title":"Profiling Epsilon Programs","text":"<p>The purpose of this article is to provide an overview and a usage example of the Epsilon profiling tools. Profiling is particularly useful in order to obtain metrics for theperformance of Epsilon code, and to identify blocks of code that are either executed more often than anticipated or take too much time to execute.</p>"},{"location":"doc/articles/profiling/#adding-profiling-statements-to-your-epsilon-code","title":"Adding profiling statements to your Epsilon code","text":"<p>Code-level support for profiling in Epsilon has been implemented in the form of a tool called <code>ProfilerTool</code> (<code>org.eclipse.epsilon.eol.tools.ProfilerTool</code>). To add support for profiling in your Epsilon program you must instantiate the tool and call its <code>start()</code> and <code>stop()</code> methods. The following EOL example contains an operation <code>fib()</code> that calculates the Fibonacci number of a given integer, and a call to the <code>fib()</code> operation with an initial value of 15.</p> <pre><code>15.fib();\noperation Integer fib() : Integer {\n  var fib : Integer;\n  if (self = 1 or self = 0){ \n    fib = 1;\n  } else {\n    fib = (self-1).fib()+(self-2).fib();\n  }\n  return fib;\n}</code></pre> <p>Our aim in this example is to enrich the program with profiling statements so that we canget to know how many times the <code>fib()</code> operation is executed and how much time each calltakes to execute. To achieve this we modify our program as follows:</p> <pre><code>var profiler : new Native(\"org.eclipse.epsilon.eol.tools.ProfilerTool\");\nprofiler.start(\"Program\");\n15.fib();\nprofiler.stop();\n\noperation Integer fib() : Integer {\n  profiler.start(\"fib\",self);\n  var fib : Integer;\n  if (self = 1 or self = 0){ \n    fib = 1;\n  } else {\n    fib = (self-1).fib()+(self-2).fib();\n  }\n  profiler.stop();\n  return fib;\n}</code></pre> <p>We add an instantiation statement that creates a new instance of the <code>ProfilerTool</code> in Line 1. Then we define two profiling targets. The first one is called \"Program\" and measures the performance of line 3 and the second one is called \"fib\" and measures the performance of the body of the <code>fib()</code> operation. Note that the first call to the <code>start()</code> method has only one argument (the mandatory <code>targetName : String</code> argument) while the second one has an additional argument. This extra (optional) argument (<code>data : Any</code>) enables users to capture context-specific information where multiple calls to the specific <code>start()</code> method are anticipated. In our example, we store the value of the integer on which the operation is executed (<code>self</code>). Here we should note that since profiling has been implemented in the context of EOL, the same technique can be used to profile code in all task-specific languages of Epsilon (ETL, ECL, EML etc).</p>"},{"location":"doc/articles/profiling/#inspecting-profiling-information","title":"Inspecting Profiling Information","text":"<p>Once we've executed the program, we can inspect the profiling information gathered, by activating the \"Profiling\" Eclipse view. Upon activation the view will look like this:</p> <p></p> <p>To populate the view with the information gathered during profiling, we click the \"Refresh view\" button in the toolbar of the view. This makes the view look like this:</p> <p></p> <p>From this summary view we see that the Program target has been executed 1 time and has taken 1292 ms to execute. Similarly, the fib target has been executed 1973 times with a total time of 1292 ms and an average of 0.6548. By clicking on the respective column headers of the summary table we can sort the targets by name, # times executed, total execution time etc.</p> <p>To obtain a more detailed view on the profiling data, we can switch to the \"Details\" tab located at the bottom of the view.</p> <p></p> <p>Unlike the table-oriented \"Summary\" view, the \"Details\" view contains a tree-table combination that visualizes each target instance and displays its execution time, the context specific data, as well as the location of the profiling statement in the source code. By default, the children of each target are ordered by execution order. However, by checking the \"Sort children by execution time\" button on the view toolbar we can sort the children by execution time as well. Also, double-clicking a particular target should bring up the respective editor and highlight the line in which the call to the <code>start()</code> method of the ProfilerTool exists.</p>"},{"location":"doc/articles/profiling/#execution-time-measuring-modes","title":"Execution Time Measuring Modes","text":"<p>The Epsilon profiling tools support two different modes for measuring the time each target has consumed to execute. In the individual mode, each target is assigned only the time it has taken to execute itself. In the aggregated mode, the execution time of a target is that of the target itself plus the execution times of its children (recursively). To change between the two modes, we can check/uncheck the \"Show aggregated execution times\" button on the toolbar.</p>"},{"location":"doc/articles/profiling/#enabling-profiling-in-epsilon-run-configurations","title":"Enabling Profiling in Epsilon Run Configurations","text":"<p>You can turn profiling on through the \"Profiling\" tab of the run configuration of your Epsilon program.</p>"},{"location":"doc/articles/profiling/#enabling-profiling-in-epsilon-ant-tasks","title":"Enabling Profiling in Epsilon ANT tasks","text":"<p>In addition to profiling specific code blocks, we can use the Epsilon profiling tools to profile entire model management operations invoked as ANT tasks by setting the optional profile attribute to true. In the following example, we have created an ANT build-file that invokes the Fib.eol EOL program we demonstrated above.</p> <pre><code>&lt;project default=\"main\"&gt;\n&lt;target name=\"main\"&gt;\n&lt;epsilon.eol src=\"Fib.eol\" profile=\"true\"/&gt;\n&lt;/target&gt;\n&lt;/project&gt;\n</code></pre> <p>Executing the ANT build-file and refreshing the following Profiling view makes it look like this:</p> <p></p> <p>We can see that a new target named after the filename of the executed EOL program has been created along with the targets created using the in-line calls to the <code>start()</code> method of the <code>ProfilerTool</code>.</p>"},{"location":"doc/articles/profiling/#enabling-profiling-from-java","title":"Enabling Profiling from Java","text":"<p>It is possible to enable profiling on Epsilon scripts executed through Java, by using the <code>Profiler.INSTANCE</code> from the Epsilon profiling tools in <code>org.eclipse.epsilon.profiling</code>. For details, please consult the JavaBasedProfiler example class on Github.</p> <p>When executed, the code will produce a CSV file with similar content as the \"Profiling\" view in Eclipse. This CSV file can be opened with Excel (using semicolons as column separators), producing this view which shows that 388ms of the overall 395ms were spent across 100 executions of the statement block that starts on column 21 of line 1.</p> <p></p>"},{"location":"doc/articles/profiling/#notes-on-using-the-profiling-tools","title":"Notes on Using the Profiling Tools","text":"<p>The underlying profiler is loosely coupled with Epsilon. This means that it records profiling information when asked to, and which is never cleared automatically. To clear the profile, you must click the \"Reset profiler\" button in the Profiling view.</p> <p>To enable real-time preview of the profiling data as they are being recorded, we have added an \"Auto Refresh\" button to the view. However, this should be used with caution as real-time rendering of the results may lead to (significantly) increased execution times due to the time consumed to actually query the profiler and display the data in the widgets.</p> <p>In regard to the impact of the profiling code on the produced metrics, we have tried to minimize it by using an elaborated stopwatch mechanism. Initial tests have shown that each <code>start()</code> -- <code>stop()</code> pair introduces a 0-10ms overhead of the measured time; however this is only indicative and may vary according to the execution platform.</p>"},{"location":"doc/articles/reflective-emf-tutorial/","title":"Reflective EMF Tutorial","text":"<p>This tutorial demonstrates how to create an EMF Ecore metamodel and a sample model that conforms to it reflectively (i.e. without generating any code).</p>"},{"location":"doc/articles/reflective-emf-tutorial/#prerequisites","title":"Prerequisites","text":"<p>To go through this tutorial you need to first install the Eclipse Modeling Distribution, Epsilon and Emfatic. Installation instructions are available here.</p>"},{"location":"doc/articles/reflective-emf-tutorial/#create-a-new-project","title":"Create a new project","text":"<p>Go to <code>File</code> \u2192 <code>New</code> \u2192 <code>Other...</code> and select <code>General</code> \u2192 <code>Project</code>. Type <code>library</code> as the project name:</p> <p></p>"},{"location":"doc/articles/reflective-emf-tutorial/#create-libraryemf","title":"Create library.emf","text":"<p>Go to <code>File</code> \u2192 <code>New</code> \u2192 <code>Other...</code> and select <code>File</code>. Type <code>library.emf</code> as the file name:</p> <p></p> <p>This is where we'll specify our Ecore metamodel using the Emfatic textual syntax</p>"},{"location":"doc/articles/reflective-emf-tutorial/#add-content-to-libraryemf","title":"Add content to library.emf","text":"<p>Now <code>library.emf</code> should be open and you can copy-paste the following text into it (our sample metamodel) and save.</p> <pre><code>@namespace(uri=\"library\", prefix=\"\")\npackage library;\n\nclass Library {\n   val Writer[*] writers;\n   val Book[*] books;\n}\n\nclass Writer {\n   attr String name;\n   ref Book[*] books;\n}\n\nclass Book {\n   attr String title;\n   attr int pages = 100;\n   attr BookCategory category;\n}\n\nenum BookCategory {\n   Mystery;\n   ScienceFiction;\n   Biography;\n}</code></pre> <p>Now your <code>library.emf</code> editor should look like this:</p> <p></p>"},{"location":"doc/articles/reflective-emf-tutorial/#generate-libraryecore-from-libraryemf","title":"Generate library.ecore from library.emf","text":"<p>The next step is to generate a proper XMI-based Ecore metamodel from the Emfatic textual representation. To do this, you can right-click <code>library.emf</code> and select <code>Generate Ecore model</code> as shown below:</p> <p></p> <p>Once you've done this you should have a new file called <code>library.ecore</code> sitting next to your <code>library.emf</code>. Congratulations! You're half-way there!</p> <p>Tip</p> <p>If at some point you change <code>library.emf</code>, you need to repeat this step in order to update <code>library.ecore</code>.</p>"},{"location":"doc/articles/reflective-emf-tutorial/#register-libraryecore","title":"Register library.ecore","text":"<p>The next step is to let EMF know of the existence of your newly created <code>library.ecore</code> metamodel. To do this, right-click <code>library.ecore</code> and select <code>Register EPackages</code> as shown below:</p> <p></p>"},{"location":"doc/articles/reflective-emf-tutorial/#create-a-model-that-conforms-to-libraryecore","title":"Create a model that conforms to library.ecore","text":"<p>Now we're ready to create models that conform to our new Ecore metamodel! To create a model, go to <code>File</code> \u2192 <code>New</code> \u2192 <code>Other...</code> and select <code>EMF Model</code> as shown below:</p> <p></p> <p>Click <code>Next</code> and set the name of the model to <code>mylibrary.model</code>:</p> <p></p> <p>Then hit the <code>Browse...</code> button next to the <code>Metamodel URI</code> field and select <code>library</code> in the list that pops up:</p> <p></p> <p>Finally, select <code>Library</code> from the <code>Root instance type</code> combo box and hit <code>Finish</code>:</p> <p></p> <p>Now <code>mylibrary.model</code> should be open in a tree-based editor:</p> <p></p>"},{"location":"doc/articles/reflective-emf-tutorial/#add-content-to-mylibrarymodel","title":"Add content to mylibrary.model","text":"<p>To create a new <code>Book</code> under the library, you can right-click it and select <code>New Child</code> \u2192 <code>Books</code> \u2192 <code>Book</code></p> <p></p> <p>To set the title of the new book, you can right-click it and select <code>Show Properties View</code></p> <p></p> <p>Then, in the <code>Title</code> field of the <code>Properties</code> view, you can type the name of the book:</p> <p></p> <p>Congratulations!</p> <p>You've just created your first EMF model!</p>"},{"location":"doc/articles/release-tasks/","title":"Releasing a new version of Epsilon","text":"<p>There are a number of adiministrative and engineering tasks required to release a new verison of Epsilon. It's important to do them in proper order, as described below.</p>"},{"location":"doc/articles/release-tasks/#getting-the-release-approved-by-eclipse","title":"Getting the release approved by Eclipse","text":"<p>Log in to the PMI. Under the \"Releases\" section (right hand side under \"Committer Tools\"), click on \"Create a new release\" and fill in the fields. Note that we typically have a major.minor naming scheme, so for the release name, make sure it's 2 numbers (i.e. don't add a .0 patch number). If it has been more than one year since the last release, a review is required, so the release date should be set at least 8 days later than today. In this case, you will also need to do \"Generate IP log\" for the release.</p> <p>On the release, go to \"Edit\". At a minimum, you should ensure \"The Basics\" section is filled in and correct. For \"IP Due Dilligence Type\", select Type A if you're unsure. The hit \"Save\". When you're happy with it, and it has been more than a year since the last release, you need to submit the release for review.</p>"},{"location":"doc/articles/release-tasks/#updating-orbit-repos","title":"Updating Orbit repos","text":"<p>Before creating the release, it's worth updating links to the Orbit repository used for resolving our dependencies. This commit provides an example of the process, showing which files should be updated.</p>"},{"location":"doc/articles/release-tasks/#managing-the-update-sites","title":"Managing the update sites","text":"<p>When creating a new release, we need to add the update site for this release to the composite. We also need to create a folder containing the javadocs for the release under a directory with the name of the release at the root of the download site. We also need to remove the old release folder (move it to the archive). The new update site for the release is obtained by copying the interim.</p> <p>These tasks are automated by a shell script. Please check this before the release. The main thing you'll need to check are the <code>OldVersion</code> and <code>NewVersion</code> variables. There are two ways this can be run, but in any case, it needs to be run from the CI server. One way is to uncomment the <code>NEW VERSION</code> stage in the Jenkinsfile at the root of the repository, then push to trigger it. The other way is to run the release-logistics Jenkins job. Of course, you should check what is being run first, since if anything is deleted or overwritten, it can't be undone. Login to the CI and then you can check what is being run in Configure. Scroll down to Build and check the Execute shell task, making sure it's the same as that in the shell script in the repo (or whichever looks correct).</p>"},{"location":"doc/articles/release-tasks/#creating-a-new-version-in-the-oomph-installer","title":"Creating a new version in the Oomph installer","text":"<p>The <code>releng/org.eclipse.epsilon.releng/epsilonUse.setup</code> should be updated with the new version. You can copy the Interim version and rename it to the release. The ordering of Product Versions should always be the latest release at the top, then Interim, then older versions. Whichever is at the top will be the default when users try to install Epsilon using Oomph. Of course, the properties for the new version should be changed to match (e.g. the name, description and update site). Check these carefully. A version of Eclipse should also be hard-coded, rather than relying on the latest update site, so pick whichever is the latest Eclipse release and use that.</p>"},{"location":"doc/articles/release-tasks/#build-and-release-to-maven-central","title":"Build and release to Maven Central","text":"<p>See this article.</p>"},{"location":"doc/articles/release-tasks/#tagging-the-release","title":"Tagging the release","text":"<p>You should run <code>git tag x.y</code>, replacing x.y with the version. Then do <code>git push origin x.y</code> (again, <code>x.y</code> is the version). You can verify the tag was pushed by checking the output of <code>git ls-remote --tags origin</code>.</p>"},{"location":"doc/articles/release-tasks/#update-the-website","title":"Update the website","text":"<p>The Epsilon website's Download page should be the only place in the website repo that needs updating. Specifically, you will need to change two source files in the source directory. Add the new release info to <code>all-versions.md</code>. Copy <code>index.md</code> and rename it to the current / old release. Then update <code>index.md</code> to mention the new release. Generally it should be as easy as Find and Replacing the old version with the new one.</p> <p>You should also update the list of Javadoc URLs in <code>mkdocs.yml</code>, adding the link to the previous stable release as the <code>Stable</code> link will now point to the new stable release.</p> <p>Also don't forget to build the static site for changes to take effect.</p>"},{"location":"doc/articles/release-tasks/#bump-up-versions","title":"Bump up versions","text":"<p>Run the following commands from the root of the repository, replacing <code>X.Y.Z</code> with the full version number of the release (where Z is the patch, usually 0). Tycho will automatically take care of updating the Maven and PDE projects (<code>MANIFEST.MF</code>, <code>feature.xml</code> etc.). Note that the standalone POMs (i.e. the <code>pom-plain.xml</code> files) are bumped separately using the third command below. Also note the order: run the Tycho one first, then bump <code>epsilon.version</code>, then run the Tycho versions bump again and it should succeed.</p> <p><code>mvn org.eclipse.tycho:tycho-versions-plugin:set-version -DnewVersion=X.Y.Z-SNAPSHOT</code> <code>mvn versions:set-property -Dproperty=epsilon.version -DnewVersion=X.Y.Z-SNAPSHOT</code> <code>mvn org.eclipse.tycho:tycho-versions-plugin:set-version -DnewVersion=X.Y.Z-SNAPSHOT</code> <code>mvn -f pom-plain.xml versions:set -DnewVersion=X.Y.Z-SNAPSHOT</code></p> <p>You may also need to manually bump up the version of the <code>releng/org.eclipse.epsilon.target</code> project. Specifically, the <code>META-INF/MANIFEST.MF</code>, but it's also worth checking the <code>pom.xml</code> to make sure they're consistent with each other. Also, in the root <code>pom.xml</code> in the repository, there is a property called <code>epsilon.version</code>. Also check <code>org.eclipse.epsilon.test/META-INF/MANIFEST.MF</code>. The build will fail if anything is inconsistent.</p>"},{"location":"doc/articles/release-tasks/#announce-release-on-forum","title":"Announce release on forum","text":"<p>It would be courteous to let users know of the new release, along with the new features, on the Epsilon Forum.</p>"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/","title":"Running Epsilon's Ant Tasks from Command Line","text":"<p>This example project shows how to download, configure and run Epsilon's Ant tasks from the command line using Ant, Maven and Gradle. To debug Epsilon scripts running from these tasks, read these instructions.</p> <p>To run the examples below, you only need to have Ant, Maven or Gradle installed in your system.</p>"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#ant","title":"Ant","text":"<p>When you run the <code>ant</code> command in the root directory of the project, the following will happen:</p> <ul> <li>The build file (<code>build.xml</code>) will download Apache Ivy in a temporary directory</li> <li>Ivy will fetch the required Epsilon jars (also in a temporary directory) from Maven Central/Sonatype</li> <li>The build file will set up Epsilon's Ant tasks</li> <li>The following part of the build file will be executed, which will load an EMF-based model and then run an EOL program against it</li> </ul> <pre><code>&lt;epsilon.emf.loadModel name=\"Library\" modelfile=\"library.model\" metamodelfile=\"library.ecore\"/&gt;\n\n&lt;epsilon.eol&gt;\nfor (writer in Writer.all) {\n        (writer.name + \" wrote \" + writer.books.title.concat(\", \")).println();\n    }\n    &lt;model ref=\"Library\"/&gt;\n&lt;/epsilon.eol&gt;\n</code></pre> <p>If everything goes well, the last few lines of the output of the <code>ant</code> command should look like this:</p> <pre><code>run-epsilon:\n[epsilon.eol] Agatha Christie wrote Endless Night\n\nBUILD SUCCESSFUL\n</code></pre> <p>The complete source code is below and in Epsilon's Git repo.</p> build.xmlivy.xmlivysettings.xml <pre><code>&lt;project default=\"run-epsilon\" xmlns:ivy=\"antlib:org.apache.ivy.ant\"&gt;\n\n&lt;!-- This part of the build file runs our Epsilon tasks --&gt;\n&lt;target name=\"run-epsilon\" depends=\"setup-epsilon\"&gt;\n&lt;!-- Load the library.model EMF model --&gt;\n&lt;epsilon.emf.loadModel name=\"Library\" modelfile=\"library.model\" metamodelfile=\"library.ecore\"/&gt;\n\n&lt;!-- Run library.eol against it --&gt;\n&lt;epsilon.eol src=\"library.eol\"&gt;\n&lt;model ref=\"Library\"/&gt;\n&lt;/epsilon.eol&gt;\n&lt;/target&gt;\n\n&lt;!-- The rest of the build file downloads Ivy, fetches the Epsilon jars and sets up the Epsilon ANT tasks --&gt;\n&lt;property name=\"ivy.version\" value=\"2.5.0\"/&gt;\n&lt;property name=\"ivy.jar.dir\" value=\"${basedir}/ivy\"/&gt;\n&lt;property name=\"ivy.jar.file\" value=\"${ivy.jar.dir}/ivy.jar\"/&gt;\n\n&lt;!-- Downloads Ivy --&gt;\n&lt;target name=\"download-ivy\" unless=\"skip.download\"&gt;\n&lt;mkdir dir=\"${ivy.jar.dir}\"/&gt;\n&lt;get src=\"https://repo1.maven.org/maven2/org/apache/ivy/ivy/${ivy.version}/ivy-${ivy.version}.jar\"\ndest=\"${ivy.jar.file}\" usetimestamp=\"true\"/&gt;\n&lt;/target&gt;\n\n&lt;!-- Sets up the Ivy ANT tasks --&gt;\n&lt;target name=\"setup-ivy\" depends=\"download-ivy\"&gt;\n&lt;path id=\"ivy.lib.path\"&gt;\n&lt;fileset dir=\"${ivy.jar.dir}\" includes=\"*.jar\"/&gt;\n&lt;/path&gt;\n&lt;taskdef resource=\"org/apache/ivy/ant/antlib.xml\"\nuri=\"antlib:org.apache.ivy.ant\" classpathref=\"ivy.lib.path\"/&gt;\n&lt;/target&gt;\n\n&lt;target name=\"setup-epsilon\" depends=\"setup-ivy\"&gt;\n&lt;!-- Uncomment the line below to clear Ivy's cache --&gt;\n&lt;!--ivy:cleancache/--&gt;\n&lt;ivy:settings file=\"ivysettings.xml\" /&gt;\n\n&lt;!-- Fetch all relevant Epsilon jars under lib/binaries --&gt;\n&lt;ivy:retrieve conf=\"binaries\" pattern=\"lib/[conf]/[artifact](-[classifier]).[ext]\"/&gt;\n\n&lt;!-- Construct a path from all the jars under lib/binaries --&gt;\n&lt;path id=\"lib.path\"&gt;\n&lt;fileset dir=\"lib/binaries\" includes=\"*.jar\"/&gt;\n&lt;/path&gt;\n\n&lt;!-- Load the ANT tasks from o.e.e.workflow and o.e.e.workflow.emf using the same classloader --&gt;\n&lt;taskdef classpathref=\"lib.path\" resource=\"org/eclipse/epsilon/workflow/tasks/tasks.xml\" loaderref=\"lib.path.loader\"/&gt;\n\n&lt;taskdef classpathref=\"lib.path\" resource=\"org/eclipse/epsilon/workflow/tasks/emf/tasks.xml\" loaderref=\"lib.path.loader\"/&gt;\n\n&lt;/target&gt;\n\n&lt;/project&gt;\n</code></pre> <pre><code>&lt;ivy-module version=\"2.0\"&gt;\n&lt;info organisation=\"\" module=\"\"/&gt;\n&lt;configurations&gt;\n&lt;conf name=\"binaries\" /&gt;\n&lt;/configurations&gt;\n&lt;dependencies&gt;\n&lt;dependency org=\"org.eclipse.epsilon\" name=\"org.eclipse.epsilon.workflow\" rev=\"2.4.0\" conf=\"binaries-&gt;default\"/&gt;\n&lt;dependency org=\"org.eclipse.epsilon\" name=\"org.eclipse.epsilon.workflow.emf\" rev=\"2.4.0\" conf=\"binaries-&gt;default\"/&gt;\n&lt;exclude artifact=\"org.eclipse.equinox.registry\"/&gt;\n&lt;exclude artifact=\"org.eclipse.core.runtime\"/&gt;\n&lt;/dependencies&gt;\n&lt;/ivy-module&gt;\n</code></pre> <pre><code>&lt;ivysettings&gt;\n\n&lt;settings defaultResolver=\"default-chain\" defaultConflictManager=\"all\" /&gt;\n\n&lt;resolvers&gt;\n&lt;ibiblio name=\"maven-central\"  m2compatible=\"true\" usepoms=\"true\" /&gt;\n&lt;ibiblio name=\"sonatype-snapshots\" root=\"https://oss.sonatype.org/content/repositories/snapshots\" m2compatible=\"true\"/&gt;\n&lt;chain name=\"default-chain\"&gt;\n&lt;resolver ref=\"sonatype-snapshots\"/&gt;\n&lt;resolver ref=\"maven-central\"/&gt;\n&lt;/chain&gt;\n&lt;/resolvers&gt;\n\n&lt;/ivysettings&gt;\n</code></pre>"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#maven","title":"Maven","text":"<p>Since Maven can run Ant tasks, Epsilon Ant tasks can also be executed from a Maven build (<code>mvn clean install</code>) as shown below. </p> pom.xml <pre><code>&lt;project&gt;\n&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n&lt;artifactId&gt;epsilon-maven&lt;/artifactId&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;pluginRepositories&gt;\n&lt;pluginRepository&gt;\n&lt;id&gt;Sonatype&lt;/id&gt;\n&lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;\n&lt;/pluginRepository&gt;\n&lt;/pluginRepositories&gt;\n&lt;build&gt;\n&lt;plugins&gt;\n&lt;plugin&gt;\n&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n&lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;\n&lt;version&gt;3.0.0&lt;/version&gt;\n&lt;executions&gt;\n&lt;execution&gt;\n&lt;phase&gt;compile&lt;/phase&gt;\n&lt;configuration&gt;\n&lt;target&gt;\n&lt;!-- Set up the core Epsilon tasks --&gt;\n&lt;taskdef\nresource=\"org/eclipse/epsilon/workflow/tasks/tasks.xml\"/&gt;\n\n&lt;!-- Set up the Epsilon EMF tasks --&gt;\n&lt;taskdef\nresource=\"org/eclipse/epsilon/workflow/tasks/emf/tasks.xml\"/&gt;\n\n&lt;!-- Load the library.model EMF model --&gt;\n&lt;epsilon.emf.loadModel name=\"Library\"\nmodelfile=\"library.model\"\nmetamodelfile=\"library.ecore\"/&gt;\n\n&lt;!-- Run library.eol against it --&gt;\n&lt;epsilon.eol src=\"library.eol\"&gt;\n&lt;model ref=\"Library\"/&gt;\n&lt;/epsilon.eol&gt;\n\n&lt;!-- Run library.eunit --&gt;\n&lt;epsilon.eunit src=\"library.eunit\"&gt;\n&lt;modelTasks&gt;\n&lt;epsilon.emf.loadModel name=\"A\" metamodelfile=\"library.ecore\" read=\"false\" store=\"false\" modelfile=\"dummyA.model\"/&gt;\n&lt;epsilon.emf.loadModel name=\"B\" metamodelfile=\"library.ecore\" read=\"false\" store=\"false\" modelfile=\"dummyB.model\"/&gt;\n&lt;/modelTasks&gt;\n&lt;comparators&gt;\n&lt;comparator classname=\"org.eclipse.epsilon.eunit.cmp.emf.EMFModelComparator\" /&gt;\n&lt;/comparators&gt;\n&lt;/epsilon.eunit&gt;\n&lt;/target&gt;\n&lt;/configuration&gt;\n&lt;goals&gt;\n&lt;goal&gt;run&lt;/goal&gt;\n&lt;/goals&gt;\n&lt;/execution&gt;\n&lt;/executions&gt;\n&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.workflow&lt;/artifactId&gt;\n&lt;version&gt;2.4.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.workflow.emf&lt;/artifactId&gt;\n&lt;version&gt;2.4.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.eunit.cmp.emf&lt;/artifactId&gt;\n&lt;version&gt;2.4.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n&lt;/plugin&gt;\n&lt;/plugins&gt;\n&lt;/build&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#gradle","title":"Gradle","text":"<p>Since Gradle can also run Ant tasks, Epsilon Ant tasks can also be executed from a Gradle build (<code>gradle run</code>) as shown below.</p> build.gradle <pre><code>configurations {\nepsilon\n}\n\nrepositories {\nmaven {\nurl \"https://oss.sonatype.org/content/repositories/snapshots\"\n}\nmavenCentral()\n}\n\ndependencies {\nepsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0'\nepsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow.emf:2.4.0'\nepsilon 'org.eclipse.epsilon:org.eclipse.epsilon.eunit.cmp.emf:2.4.0'\n}\n\ntask setupEpsilonTasks {\n// Set up the core Epsilon tasks\nant.taskdef(resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml', classpath: configurations.epsilon.asPath, loaderref: 'epsilon')\n// Set up the Epsilon EMF tasks\nant.taskdef(resource: 'org/eclipse/epsilon/workflow/tasks/emf/tasks.xml', classpath: configurations.epsilon.asPath, loaderref: 'epsilon')\n// Set logging level to info so that EOL's println() is not suppressed\nant.lifecycleLogLevel = 'INFO'\n}\n\ntask run {\ndependsOn tasks.setupEpsilonTasks\n// Load the library.model EMF model\nant.'epsilon.emf.loadModel'(name: 'Library', modelfile: 'library.model', metamodelfile: 'library.ecore')\n\n// Run library.eol against it\nant.'epsilon.eol'(src: 'library.eol'){ model(ref: 'Library') }\n\n// Run library.eunit\nant.'epsilon.eunit'(src: 'library.eunit'){\nmodelTasks() {\nant.'epsilon.emf.loadModel'(name: 'A', metamodelfile: 'library.ecore',\nread: 'false', store: 'false', modelfile: 'dummyA.model')\nant.'epsilon.emf.loadModel'(name: 'B', metamodelfile: 'library.ecore',\nread: 'false', store: 'false', modelfile: 'dummyB.model')\n}\ncomparators() {\ncomparator(classname:\n'org.eclipse.epsilon.eunit.cmp.emf.EMFModelComparator')\n}\n}\n}\n</code></pre>"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#flexmi-and-emfatic","title":"Flexmi and Emfatic","text":"<p>You can also use Flexmi instead of XMI (<code>library.flexmi</code> instead of <code>library.model</code>) for the model, and Emfatic instead of Ecore (<code>library.emf</code> instead of <code>library.ecore</code>) by adding the following dependency to your ANT/Maven/Gradle build.</p> Ivy/ANTMavenGradle <pre><code>&lt;dependency org=\"org.eclipse.emfatic\" name=\"org.eclipse.emfatic.core\" rev=\"1.1.0-SNAPSHOT\" conf=\"binaries-&gt;default\"/&gt;\n</code></pre> <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.emfatic&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.emfatic.core&lt;/artifactId&gt;\n&lt;version&gt;1.1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>epsilon 'org.eclipse.emfatic:org.eclipse.emfatic.core:1.1.0-SNAPSHOT'\n</code></pre> <p>A complete Gradle example that uses <code>library.flexmi</code> instead of (the XMI-based) <code>library.model</code>, and <code>library.emf</code> instead of <code>library.ecore</code> is shown below.</p> build.gradlelibrary.eollibrary.flexmilibrary.emf <pre><code>configurations {\nepsilon\n}\n\nrepositories {\nmaven {\nurl \"https://oss.sonatype.org/content/repositories/snapshots\"\n}\nmavenCentral()\n}\n\ndependencies {\nepsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0'\nepsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow.emf:2.4.0'\nepsilon ('org.eclipse.emfatic:org.eclipse.emfatic.core:1.1.0-SNAPSHOT') {\nexclude group: 'org.eclipse.platform'\n}\n}\n\ntask setupEpsilonTasks {\n// Set up the core Epsilon tasks\nant.taskdef(resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml', classpath: configurations.epsilon.asPath, loaderref: 'epsilon')\n// Set up the Epsilon EMF tasks\nant.taskdef(resource: 'org/eclipse/epsilon/workflow/tasks/emf/tasks.xml', classpath: configurations.epsilon.asPath, loaderref: 'epsilon')\n// Set logging level to info so that EOL's println() is not suppressed\nant.lifecycleLogLevel = 'INFO'\n}\n\ntask run {\ndependsOn tasks.setupEpsilonTasks\n// Load the library.flexmi EMF model\nant.'epsilon.emf.loadModel'(name: 'Library', modelfile: '../library.flexmi', metamodelfile: '../library.emf')\n\n// Run library.eol against it\nant.'epsilon.eol'(src: '../library.eol'){ model(ref: 'Library') }\n}\n</code></pre> <pre><code>for (writer in Writer.all) {\n    (writer.name + \" wrote \" + writer.books.title.concat(\", \")).println();\n}</code></pre> <pre><code>&lt;?nsuri library?&gt;\n&lt;library&gt;\n&lt;writer name=\"Agatha Christie\"/&gt;\n&lt;book title=\"Endless Night\" pages=\"224\" author=\"Agatha Christie\"/&gt;\n&lt;/library&gt;\n</code></pre> <pre><code>@namespace(uri=\"library\", prefix=\"\")\npackage library;\n\nclass Library {\n    val Writer[*] writers;\n    val Book[*] books;\n}\n\nclass Writer {\n    attr String name;\n    ref Book[*]#author books;\n}\n\nclass Book {\n    attr String title;\n    attr int pages = 100;\n    attr BookCategory category;\n    ref Writer[1]#books author;\n}\n\nenum BookCategory {\n    Mystery = 0;\n    ScienceFiction = 1;\n    Biography = 2;\n}\n\n</code></pre>"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#excel","title":"Excel","text":"<p>The example below demonstrates using the generic <code>epsilon.loadModel</code> task to run the same EOL program against an Excel spreadsheet.</p> build.gradlemapping.xml <pre><code>configurations {\nepsilon\n}\n\nrepositories {\nmaven {\nurl \"https://oss.sonatype.org/content/repositories/snapshots\"\n}\nmavenCentral()\n}\n\ndependencies {\nepsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0'\nepsilon 'org.eclipse.epsilon:org.eclipse.epsilon.emc.spreadsheets.excel:2.4.0'\n}\n\ntask setupEpsilonTasks {\n// Set up the core Epsilon tasks\nant.taskdef(resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml', classpath: configurations.epsilon.asPath, loaderref: 'epsilon')\n// Set logging level to info so that EOL's println() is not suppressed\nant.lifecycleLogLevel = 'INFO'\n}\n\ntask run {\ndependsOn tasks.setupEpsilonTasks\n// Load the library.xlsx spreadsheet\nant.'epsilon.loadModel'(name: 'Library', impl: 'org.eclipse.epsilon.emc.spreadsheets.excel.ExcelModel'){\nparameter(name: 'SPREADSHEET_FILE', file: 'library.xlsx')\nparameter(name: 'CONFIGURATION_FILE', file: 'mapping.xml')\n}\n\n// Run library.eol against it\nant.'epsilon.eol'(src: '../library.eol'){ model(ref: 'Library') }\n}\n</code></pre> <pre><code>&lt;spreadsheet&gt;\n&lt;worksheet name=\"Writer\"&gt;\n&lt;column name=\"name\"/&gt;\n&lt;column name=\"books\" many=\"true\"/&gt;\n&lt;/worksheet&gt;\n&lt;worksheet name=\"Book\"&gt;\n&lt;column name=\"id\"/&gt;\n&lt;column name=\"title\"/&gt;    &lt;column name=\"pages\" datatype=\"integer\"/&gt;\n&lt;/worksheet&gt;\n&lt;reference source=\"Writer-&gt;books\"\ntarget=\"Book-&gt;id\"/&gt;                    &lt;/spreadsheet&gt;\n</code></pre>"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#uml","title":"UML","text":"<p>Models conforming to the Eclipse UML2 metamodel can be queried as shown below.</p> build.gradleuml.eolmodel.uml <pre><code>configurations {\nepsilon\n}\n\nrepositories {\nmaven {\nurl \"https://repo.eclipse.org/content/repositories/acceleo-releases/\"\n}\nmaven {\nurl \"https://oss.sonatype.org/content/repositories/snapshots\"\n}\nmavenCentral()\n}\n\ndependencies {\nepsilon('org.eclipse.epsilon:org.eclipse.epsilon.emc.uml:2.4.0') {\n// UML2 is broken on Maven Central\nexclude group: 'org.eclipse.uml2'\n}\nepsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0'\n\n// Fetch the UML2 dependencies from repo.eclipse.org instead\nepsilon 'org.eclipse.uml2:org.eclipse.uml2.uml:5.0.1.v20140910-1354'\nepsilon 'org.eclipse.uml2:org.eclipse.uml2.common:2.0.1.v20140910-1354'\nepsilon 'org.eclipse.uml2:org.eclipse.uml2.types:2.0.0.v20140910-1354'\n}\n\ntask setupEpsilonTasks {\n\n// Set up the core Epsilon tasks\nant.taskdef(resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml', classpath: configurations.epsilon.asPath, loaderref: 'epsilon')\n\n// Set logging level to info so that EOL's println() is not suppressed\nant.lifecycleLogLevel = 'INFO'\n}\n\ntask run {\ndependsOn tasks.setupEpsilonTasks\n\n// Load a UML model from model.uml\nant.'epsilon.loadModel'(name: 'UML', impl: 'org.eclipse.epsilon.emc.uml.UmlModel'){\nparameter(name: 'modelFile', file: 'model.uml')\n}\n\n// Run library.eol against it\nant.'epsilon.eol'(src: 'uml.eol'){ model(ref: 'UML') }\n\n}\n</code></pre> <pre><code>// Print the names of all\n// classes in the model\nfor (c in Class.all) {\n    c.name.println();\n}</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xmi:XMI xmi:version=\"2.1\" xmlns:xmi=\"http://schema.omg.org/spec/XMI/2.1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:uml=\"http://www.eclipse.org/uml2/5.0.0/UML\"&gt;\n&lt;uml:Model xmi:id=\"_in3dgJiMEeuzROqeHhotPw\" name=\"umlcddemo\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_in3dgJiMEeuzROqeHhotPw0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_in3dgJiMEeuzROqeHhotPw00\" key=\"uuid\" value=\"_in3dgJiMEeuzROqeHhotPw\"/&gt;\n&lt;details xmi:id=\"_in3dgJiMEeuzROqeHhotPw01\" key=\"author\" value=\"kolovos\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;packageImport xmi:id=\"_in3dgZiMEeuzROqeHhotPw\" importingNamespace=\"_in3dgJiMEeuzROqeHhotPw\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_in3dgZiMEeuzROqeHhotPw0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_in3dgZiMEeuzROqeHhotPw00\" key=\"uuid\" value=\"_in3dgZiMEeuzROqeHhotPw\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;importedPackage href=\"http://www.omg.org/spec/UML/20131001/PrimitiveTypes.xmi#/\"/&gt;\n&lt;/packageImport&gt;\n&lt;packagedElement xsi:type=\"uml:Class\" xmi:id=\"_rAoBcHq6EDmVkdImmyh-dQ\" name=\"Project\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_rAoBcHq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_rAoBcHq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_rAoBcHq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/packagedElement&gt;\n&lt;packagedElement xsi:type=\"uml:Class\" xmi:id=\"_xAOzcHq6EDmVkdImmyh-dQ\" name=\"Task\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_xAOzcHq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_xAOzcHq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_xAOzcHq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/packagedElement&gt;\n&lt;packagedElement xsi:type=\"uml:Association\" xmi:id=\"_yHEfsXq6EDmVkdImmyh-dQ\" name=\"Project_Task\" memberEnd=\"_yHD4oXq6EDmVkdImmyh-dQ _yHCqgHq6EDmVkdImmyh-dQ\" navigableOwnedEnd=\"_yHCqgHq6EDmVkdImmyh-dQ _yHD4oXq6EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_yHEfsXq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_yHEfsXq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_yHEfsXq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;ownedEnd xmi:id=\"_yHCqgHq6EDmVkdImmyh-dQ\" name=\"project\" type=\"_rAoBcHq6EDmVkdImmyh-dQ\" owningAssociation=\"_yHEfsXq6EDmVkdImmyh-dQ\" association=\"_yHEfsXq6EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_yHCqgHq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_yHCqgHq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_yHCqgHq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;lowerValue xsi:type=\"uml:LiteralInteger\" xmi:id=\"_yHDRkHq6EDmVkdImmyh-dQ\" value=\"1\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_yHDRkHq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_yHDRkHq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_yHDRkHq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/lowerValue&gt;\n&lt;upperValue xsi:type=\"uml:LiteralInteger\" xmi:id=\"_yHD4oHq6EDmVkdImmyh-dQ\" value=\"1\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_yHD4oHq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_yHD4oHq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_yHD4oHq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/upperValue&gt;\n&lt;/ownedEnd&gt;\n&lt;ownedEnd xmi:id=\"_yHD4oXq6EDmVkdImmyh-dQ\" name=\"tasks\" type=\"_xAOzcHq6EDmVkdImmyh-dQ\" owningAssociation=\"_yHEfsXq6EDmVkdImmyh-dQ\" association=\"_yHEfsXq6EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_yHD4oXq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_yHD4oXq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_yHD4oXq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;lowerValue xsi:type=\"uml:LiteralInteger\" xmi:id=\"_yHD4onq6EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_yHD4onq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_yHD4onq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_yHD4onq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/lowerValue&gt;\n&lt;upperValue xsi:type=\"uml:LiteralUnlimitedNatural\" xmi:id=\"_zUmCwHq6EDmVkdImmyh-dQ\" value=\"*\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_zUmCwHq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_zUmCwHq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_zUmCwHq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/upperValue&gt;\n&lt;/ownedEnd&gt;\n&lt;/packagedElement&gt;\n&lt;packagedElement xsi:type=\"uml:Class\" xmi:id=\"_86ZfYHq6EDmVkdImmyh-dQ\" name=\"Person\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_86ZfYHq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_86ZfYHq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_86ZfYHq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/packagedElement&gt;\n&lt;packagedElement xsi:type=\"uml:Association\" xmi:id=\"_-j5z0nq6EDmVkdImmyh-dQ\" name=\"Project_Person\" memberEnd=\"_-j5Mwnq6EDmVkdImmyh-dQ _-j4lsnq6EDmVkdImmyh-dQ\" navigableOwnedEnd=\"_-j4lsnq6EDmVkdImmyh-dQ _-j5Mwnq6EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_-j5z0nq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_-j5z0nq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_-j5z0nq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;ownedEnd xmi:id=\"_-j4lsnq6EDmVkdImmyh-dQ\" name=\"project\" type=\"_rAoBcHq6EDmVkdImmyh-dQ\" owningAssociation=\"_-j5z0nq6EDmVkdImmyh-dQ\" association=\"_-j5z0nq6EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_-j4lsnq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_-j4lsnq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_-j4lsnq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;lowerValue xsi:type=\"uml:LiteralInteger\" xmi:id=\"_-j5MwHq6EDmVkdImmyh-dQ\" value=\"1\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_-j5MwHq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_-j5MwHq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_-j5MwHq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/lowerValue&gt;\n&lt;upperValue xsi:type=\"uml:LiteralInteger\" xmi:id=\"_-j5MwXq6EDmVkdImmyh-dQ\" value=\"1\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_-j5MwXq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_-j5MwXq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_-j5MwXq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/upperValue&gt;\n&lt;/ownedEnd&gt;\n&lt;ownedEnd xmi:id=\"_-j5Mwnq6EDmVkdImmyh-dQ\" name=\"persons\" type=\"_86ZfYHq6EDmVkdImmyh-dQ\" owningAssociation=\"_-j5z0nq6EDmVkdImmyh-dQ\" association=\"_-j5z0nq6EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_-j5Mwnq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_-j5Mwnq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_-j5Mwnq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;lowerValue xsi:type=\"uml:LiteralInteger\" xmi:id=\"_-j5z0Hq6EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_-j5z0Hq6EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_-j5z0Hq6EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_-j5z0Hq6EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/lowerValue&gt;\n&lt;upperValue xsi:type=\"uml:LiteralUnlimitedNatural\" xmi:id=\"_Ctk-8Hq7EDmVkdImmyh-dQ\" value=\"*\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_Ctk-8Hq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_Ctk-8Hq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_Ctk-8Hq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/upperValue&gt;\n&lt;/ownedEnd&gt;\n&lt;/packagedElement&gt;\n&lt;packagedElement xsi:type=\"uml:Class\" xmi:id=\"_FYr6UHq7EDmVkdImmyh-dQ\" name=\"Effort\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_FYr6UHq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_FYr6UHq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_FYr6UHq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/packagedElement&gt;\n&lt;packagedElement xsi:type=\"uml:Association\" xmi:id=\"_HOgzgXq7EDmVkdImmyh-dQ\" name=\"Effort_Person\" memberEnd=\"_HOgMcHq7EDmVkdImmyh-dQ _HOeXQnq7EDmVkdImmyh-dQ\" navigableOwnedEnd=\"_HOeXQnq7EDmVkdImmyh-dQ _HOgMcHq7EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_HOgzgXq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_HOgzgXq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_HOgzgXq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;ownedEnd xmi:id=\"_HOeXQnq7EDmVkdImmyh-dQ\" name=\"effort\" type=\"_FYr6UHq7EDmVkdImmyh-dQ\" owningAssociation=\"_HOgzgXq7EDmVkdImmyh-dQ\" association=\"_HOgzgXq7EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_HOeXQnq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_HOeXQnq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_HOeXQnq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;lowerValue xsi:type=\"uml:LiteralInteger\" xmi:id=\"_HOflYHq7EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_HOflYHq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_HOflYHq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_HOflYHq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/lowerValue&gt;\n&lt;upperValue xsi:type=\"uml:LiteralUnlimitedNatural\" xmi:id=\"_N8H7AHq7EDmVkdImmyh-dQ\" value=\"*\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_N8H7AHq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_N8H7AHq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_N8H7AHq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/upperValue&gt;\n&lt;/ownedEnd&gt;\n&lt;ownedEnd xmi:id=\"_HOgMcHq7EDmVkdImmyh-dQ\" name=\"person\" type=\"_86ZfYHq6EDmVkdImmyh-dQ\" owningAssociation=\"_HOgzgXq7EDmVkdImmyh-dQ\" association=\"_HOgzgXq7EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_HOgMcHq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_HOgMcHq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_HOgMcHq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;lowerValue xsi:type=\"uml:LiteralInteger\" xmi:id=\"_HOgMcXq7EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_HOgMcXq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_HOgMcXq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_HOgMcXq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/lowerValue&gt;\n&lt;upperValue xsi:type=\"uml:LiteralInteger\" xmi:id=\"_HOgzgHq7EDmVkdImmyh-dQ\" value=\"1\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_HOgzgHq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_HOgzgHq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_HOgzgHq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/upperValue&gt;\n&lt;/ownedEnd&gt;\n&lt;/packagedElement&gt;\n&lt;packagedElement xsi:type=\"uml:Association\" xmi:id=\"_JLgrt3q7EDmVkdImmyh-dQ\" name=\"Effort_Task\" memberEnd=\"_JLgrtHq7EDmVkdImmyh-dQ _JLgrsXq7EDmVkdImmyh-dQ\" navigableOwnedEnd=\"_JLgrsXq7EDmVkdImmyh-dQ _JLgrtHq7EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_JLgrt3q7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_JLgrt3q7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_JLgrt3q7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;ownedEnd xmi:id=\"_JLgrsXq7EDmVkdImmyh-dQ\" name=\"effort\" type=\"_FYr6UHq7EDmVkdImmyh-dQ\" owningAssociation=\"_JLgrt3q7EDmVkdImmyh-dQ\" association=\"_JLgrt3q7EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_JLgrsXq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_JLgrsXq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_JLgrsXq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;lowerValue xsi:type=\"uml:LiteralInteger\" xmi:id=\"_JLgrsnq7EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_JLgrsnq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_JLgrsnq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_JLgrsnq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/lowerValue&gt;\n&lt;upperValue xsi:type=\"uml:LiteralUnlimitedNatural\" xmi:id=\"_TnCPYHq7EDmVkdImmyh-dQ\" value=\"*\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_TnCPYHq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_TnCPYHq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_TnCPYHq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/upperValue&gt;\n&lt;/ownedEnd&gt;\n&lt;ownedEnd xmi:id=\"_JLgrtHq7EDmVkdImmyh-dQ\" name=\"task\" type=\"_xAOzcHq6EDmVkdImmyh-dQ\" owningAssociation=\"_JLgrt3q7EDmVkdImmyh-dQ\" association=\"_JLgrt3q7EDmVkdImmyh-dQ\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_JLgrtHq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_JLgrtHq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_JLgrtHq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;lowerValue xsi:type=\"uml:LiteralInteger\" xmi:id=\"_JLgrtXq7EDmVkdImmyh-dQ\" value=\"1\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_JLgrtXq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_JLgrtXq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_JLgrtXq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/lowerValue&gt;\n&lt;upperValue xsi:type=\"uml:LiteralInteger\" xmi:id=\"_JLgrtnq7EDmVkdImmyh-dQ\" value=\"1\"&gt;\n&lt;xmi:Extension extender=\"http://www.eclipse.org/emf/2002/Ecore\"&gt;\n&lt;eAnnotations xmi:id=\"_JLgrtnq7EDmVkdImmyh-dQ0\" source=\"genmymodel\"&gt;\n&lt;details xmi:id=\"_JLgrtnq7EDmVkdImmyh-dQ00\" key=\"uuid\" value=\"_JLgrtnq7EDmVkdImmyh-dQ\"/&gt;\n&lt;/eAnnotations&gt;\n&lt;/xmi:Extension&gt;\n&lt;/upperValue&gt;\n&lt;/ownedEnd&gt;\n&lt;/packagedElement&gt;\n&lt;/uml:Model&gt;\n&lt;/xmi:XMI&gt;\n</code></pre>"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#genmymodel","title":"GenMyModel","text":"<p>GenMyModel is a web-based modelling tool that can be used to create UML2-compliant models. You can consume the XMI representation of a public GenMyModel UML model directly from Epsilon as shown below.</p> build.gradle <pre><code>configurations {\nepsilon\n}\n\nrepositories {\nmaven {\nurl \"https://repo.eclipse.org/content/repositories/acceleo-releases/\"\n}\nmaven {\nurl \"https://oss.sonatype.org/content/repositories/snapshots\"\n}\nmavenCentral()\n}\n\ndependencies {\nepsilon('org.eclipse.epsilon:org.eclipse.epsilon.emc.uml:2.4.0') {\n// UML2 is broken on Maven Central\nexclude group: 'org.eclipse.uml2'\n}\nepsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0'\n\n// Fetch the UML2 dependencies from repo.eclipse.org instead\nepsilon 'org.eclipse.uml2:org.eclipse.uml2.uml:5.0.1.v20140910-1354'\nepsilon 'org.eclipse.uml2:org.eclipse.uml2.common:2.0.1.v20140910-1354'\nepsilon 'org.eclipse.uml2:org.eclipse.uml2.types:2.0.0.v20140910-1354'\n}\n\ntask setupEpsilonTasks {\n\n// Set up the core Epsilon tasks\nant.taskdef(resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml', classpath: configurations.epsilon.asPath, loaderref: 'epsilon')\n\n// Set logging level to info so that EOL's println() is not suppressed\nant.lifecycleLogLevel = 'INFO'\n}\n\ntask run {\ndependsOn tasks.setupEpsilonTasks\n\n// Load a UML model straight from GenMyModel\nant.'epsilon.loadModel'(name: 'UML', impl: 'org.eclipse.epsilon.emc.uml.UmlModel'){\nparameter(name: 'modelUri', value: 'https://app.genmymodel.com/api/projects/_in3dgJiMEeuzROqeHhotPw/custom-xmi')\n}\n\n// Run library.eol against it\nant.'epsilon.eol'(src: '../uml.eol'){ model(ref: 'UML') }\n\n\n}\n</code></pre>"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#epsilon-1x","title":"Epsilon 1.x","text":"<p>If you would like to use an older (1.x) version of Epsilon, you can use this example instead, which uses a fat jar we used to produce (<code>epsilon-1.x-kitchensink.jar</code>) before moving all our jars to Maven Central/Sonatype.</p>"},{"location":"doc/articles/running-from-source/","title":"Running Epsilon from Source","text":"<p>To run Epsilon from source, you need to:</p> <ul> <li>Download a copy of the latest version of Eclipse and select the \"Eclipse IDE for Eclipse Committers\" option when prompted during the installation process.</li> <li>Clone the Git repository from <code>https://github.com/eclipse/epsilon</code></li> <li>Import all the projects under the <code>plugins</code>, <code>features</code>, and <code>tests</code> folders in your workspace.</li> <li>(optional) To organise your workspace, you can create working sets. For example, you could create three working sets that mirror the contents of the folders above (<code>plugins</code>, <code>features</code>, and <code>tests</code>).</li> <li>Open <code>releng/org.eclipse.epsilon.target/org.eclipse.epsilon.target.target</code> and click the \"Set as Active Target Platform\" link on the top right</li> <li>Set the JDK compliance level to 1.8. This setting can be found in Window/Preferences/Java/Compiler</li> <li>Right-click on any Epsilon plugin project in the Project Explorer and select Run as \u2192 Eclipse Application</li> </ul> <p>Using your own Eclipse IDE and Maven m2e integration</p> <p>If you would prefer to keep using your own Eclipse IDE instance instead of downloading a new one, please keep in mind that the target platform of the current interim version of Epsilon uses recent features to pull some dependencies directly from Maven Central. To use this target platform, you must install the latest version of the m2e integration plugin, which can be found here: https://download.eclipse.org/technology/m2e/releases/latest</p> <p>Managing the target platform with the CBI Target Platform Definition DSL</p> <p>If needed, you can modify the target platform using the integrated editor provided by Eclipse when opening the <code>org.eclipse.epsilon.target.target</code> file. Alternatively, you can use the Target Platform Definition DSL provided by Eclipse CBI. The <code>org.eclipse.epsilon.target.target.tpd</code> file contains a target platform specified with this DSL, and used to auto-generate the <code>.target</code> version.</p>"},{"location":"doc/articles/running-from-source/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>The execution engines for the various Epsilon languages are located in <code>org.eclipse.epsilon.*.engine</code> plugins. These are Eclipse-independent.</li> <li>Plugins named <code>*.dt</code> contain development tools (e.g. editors, run configurations, debuggers) for the respective Epsilon languages.</li> <li>Plugins named <code>org.eclipse.epsilon.emc.*</code> contain Epsilon Model Connectivity (EMC) drivers through which Epsilon languages can interact with different types of models (e.g. EMF models, spreadsheets etc.)</li> <li>Plugins named <code>org.eclipse.epsilon.emc.*.dt</code> contain development tools (e.g. model configuration dialogs) for the respective EMC drivers.</li> <li>Plugins named <code>*.workflow</code> contribute ANT tasks.</li> </ul>"},{"location":"doc/articles/running-from-source/#modifying-the-epsilon-parsers","title":"Modifying the Epsilon parsers","text":"<ul> <li>Before you can regenerate the Epsilon parsers, you need to clone the epsilon-antlr-dev Git repo into a sibling folder of the Epsilon repo.</li> <li>To modify e.g. the EVL parser, you need to change <code>Evl.g</code> and/or <code>EvlParserRules.g</code>. To re-generate the parser you need to run <code>build-evl-parser.xml</code> as an Ant build.</li> <li>Since all Epsilon languages extend EOL, if you modify the EOL parser, you'll then need to run <code>build-all-eol-dependent-parsers.xml</code></li> </ul>"},{"location":"doc/articles/running-from-source/#running-the-epsilon-tests","title":"Running the Epsilon tests","text":"<ul> <li>After making any changes to the Epsilon source code, you're advised to run the Epsilon test suites to avoid regressions. Epsilon provides two main test suites: <code>EpsilonTestSuite</code> and <code>EpsilonPluggedInTestSuite</code> (the latter needs to be run as a <code>JUnit Plug-In Test</code>)</li> </ul>"},{"location":"doc/articles/simulink/","title":"Scripting Simulink models using Epsilon","text":"<p>In this article we demonstrate how you can create, query and modify Simulink models in Epsilon programs. While the example in this article demonstrates using EOL to script Simulink models, it's worth stressing that Simulink models are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models - Simulink or EMF-based -, or to text), compare and merge your Simulink models.</p> <p>Warning</p> <p>The Simulink driver only works with Java 8 for versions of MATLAB before 2021a. This is due to a limitation of the official MATLAB Java API.</p>"},{"location":"doc/articles/simulink/#installation","title":"Installation","text":"<p>The first time you run Eclipse after installing the Simulink driver you will need to point it to the location of your Matlab installation through the Eclipse <code>Preferences\u2192Epsilon\u2192Simulink</code> dialog. In particular, you need to specify the location of the <code>&lt;matlab-root&gt;/bin/win64</code> (or <code>/bin/maci64</code> if you are on Mac OS) directory and Matlab's <code>engine.jar</code> as shown below. Note that in most cases, if you installed MATLAB in the default location for your operating system, the paths should be automatically detected, and if not you should usually only need to set the MATLAB root directory in your preferences.</p> <p></p>"},{"location":"doc/articles/simulink/#troubleshooting-notes","title":"Troubleshooting / Notes","text":"<ul> <li>The driver has been developed and tested with Matlab_R2017a and may not work with older versions of Matlab (<code>engine.jar</code> was introduced fairly recently).</li> <li>If you start getting strange errors about dynamic libraries, chances are that the Matlab paths above are wrong. If restarting Eclipse and correcting the paths doesn't solve this, please post a message to the forum.</li> <li>If you are on Windows, ensure that <code>&lt;matlab-root&gt;/bin/win64</code> is in the system path (in Windows' Environment Variables).</li> <li>In some cases, you may need to use the same Java runtime (JRE) as your MATLAB installation. For example in Windows, the path to MATLAB's Java is <code>&lt;matlab-root&gt;/sys/java/jre/win64/jre</code>. To configure an alternative JRE, please set the <code>MATLAB_JAVA</code> environment variable to point to a compatible JRE, and ensure that both your Eclipse and MATLAB are using the same JRE version.</li> <li>If you are having trouble configuring the MATLAB paths from the UI (or no alternative configuration method is available), you can set the \"org.eclipse.epsilon.emc.matlab_path\" environment variable to point to your MATLAB installation.</li> </ul>"},{"location":"doc/articles/simulink/#quick-start","title":"Quick start","text":"<ul> <li>Create a new General project</li> <li>Create an empty Simulink model in the project (e.g. <code>empty.slx</code>)</li> <li>Create a new EOL file (e.g. <code>demo.eol</code>) and add the content below to     it:</li> </ul> <pre><code>// Create elements\nvar sineWave = new `simulink/Sources/Sine Wave`;\nvar gain = new `simulink/Math Operations/Gain`;\nvar saturation = new `simulink/Discontinuities/Saturation`;\nvar busCreator = new `simulink/Signal Routing/Bus Creator`;\nvar scope = new `simulink/Sinks/Scope`;\n\n// Position them on the diagram\nsineWave.position = \"[100 100 130 130]\";\ngain.position = \"[200 100 230 130]\";\nsaturation.position = \"[300 100 330 130]\";\nbusCreator.position = \"[400 70 410 300]\";\nscope.position = \"[500 175 530 205]\";\n\n// Set their properties\ngain.gain = 2;\nbusCreator.inputs = 3;\n\n// Link them\nsineWave.link(gain);\ngain.link(saturation);\nsaturation.link(busCreator);\ngain.linkTo(busCreator, 2);\nsineWave.linkTo(busCreator, 3);\nbusCreator.link(scope);</code></pre> <ul> <li>Create a new Run configuration for your EOL program and add a Simulink model to it, pointing at your .slx (e.g. <code>empty.slx</code>) model</li> <li>Launch the Run configuration. Simulink should pop up and you should see the model below (which you can edit/run as normal)</li> </ul>"},{"location":"doc/articles/simulink-stateflow/","title":"Managing Matlab Simulink/Stateflow models from Epsilon","text":"<p>Epsilon supports Matlab Simulink models. This tutorial shows you how to manipulate Simulink and Stateflow blocks from within Epsilon.</p> <p>Warning</p> <p>The Simulink driver only works with Java 8 for versions of MATLAB before 2021a. This is due to a limitation of the official MATLAB Java API. Support for Java 11 with MATLAB &gt;= 2021a was added in Epsilon 2.5.</p>"},{"location":"doc/articles/simulink-stateflow/#pre-requisite-setting-up-your-eclipse-installation","title":"[Pre-requisite] Setting up your Eclipse Installation","text":"<p>Help &gt; Install New Software...</p> <p>In your eclipse installation make sure to go to Help &gt; Install New Software... and in the pop up window add the Epsilon's Update Site and select the \"Epsilon Simulink Integration\" and proceed with the installation. Make sure that you have \"Epsilon Core\", \"Epsilon Core Developement Tools\" and their dependencies already Installed. Click here for more details.</p> <p>Once installed, make sure to add to the Eclipse Preferences (Eclipse &gt; Preferences...) the path of the Simulink library directory and the Matlab Engine Jar. You will find them in the Preference dialog under the tabs Epsilon &gt; Simulink.</p> <p>For MATLAB version R2017a, the OSX paths for both are those in the figure below, whereas for Windows machines, the paths are as follow:</p> <ul> <li><code>C:/Program Files/MATLAB/R2017b/bin/win64</code></li> <li><code>C:/Program Files/MATLAB/R2017b/extern/engines/java/jar/engine.jar</code></li> </ul> <p></p>"},{"location":"doc/articles/simulink-stateflow/#loadingcreating-a-simulink-file-as-a-model","title":"Loading/Creating a Simulink File as a model","text":"<p>Depending on what epsilon language you would like to run (EOL, EGL, ETL, EVL, etc.) you will have to create the corresponding \"Run Configuration\" (EOL Program, EGL Generator, ETL Transformation, EVL validation, etc.)</p> <p></p> <p>Different types of Run Configurations</p> <p>Once you create an epsilon-based run configuration, in the \"Models\" tab you should be able to add a Simulink Model.</p> <p></p> <p>In the model configuration window you may choose:</p> <ul> <li>Simulink File: The simulink file to read from or to store after the execution.</li> <li>Hide Editor: Do not open the Matlab Simulink editor if it is closed. Either option won't close the editor if it is opened.</li> <li>Read on Load: read the contents of the file before the execution.</li> <li>Store on Disposal: close without saving the changes to the file after the execution</li> </ul> <p></p> <p>Model configuration window</p>"},{"location":"doc/articles/simulink-stateflow/#creating-blocks","title":"Creating blocks","text":"<p>Icon of the Simulink \"Library Browser\"</p> <p></p> <p>The Step Block is found under Simulink/Sources/Step and therefore created as new <code>simulink/Sources/Step</code>; To create Simulink Blocks you may instantiate them using the following syntax. The full path of the block matches their location in the Simulink \"Library Browser\". The EOL syntax to create this blocks is as follows:</p> <pre><code>var step = new `simulink/Sources/Step`;\nvar sum = new `simulink/Math Operations/Sum`;\nvar chart = new `sflib/Chart`;</code></pre> <p>In contrast to Simulink Blocks, Stateflow Blocks don't require the full library path but have to be instantiated with the Stateflow prefix (e.g. <code>Stateflow.${Block_Type}</code>). These blocks also need to have a parent and there are three options to do this with the Epsilon driver.</p> <pre><code>// Pass the parent as an argument of the constructor \nnew `Stateflow.State`(parent);\n\n// Add the child to the parent \nvar state= new `Stateflow.State`; \nparent.add(state);\n\n// Set the parent as an object attribute \nvar state= new `Stateflow.State`;\nstate.parent = parent;</code></pre>"},{"location":"doc/articles/simulink-stateflow/#child-blocks","title":"Child Blocks","text":"<p>You can also retrieve the child blocks of a given Simulink or Stateflow block using either syntax for both kinds of blocks:</p> <pre><code>state.getChildren();\nchart.children;</code></pre> <p>Note that Stateflow Blocks will return Stateflow Blocks as children and Simulink Blocks will return their Simulink children Blocks.</p>"},{"location":"doc/articles/simulink-stateflow/#querying-for-existing-blocks","title":"Querying for existing blocks","text":"<p>If your Simulink file had preexisting blocks or if you just created some with your EOL script, then you may query for all the blocks of a given type.</p> <p>For Simulink Blocks you may do this without having to specify their full path.</p> <pre><code>// var sum = new `simulink/Math Operations/Sum`; // Full path \nvar sumBlockList = Sum.all; // Type only</code></pre> <p>For Stateflow Blocks you must specify the fully qualified type i.e. the same used for creation:</p> <pre><code>// var state= new `Stateflow.State`; // Fully qualified type\nvar stateBlockList = `Stateflow.State`.all; </code></pre> <p>Be aware that some Simulink Blocks have different \"BlockTypes\" than the path used for their construction.</p> <pre><code>var pidController = new `simulink/Continuous/PID Controller`; \nvar subsystemBlockList = SubSystem.all; // Includes PID Controller\n// PIDController.all or `PID Controller`.all would return an error\nvar transferFcn = new `simulink/Continuous/Transfer Fcn`;\nvar transferFcnBlockList = TransferFcn.all; // Removed the space</code></pre> <p>You may find the real Simulink Block type of the element by retrieving the \"BlockType\" property of the Simulink Block.</p> <pre><code>var pidController = new `simulink/Continuous/PID Controller`;\npidController.BlockType.println; // prints \"SubSystem\"</code></pre> <p>Note that Simulink and Stateflow Block types are case sensitive for instantiation and collection.</p>"},{"location":"doc/articles/simulink-stateflow/#reading-and-updating-the-block-properties","title":"Reading and Updating the block properties","text":"<p>You may read and update properties of Simulink and Stateflow blocks as follows:</p> <pre><code>state.Name = \"State A\"; // Set\nstate.name.println; // Get</code></pre> <p>You may also set and get positioning attributes.</p> <pre><code>state.Position = \"[50 50 310 200]\"; // Set (receives a string type)\nvar seq = state.position; // Get position (returns a sequence type)\nassert(seq.at(0) = 50); // element 0 of state block position</code></pre> <p>Note that properties are case insensitive.</p>"},{"location":"doc/articles/simulink-stateflow/#deleting-blocks","title":"Deleting blocks","text":"<p>You can also delete blocks using the following syntax:</p> <pre><code>delete state; // `Stateflow.State`\ndelete chart; // `sflib/Chart`</code></pre>"},{"location":"doc/articles/simulink-stateflow/#summary","title":"Summary","text":"<p>In this tutorial we've seen how to create, read, update, and delete Simulink and Stateflow block types in epsilon and also how to set up your eclipse installation to be able to run epsilon-based scripts on Simulink files loaded as models.</p> <p>For further information on how to perform more complex operations with epsilon have a look at Epsilon's website or Epsilon's book. For more examples with the Simulink/Stateflow Epsilon Driver have a look at this folder in the official epsilon repository.</p>"},{"location":"doc/articles/target-platform/","title":"Managing the target platform","text":"<p>Epsilon stable and interim releases are built using Eclipse Tycho, which repurposes Apache Maven for automating the build of Eclipse plugins, features and update sites. Maven builds are launched automatically by the Epsilon Jenkins instance whenever a change in the <code>main</code> branch of the Epsilon Git repository is detected.</p> <p>Tycho requires defining a \"target platform\" with the Eclipse plugins and features that Epsilon should be compiled against. In the case of Epsilon, this target platform will usually include EMF, GMF, the Eclipse IDE and PDE, Emfatic, and then any other third-party components that might be useful (e.g. Sirius or Papyrus). The target platform is stored in the plugins/org.eclipse.epsilon.targetplatform.target project.</p> <p>The target platform is an XML file that lists features or plugins from one or more update sites. It can be edited by hand, but it is rather unwieldy, so it is better to open it from Eclipse. A working Internet connection is needed to edit these files. Once you open the file, Eclipse will spend some time downloading features and plugins from the update sites and resolving dependencies. After it is done, you should see something like this:</p> <p></p> <p>In the picture, we can see three update sites (main Luna release, Luna updates and Emfatic), with some features pulled from them. In general, it is better to define target platforms at the feature level rather than at the plugin level, as they tend to be more stable across releases: it's better to pull in a few extra plugins than have the whole thing break because of a single missing plugin.</p> <p>One important restriction is that even though Eclipse allows for adding local folders as part of the target platform, these are rejected by Tycho. Tycho only supports URL-based update sites in target platform definitions: should you need a custom plugin for building Eclipse, it will have to be placed in an update site and hosted somewhere. If it is part of a well-known open source project, it may make sense to see if one of the Orbit update sites already has it: additionally, those bundles have already gone through the legal processes set by the Eclipse Foundation.</p> <p>To check if the target platform has everything we need, we should follow these steps:</p> <ol> <li>Import the rest of the Epsilon source code into our workspace.</li> <li>Go to the target platform editor after resolution is done and click on \"Set Target Platform\".</li> <li>Wait for everything to be rebuilt, and check there are no compilation errors due to missing dependencies.</li> </ol> <p>Should we miss some dependencies, we can either \"Edit...\" one of the locations to include more things from it, or we can \"Add...\" a location with new things. It is OK to add the same location multiple times. Keep in mind that recent versions of Eclipse have an issue with the \"Edit...\" button where you will need to wait a few seconds until Eclipse ticks again all the things we previously had from that location - if you don't wait, you will lose the features that were previously selected!</p> <p>After any changes are made to the target platform definition and saved, Eclipse will take a bit to resolve again everything. It's a good idea to make changes in small increments, in case there is a resolution problem and the definition has to be rolled back.</p> <p>Even if everything compiles, it's a good idea to double check in the \"Content\" tab if the specific plugins and versions we wanted are in there. Sometimes, it may not be obvious which features contribute which plugin.</p> <p>Once the target platform has been set through \"Set Target Platform\", it may also make sense to use the \"Target Platform State\" view to find plugins that are missing dependencies. The target platform resolves if we have all the things we asked for, but it does not check that the plugins we are fetching have all their dependencies sorted out.</p> <p></p> <p>This view allows you to search through the contents of the current target platform, and to check how dependencies have been resolved between the plugins. There is a drop down menu with an option for only showing unresolved plugins: a good target platform should never have any listed in there, unless they happen to be platform-specific. For instance, it makes sense if a Mac-specific plugin (e.g. a Mac binary for launching Eclipse) does not resolve in a developer's Linux machine.</p> <p>Once the target platform has been revised and we have double-checked that everything compiles fine and that there are no unresolved plugins in the \"Target Platform State\" view, we should do one last check before pushing the changes to Git: making sure the Tycho build still works. To do so, we should go to the main folder of the Epsilon Git repository and run this command, assuming we have a recent version of Maven 3 installed and available from our <code>PATH</code>:</p> <pre><code>mvn clean install\n</code></pre> <p>If this command succeeds, it is ready to be pushed. Push the changes, wait until the build succeeds in the Epsilon Jenkins instance (Jenkins checks every 5 minutes or so for changes), and then you're done!</p>"},{"location":"doc/articles/troubleshooting/","title":"Troubleshooting","text":"<p>Below are some common issues that (particularly new) users of Epsilon tend to run into.</p>"},{"location":"doc/articles/troubleshooting/#line-1-reason-missing-eof-at","title":"Line: 1, Reason: missing EOF at \u2018&lt;'","text":"<p>If you get this error message while you are trying to run your Epsilon program, chances are that in the <code>Source</code> tab of your run configuration, you have selected a model instead of the Epsilon program you are trying to run.</p>"},{"location":"doc/articles/troubleshooting/#where-is-the-run-button","title":"Where is the \"Run\" button?","text":"<p>If you cannot find the run button in the toolbar of your Eclipse, you need to activate the Epsilon perspective from the <code>Window</code> \u2192 <code>Perspective</code> \u2192 <code>Open Perspective</code> \u2192 <code>Other</code> menu or from the respective shortcut at the top-right corner of your Eclipse window.</p>"},{"location":"doc/articles/troubleshooting/#i-see-no-files-when-i-browse-for-a-programmodel-file","title":"I see no files when I browse for a program/model file","text":"<p>In the dialog that pops up after you have clicked the <code>Browse</code> button, please start typing the name of the file you are looking for (or <code>*</code> to see all files) in the search box on the top, and files should start appearing under the <code>Matched items</code> part of the dialog.</p>"},{"location":"doc/articles/troubleshooting/#syntax-highlighting-doesnt-work-in-the-epsilonemfatic-editors","title":"Syntax highlighting doesn't work in the Epsilon/Emfatic editors","text":"<p>Chances are that you don't have Epsilon installed in your Eclipse instance. To download Epsilon please follow these instructions. </p>"},{"location":"doc/articles/visualising-models-with-picto-and-sirius/","title":"Visualising Models with Picto and Sirius","text":"<p>Graphical modelling frameworks such as Sirius allow for models to be visualised and edited as diagrams, tables and trees. Sometimes it may be beneficial to visualise parts of the model in a different format, such as graphs. By combining both Sirius and Picto, you can combine the benefits of graphical editing, with the flexibility of rendering views using HTML/SVG/JavaScript-based technologies. </p> <p></p>"},{"location":"doc/articles/visualising-models-with-picto-and-sirius/#example","title":"Example","text":"<p>In this example, we will use the Sirius basicfamily example and render charts using ChartJS.</p> <ol> <li> <p>Import the following projects using File\u2192New\u2192Other\u2192Examples\u2192Sirius Examples:</p> <ul> <li>Basic Family Metamodel Definition (If you cannot see the Sirius Examples, you will need to install the samples feature from here)</li> </ul> </li> <li> <p>Import the <code>org.eclipse.epsilon.examples.picto.sirius</code> plug-in project from the Epsilon repository.</p> </li> <li> <p>Launch a new runtime instance of Eclipse.</p> </li> <li> <p>In the new runtime instance, import the following projects using File\u2192New\u2192Other\u2192Examples\u2192Sirius Examples:</p> <ul> <li>Advanced Tutorial Solution </li> <li>Basic Family Sample Model projects</li> </ul> </li> <li> <p>Open the Picto view (Window\u2192Show View\u2192Other\u2192Picto)</p> </li> <li> <p>In the <code>basicfamily.sample</code> project, create a new Persons diagram on the Family element. </p> </li> </ol> <p>E.g. open the representations.aird file and do the following:</p> <p></p> <p></p> <p>and click Finish.</p> <p>When opened you should see charts showing the number of males and females in the family </p> <p></p> <ol> <li>Now create a new Relationships diagram on Elias</li> </ol> <p></p> <p>You should now see charts showing the number of male and female children of Elias </p> <p></p>"},{"location":"doc/articles/visualising-models-with-picto-and-sirius/#modifying-the-example","title":"Modifying the Example","text":"<p>The <code>org.eclipse.epsilon.examples.picto.sirius</code> plug-in uses the <code>pictoSource</code> extension point and the <code>BasicFamilyPictoSource</code> class to allow Picto to obtain model elements and auto-refresh on save of the Sirius editor. This uses part of the Sirius API to get the root element of the diagram.</p> <pre><code>protected EObject getRootOfDiagram(IEditorPart editorPart) {\nif (isSiriusEditor(editorPart)) {\nDDiagramEditor editor = (DDiagramEditor) editorPart;\nDSemanticDiagramImpl diagram = (DSemanticDiagramImpl) editor.getRepresentation();\nreturn diagram.getTarget();\n}\nreturn null;\n}\n\nprotected boolean isSiriusEditor(IEditorPart editorPart) {\nreturn editorPart instanceof DDiagramEditor;\n}\n</code></pre> <p>The <code>basicfamily.egx</code> file (located in the resources directory of the <code>org.eclipse.epsilon.examples.picto.sirius</code> plug-in) coordinates the generation of the Picto views.</p> <p>The <code>model2bar.egl</code> and <code>model2pie.egl</code> files generate the respective bar and pie chart views using the ChartJS framework.</p>"},{"location":"doc/articles/vscode/","title":"Epsilon in VS Code","text":"<p>You can now edit and run Epsilon programs, and edit Flexmi models and Emfatic metamodels in VS Code as shown below.</p> <p></p> <p>To do this you will need to install the following VS Code extensions:</p> <ul> <li>Eclipse Epsilon Languages: Syntax highlighting, terminal hyperlinking, debugging</li> <li>Gradle for Java: Support for running Gradle build files</li> </ul>"},{"location":"doc/articles/vscode/#give-it-a-spin","title":"Give it a spin!","text":"<ul> <li>Go to any example on the Epsilon Playground</li> <li>Download a zipped copy of the example (for Gradle) using the Download button</li> <li>Extract the downloaded zip file</li> <li>Open the folder using VS Code</li> <li>Go to the Gradle tab on the left hand side</li> <li>Run the <code>run</code> task under <code>Tasks</code>-&gt;<code>other</code> as shown below</li> </ul>"},{"location":"doc/articles/xsd-xml/","title":"Scripting XML documents that conform to an XSD schema using Epsilon","text":"<p>In this article we demonstrate how you can create, query and modify XML documents backed by an XSD schema in Epsilon.</p>"},{"location":"doc/articles/xsd-xml/#querying-an-xml-document","title":"Querying an XML document","text":"<p>We use the following <code>library.xml</code> as a base for demonstrating the EOL syntax for querying XML documents.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;library xsi:noNamespaceSchemaLocation=\"library.xsd\"&gt;\n&lt;book title=\"EMF Eclipse Modeling Framework\" pages=\"744\"&gt;\n&lt;author&gt;Dave Steinberg&lt;/author&gt;\n&lt;author&gt;Frank Budinsky&lt;/author&gt;\n&lt;author&gt;Marcelo Paternostro&lt;/author&gt;\n&lt;author&gt;Ed Merks&lt;/author&gt;\n&lt;published&gt;2009&lt;/published&gt;\n&lt;/book&gt;\n&lt;book title=\"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages=\"736\"&gt;\n&lt;author&gt;Richard Gronback&lt;/author&gt;\n&lt;published&gt;2009&lt;/published&gt;\n&lt;/book&gt;\n&lt;book title=\"Official Eclipse 3.0 FAQs\" pages=\"432\"&gt;\n&lt;author&gt;John Arthorne&lt;/author&gt;\n&lt;author&gt;Chris Laffra&lt;/author&gt;\n&lt;published&gt;2004&lt;/published&gt;\n&lt;/book&gt;\n&lt;/library&gt;\n</code></pre> <p>The XSD schema <code>library.xsd</code> that backs the <code>library.xml</code> file is the following.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" elementFormDefault=\"qualified\" attributeFormDefault=\"unqualified\"&gt;\n&lt;!-- XML Schema Generated from XML Document with XmlGrid.net Free Online Service http://xmlgrid.net --&gt;\n&lt;xs:element name=\"library\"&gt;\n&lt;xs:complexType&gt;\n&lt;xs:sequence&gt;\n&lt;xs:element name=\"book\" maxOccurs=\"unbounded\"&gt;\n&lt;xs:complexType&gt;\n&lt;xs:sequence&gt;\n&lt;xs:element name=\"author\" maxOccurs=\"unbounded\" type=\"xs:string\"&gt;&lt;/xs:element&gt;\n&lt;xs:element name=\"published\" type=\"xs:int\"&gt;&lt;/xs:element&gt;\n&lt;/xs:sequence&gt;\n&lt;xs:attribute name=\"title\" type=\"xs:string\"&gt;&lt;/xs:attribute&gt;\n&lt;xs:attribute name=\"pages\" type=\"xs:int\"&gt;&lt;/xs:attribute&gt;\n&lt;/xs:complexType&gt;\n&lt;/xs:element&gt;\n&lt;/xs:sequence&gt;\n&lt;/xs:complexType&gt;\n&lt;/xs:element&gt;\n&lt;/xs:schema&gt;\n</code></pre>"},{"location":"doc/articles/xsd-xml/#querying-xml-documents-in-eol","title":"Querying XML documents in EOL","text":"<p>The XML driver uses a predefined naming convention to allow developers to programmatically access complex types in XML documents. </p>"},{"location":"doc/articles/xsd-xml/#how-can-i-query-by-element-type","title":"How can I query by element type?","text":"<p>The word <code>Type</code> should be appended at the end of the name of the tag that is used to represent a type. In addition, the first letter of the tag should be capitalised (no matter if it is in lowercase in the schema/xml file). For instance, <code>BookType.all()</code> can be used to get all elements tagged as <code>&lt;book&gt;</code> in the document. Also, if <code>b</code> is an element with a <code>&lt;book&gt;</code> tag, then <code>b.isTypeOf(BookType)</code> shall return true.</p> <pre><code>// Get the first library element in the document\nvar library = LibraryType.all().first();\n\n// Get all the books contained in this library\nvar allBooks = library.book;\n\n// We can get all the books in the document by querying directly the book type\nvar allBooksAlternative = BookType.all();\n\n// Iterate through the collection of books, navigate the pages attribute and \n// return the title of the book if it has more than 700 pages\nfor (aBook in allBooks) {\n    if (aBook.pages &gt; 700) {\n        aBook.isTypeOf(BookType).println();\n        (\"The \" + aBook.title + \" is a large book!\").println();\n    }\n}</code></pre>"},{"location":"doc/articles/xsd-xml/#how-can-i-getset-the-attributes-of-an-element","title":"How can I get/set the attributes of an element?","text":"<p>You can use the attribute name as a property of the element object. For example, if <code>b</code> is the first book of <code>library.xml</code>, <code>b.title</code> will return <code>EMF Eclipse Modeling Framework</code>. Attribute properties are read/write.</p> <p>In this example, <code>b.pages</code> will return <code>744</code> as an integer. Thus, the following program will return the total number of pages of all the books in the library. </p> <pre><code>// Get all the books contained in this library\nvar allBooks = BookType.all();\n\n// Print the total number of pages of all books\nvar total = 0;\nfor (aBook in allBooks) {\n    total = total + aBook.pages;\n}\n(\"Total pages: \" + total).println();\n\n// ... the same using collect() and sum() \n// instead of a for loop\nBookType.all().collect(b|b.pages).sum().println();</code></pre>"},{"location":"doc/articles/xsd-xml/#how-can-i-set-the-text-of-an-element","title":"How can I set the text of an element?","text":"<p>You can use the property name and the assignment symbol <code>=</code> for this.</p> <pre><code>// Get the first book contained in the library\nvar emfBook = BookType.all().first();\n\n// Set the title to a new one\nemfBook.title = \"EMF Book\";\n\n// Print the changed title (NB.: You need to have selected the \"Store on disposal\" \n// option in the run configuration to save changes to the XML file.)\nvar changedEmfBook =  BookType.all().first();\nchangedEmfBook.title.println();</code></pre>"},{"location":"doc/articles/xsd-xml/#how-do-i-create-an-element-and-add-it-to-an-existing-element","title":"How do I create an element and add it to an existing element?","text":"<p>You can use the <code>new</code> operator for this. </p> <pre><code>// Get all the books contained in this library\nvar library = LibraryType.all().first();\nvar allBooks = library.book;\n\n// Print the current number of books\nallBooks.size().println();\n\n// Create a new book\nvar newBook: new BookType;\nnewBook.title = \"MDE in Practice\";\n\n// Add the book to the library\nlibrary.book.add(newBook);\n\n// Get all books and print the new size\nBookType.all().size().println();</code></pre>"},{"location":"doc/articles/xsd-xml/#adding-an-xml-document-to-your-launch-configuration","title":"Adding an XML document to your launch configuration","text":"<p>To add an XML document to your Epsilon launch configuration, you need to select \"XML document backed by XSD (EMF)\" from the list of available model types.</p> <p></p> <p>Then you can configure the details of your document (name, file etc.) in the screen that pops up. If you are making changes to the XML document, remember to tick the \"Store on disposal\" check box to save the changes in your document. </p> <p></p>"},{"location":"doc/articles/yaml-emc/","title":"Scripting YAML documents using Epsilon","text":"<p>In this article we demonstrate how you can create, query and modify YAML documents in Epsilon programs using the YAML driver. All the examples in this article demonstrate using EOL to script YAML documents. However, it's worth stressing that YAML documents are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models \u2013 XML, CSV or EMF-based, or to text), compare and merge your YAML documents.</p>"},{"location":"doc/articles/yaml-emc/#querying-a-yaml-document","title":"Querying a YAML document","text":"<p>We use the following <code>employees.yaml</code> as a base for demonstrating the EOL syntax for querying YAML documents.</p> <pre><code>- employeeId: 14623\naddress:\ncountry: England\nresident: true\npostcode: M1 1AG\nfullname: Michael Davidson\nrole: Consultant\nindustry: [IoT, smart factories, signal analytics]\nprojects:\n- {name: SmartAutomation, budget: 25000}\n- {name: FactoryAnalytics, budget: 20000}\n\n- employeeId: 16431\naddress: {country: Germany}\nfullname: Arnold Wagner\nrole: HR\nskills:\n- communication\n- coaching\n</code></pre>"},{"location":"doc/articles/yaml-emc/#queryingmodifying-yaml-documents-in-eol","title":"Querying/modifying YAML documents in EOL","text":"<p>The YAML driver uses predefined naming conventions to allow developers to programmatically access and modify YAML documents in a concise way. A type of YAML node must be specified when accessing YAML nodes via the YAML driver. There are 3 types of nodes in YAML:</p> <ul> <li><code>Scalar Node</code>. Scalar nodes are used to represent a single scalar value (e.g., string, boolean, integer). In the YAML driver, a scalar node consists of a key-value pair, in which the key represents the name of the scalar node, and the value represents the scalar value.</li> <li><code>Mapping Node</code>. Mapping nodes are used to represent unordered collections of key-value pairs. In the YAML driver, a mapping node consists of a key-value pair, in which the key represents the name of the mapping node, and the value holds an unordered collection of key-value pairs, which in turn represent other nodes.</li> <li><code>List (Sequence) Node</code>. List nodes are used to represent an ordered list of nodes or scalar values. In the YAML driver, a list node consists of a key-value pair, in which the key represents the name of the list node, and the value represents a list of nodes or scalar values.</li> </ul> <p>This section outlines the supported conventions in the form of questions and answers followed by relevant examples.</p>"},{"location":"doc/articles/yaml-emc/#how-can-i-access-all-node-elements","title":"How can I access all node elements?","text":"<p>Retrieving all nodes, regardless of their type, is performed by using the keyword <code>Node</code>, followed by the property <code>all</code>. One can access all nodes of a specific type, by using the keyword <code>ScalarNode</code> for scalar nodes, <code>MappingNode</code> for mapping nodes, and <code>ListNode</code> for list nodes.</p> <pre><code>// Get and print all nodes\nNode.all.println();\n\n// Get and print all scalar nodes\nScalarNode.all.println();\n\n// Get and print all mapping nodes\nMappingNode.all.println();\n\n// Get and print all list nodes\nListNode.all.println();</code></pre>"},{"location":"doc/articles/yaml-emc/#how-can-i-access-nodes-by-name","title":"How can I access nodes by name?","text":"<p>The <code>s_</code> prefix followed by the name of the node is used to access all scalar nodes with the specified name. Similarly, the <code>m_</code> prefix is used for accessing mapping nodes, and the <code>l_</code> prefix for list nodes. For instance, <code>s_role.all</code> can be used to get all scalar nodes named <code>role</code>, <code>m_address.all</code> can be used to get all mapping nodes named <code>address</code>, and <code>l_industry.all</code> can be used to get all list nodes named <code>industry</code>.</p> <pre><code>// Get all scalar nodes with the name \"role\" and print the first one\ns_role.all.first().println();\n\n// Get all mapping nodes with the name \"address\" and print the first one\nm_address.all.first().println();\n\n// Get all list nodes with the name \"industry\" and print the first one\nl_industry.all.first().println();</code></pre>"},{"location":"doc/articles/yaml-emc/#how-can-i-retrieve-nodes-as-a-sequence-of-elements-or-as-a-single-element","title":"How can I retrieve nodes as a sequence of elements or as a single element?","text":"<p>One can specify how nodes can be retrieved, either as a sequence or as a single element. After the prefix of the node type (i.e., <code>s</code> for scalar node, <code>m</code> for mapping node, <code>l</code> for list node), one can use an additional prefix <code>c_</code> to specify that nodes should be retrieved as a sequence, or can use <code>e_</code> to specify that a single node should be retrieved. For instance, <code>se_country</code> specifies that a single scalar node named <code>country</code> should be retrieved, whereas <code>sc_country</code> specifies that the node named <code>country</code> should be retrieved in a sequence. Using the additional prefix <code>e_</code> can eliminate the need for using further accessor functions (e.g., <code>first</code>, <code>last</code>, <code>at</code>).</p> <pre><code>// Get the first \"address\" mapping node\nvar address = m_address.all.first();\n\n// Get and print the \"country\" scalar node in a sequence (c_)\naddress.sc_country.println();\n\n// Get and print the \"country\" scalar node as a single element (e_)\naddress.se_country.println();</code></pre>"},{"location":"doc/articles/yaml-emc/#how-can-i-access-the-name-of-a-node","title":"How can I access the name of a node?","text":"<p>One may be interested in verifying the name of a node for debugging programs, and for this purpose, the <code>name</code> property can be used.</p> <pre><code>// Get the first \"industry\" list node\nvar industry = l_industry.all.first();\n\n// Get and print the name of the node\nindustry.name.println();</code></pre>"},{"location":"doc/articles/yaml-emc/#how-can-i-access-the-type-of-a-node","title":"How can I access the type of a node?","text":"<p>One may be interested in verifying the type of a node for debugging programs, and for this purpose, the <code>type</code> property can be used.</p> <pre><code>// Get the first \"role\" scalar node\nvar role = s_role.all.first();\n\n// Get and print the type of the node\nrole.type.println(); // ScalarNode</code></pre>"},{"location":"doc/articles/yaml-emc/#how-can-i-access-the-value-of-a-node","title":"How can I access the value of a node?","text":"<p>The <code>value</code> property can be used for accessing the value of a node. The value of a node can be converted into different types using the following prefixes:</p> <ul> <li><code>s_</code> for strings</li> <li><code>i_</code> for integers</li> <li><code>d_</code> for doubles</li> <li><code>f_</code> for floats</li> <li><code>b_</code> for booleans</li> </ul> <pre><code>var employeeVal = s_employeeId.all.first().value; // 14623\nvar s_employeeVal = s_employeeId.all.first().s_value + 1; // 146231\nvar i_employeeVal = s_employeeId.all.first().i_value + 1; // 14624\nvar d_employeeVal = s_employeeId.all.first().d_value + 1; // 14624.0\nvar f_employeeVal = s_employeeId.all.first().f_value + 1; // 14624.0\nvar b_residentVal = s_resident.all.first().b_value; // true</code></pre>"},{"location":"doc/articles/yaml-emc/#how-can-i-create-a-node","title":"How can I create a node?","text":"<p>To create a new node, you can use the <code>new</code> operator followed by the type of node (i.e., <code>ScalarNode</code>, <code>MappingNode</code>, <code>ListNode</code>). Alternatively, the convention for accessing nodes can be used for creating nodes. For instance, one can use the <code>new</code> operator followed by <code>s_role</code> to create a scalar node named <code>role</code>.</p> <pre><code>// scalar node named \"city\" with the value \"Berlin\"\nvar cityNode1 = new ScalarNode(\"city\", \"Berlin\"); // city=Berlin\nvar cityNode2 = new s_city(\"Berlin\"); // city=Berlin\n\n// empty mapping node named \"address\"; its value must be set later\nvar addressNode1 = new MappingNode(\"address\"); // address={}\nvar addressNode2 = new m_address; // address={}\n\n// empty list node named \"books\" that contains 5 entries; its values must be set later\nvar booksNode1 = new ListNode(\"books\", 5); // books=[{}, {}, {}, {}, {}]\nvar booksNode2 = new l_books(5); // books=[{}, {}, {}, {}, {}]</code></pre>"},{"location":"doc/articles/yaml-emc/#how-do-i-set-the-value-of-a-node","title":"How do I set the value of a node?","text":"<p>For setting or changing the value of a node, the <code>value</code> property can be used, followed by the assignment operator (\u201c=\u201d) and a value or a node. If a node is specified after the assignment operator, then the name of that node will be ignored, and the value of that node will become the new value after the assignment operation. The function <code>set(position, value)</code> can be used for modifying the items of a list node.</p> <pre><code>// changes the value of the first \"fullname\" scalar node to \"Jack\"\ns_fullname.all.at(0).value = \"Jack\";\n\n// changes the value of the first \"role\" scalar node to \"Developer\"\ns_role.all.first().value = new ScalarNode(\"newNode\", \"Developer\");\n\n// changes the value of the \"country\" scalar node to \"Turkey\"\nm_address.all.first().se_country.value = \"Turkey\";\n\n// changes the last \"address\" mapping node into a scalar node with the value \"Street Broadway\"\nm_address.all.last().value = new s_newNode(\"Street Broadway\");\n\n// changes the last \"role\" scalar node into an empty mapping node\ns_role.all.last().value = new MappingNode();\n\n// changes the last \"employeeId\" scalar node into a list node that contains 3 empty entries\ns_employeeId.all.last().value = new ListNode(\"newNode\", 3); \n\n// changes in the \"skills\" list node the value of the item at position 1 to \"databases\"\nl_skills.all.first().value.set(1, \"databases\");</code></pre>"},{"location":"doc/articles/yaml-emc/#how-do-i-add-entries-to-a-list-node","title":"How do I add entries to a list node?","text":"<p>The function <code>add(value)</code> can be used for adding an item to a list node that contains scalar values. The functions <code>addRow()</code> and <code>addRows(size)</code> can be used for adding empty entries to a list node that contains nodes.</p> <pre><code>// add an item to the \"skills\" list node\nl_skills.all.first().value.add(\"analytics\");\n\n// add 1 empty entry to the \"projects\" list node\nl_projects.all.first().value.addRow();\n\n// add 3 empty entries to the \"projects\" list node\nl_projects.all.first().value.addRows(3);</code></pre>"},{"location":"doc/articles/yaml-emc/#how-do-i-add-nodes-to-a-mapping-node","title":"How do I add nodes to a mapping node?","text":"<p>The <code>appendNode(node)</code> function can be used for adding new nodes into a mapping node.</p> <pre><code>var address = m_address.all.last();\n\n// add a new scalar node with the name \"city\" and value \"Berlin\"\naddress.value.appendNode(new ScalarNode(\"city\", \"Berlin\"));</code></pre>"},{"location":"doc/articles/yaml-emc/#how-do-i-set-the-root-node-of-a-yaml-document","title":"How do I set the root node of a YAML document?","text":"<p>The <code>root</code> property can be used for setting the root node of a YAML document. The root node of a YAML document can either be a mapping node or a list node. The <code>setRootAsMap()</code> function can be used for setting the root node into a mapping node. The <code>setRootAsList()</code> function can be used for setting the root node into a list node.</p> <pre><code>// Set the root node into a mapping node\nYAMLDoc.setRootAsMap();\n\n// Set the root node into a list node\nYAMLDoc.setRootAsList();\n\n// Set the root node into a mapping node\nYAMLDoc.root.value = new MappingNode();\n\n// Set the root node into a list node with 3 empty entries\nYAMLDoc.root.value = new ListNode(\"\", 3);</code></pre>"},{"location":"doc/articles/yaml-emc/#how-can-i-create-a-yaml-document-from-scratch","title":"How can I create a YAML document from scratch?","text":"<p>The following code can be used for creating the <code>employees.yaml</code> file programmatically.</p> <pre><code>YAMLDoc.setRootAsList();\nvar root = YAMLDoc.getRoot();\nroot.value.addRows(2);\nvar rootFirstRow = root.value.at(0);\nvar rootSecondRow = root.value.at(1);\n\nvar addressNode1 = new MappingNode(\"address\");\nvar countryNode1 = new ScalarNode(\"country\", \"England\");\nvar residentNode = new ScalarNode(\"resident\", true);\nvar postcodeNode = new ScalarNode(\"postcode\", \"M1 1AG\");\naddressNode1.value.appendNode(countryNode1);\naddressNode1.value.appendNode(residentNode);\naddressNode1.value.appendNode(postcodeNode);\n\nvar employeeIdNode1 = new ScalarNode(\"employeeId\", \"14623\");\nvar fullnameNode1 = new ScalarNode(\"fullname\", \"Michael Davidson\");\nvar roleNode1 = new ScalarNode(\"role\", \"Consultant\");\n\nvar industryNode = new ListNode(\"industry\", 3);\nindustryNode.value =  Sequence{\"IoT\", \"smart factories\", \"signal analytics\"};\n\nvar projectsNode = new ListNode(\"projects\", 2);\nvar nameNode1 = new ScalarNode(\"name\", \"SmartAutomation\");\nvar nameNode2 = new ScalarNode(\"name\", \"FactoryAnalytics\");\nvar budgetNode1 = new ScalarNode(\"budget\", 25000);\nvar budgetNode2 = new ScalarNode(\"budget\", 20000);\nprojectsNode.value.at(0).appendNode(nameNode1);\nprojectsNode.value.at(0).appendNode(budgetNode1);\nprojectsNode.value.at(1).appendNode(nameNode2);\nprojectsNode.value.at(1).appendNode(budgetNode2);\n\nvar addressNode2 = new MappingNode(\"address\");\nvar countryNode2 = new ScalarNode(\"country\", \"Germany\");\naddressNode2.value.appendNode(countryNode2);\n\nvar employeeIdNode2 = new ScalarNode(\"employeeId\", \"16431\");\nvar fullnameNode2 = new ScalarNode(\"fullname\", \"Arnold Wagner\");\nvar roleNode2 = new ScalarNode(\"role\", \"HR\");\n\nvar skillsNode = new ListNode(\"skills\", 2);\nskillsNode.value =  Sequence{\"communication\", \"coaching\"};\n\nrootFirstRow.appendNode(employeeIdNode1);\nrootFirstRow.appendNode(addressNode1);\nrootFirstRow.appendNode(fullnameNode1);\nrootFirstRow.appendNode(roleNode1);\nrootFirstRow.appendNode(industryNode);\nrootFirstRow.appendNode(projectsNode);\n\nrootSecondRow.appendNode(employeeIdNode2);\nrootSecondRow.appendNode(addressNode2);\nrootSecondRow.appendNode(fullnameNode2);\nrootSecondRow.appendNode(roleNode2);\nrootSecondRow.appendNode(skillsNode);</code></pre>"},{"location":"doc/articles/yaml-emc/#how-can-i-delete-nodes","title":"How can I delete nodes?","text":"<p>To delete nodes, you can use the <code>delete</code> operator followed by the node(s) to be deleted.</p> <pre><code>// delete all scalar nodes named \"role\"\ndelete s_role.all;\n\n// delete the first mapping node named \"address\"\ndelete m_address.all.first();\n\n// delete all list nodes named \"skills\"\ndelete l_skills.all;</code></pre>"},{"location":"doc/articles/yaml-emc/#adding-a-yaml-document-to-your-launch-configuration","title":"Adding a YAML document to your launch configuration","text":"<p>To add a YAML document to your Epsilon launch configuration, you need to select \"YAML Document\" from the list of available model types.</p> <p></p> <p>Then you can configure the details of your document (name, file etc.) in the screen that pops up. To load a YAML document that is not in the Eclipse workspace, untick the \"Workspace file\" check box and provide a full URI for your document (e.g. <code>http://api.twitter.com/followers/epsilonews.yaml</code> or <code>file:/c:/employees.yaml</code>).</p> <p></p>"},{"location":"doc/articles/yaml-emc/#loading-a-yaml-document-through-java-code","title":"Loading a YAML document through Java code","text":"<p>The following excerpt demonstrates using YAML models using Epsilon's Java API.</p> <pre><code>EolModule module = new EolModule();\nmodule.parse(new File(\"...\"));\n\nYamlModel model = new YamlModel();\nmodel.setName(\"YAMLDoc\");\nmodel.setFile(new File(\"...\"));\nmodel.load();\n\nmodule.getContext().getModelRepository().addModel(model);\nmodule.getContext().setModule(module);\nmodule.execute();\n</code></pre>"},{"location":"doc/articles/yaml-emc/#additional-resources","title":"Additional resources","text":"<ul> <li>MDENet Community: Additional learning resources about MDE with the Epsilon Framework.</li> </ul>"},{"location":"doc/book/","title":"Epsilon Book","text":"<p>Following a major redesign of the website in June 2020, we decided to retire the Epsilon Book and to weave its contents into the website for better long-term maintenance. The final version of the PDF book is available here. The content of the book has been merged into the website as follows:</p> <ul> <li>Chapter 2: The Epsilon Model Connectivity Layer (EMC)</li> <li>Chapter 3: The Epsilon Object Language (EOL)</li> <li>Chapter 4: The Epsilon Validation Language (EVL)</li> <li>Chapter 5: The Epsilon Transformation Language (ETL)</li> <li>Chapter 6: The Epsilon Wizard Language (EWL)</li> <li>Chapter 7: The Epsilon Generation Language (EGL)</li> <li>Chapter 8: The Epsilon Comparison Language (ECL)</li> <li>Chapter 9: The Epsilon Merging Language (EML)</li> <li>Chapter 10: Epsilon Flock for Model Migration</li> <li>Chapter 11: The Epsilon Pattern Language (EPL)</li> <li>Chapter 12: The Epsilon Model Generation Language (EMG)</li> <li>Chapter 14: Orchestration Workflow</li> <li>Chapter 15: The Epsilon Unit Testing Framework (EUnit)</li> </ul>"},{"location":"doc/eugenia/","title":"Graphical Model Editor development with Eugenia/GMF","text":"<p>Eugenia discontinued in Epsilon 2.5</p> <p>Following the archival of the GMF Tooling project, Eugenia has been discontinued from version 2.5 onwards. While you can still use Eugenia with older versions of Epsilon, you may want to consider more actively-maintained tools such as Eclipse Sirius if you need to develop a graphical editor, or Picto if you are only interested in producing read-only views from models.</p> <p>Eugenia is a tool that simplifies the development of GMF-based graphical model editors by automatically generating the <code>.gmfgraph</code>, <code>.gmftool</code> and <code>.gmfmap</code> models needed by GMF editor from a single annotated Ecore metamodel. For example, from the following annotated EMF metamodel (expressed using Emfatic; an Ecore version is available here) it can generate a fully functional GMF editor, a screenshot of which is displayed below.</p>"},{"location":"doc/eugenia/#the-filesystem-metamodel","title":"The Filesystem metamodel","text":"<pre><code>@namespace(uri=\"filesystem\", prefix=\"filesystem\")\n@gmf\npackage filesystem;\n\n@gmf.diagram\nclass Filesystem {\n    val Drive[*] drives;\n    val Sync[*] syncs;\n}\n\nclass Drive extends Folder {\n\n}\n\nclass Folder extends File {\n    @gmf.compartment\n    val File[*] contents;\n}\n\nclass Shortcut extends File {\n    @gmf.link(target.decoration=\"arrow\", style=\"dash\")\n    ref File target;\n}\n\n@gmf.link(source=\"source\", target=\"target\", style=\"dot\", width=\"2\")\nclass Sync {\n    ref File source;\n    ref File target;\n}\n\n@gmf.node(label = \"name\")\nclass File {\n    attr String name;\n}</code></pre>"},{"location":"doc/eugenia/#the-generated-editor","title":"The generated editor","text":""},{"location":"doc/eugenia/#supported-annotations","title":"Supported Annotations","text":"<p>Eugenia supports the following annotations on Ecore elements.</p>"},{"location":"doc/eugenia/#gmf","title":"gmf","text":"<p>Applies to the top <code>EPackage</code> only and denotes that GMF-related annotations are expected in its elements. This doesn't affect the forthcoming model transformations, only the Ecore validation process.</p>"},{"location":"doc/eugenia/#gmfdiagram","title":"gmf.diagram","text":"<p>Denotes the root object of the metamodel. Only one (non-abstract) <code>EClass</code> must be annotated as <code>gmf.diagram</code>. Accepts the following details:</p> <ul> <li><code>diagram.extension</code> (optional) : the file extension for the diagram file</li> <li><code>model.extension</code> (optional) : the file extension for the domain model. To make the generated tree-based editor work with the same extension, you need to add an <code>@emf.gen(fileExtensions=\"model-file-extension\")</code> annotation <code>to the root package</code> of your metamodel.</li> <li><code>onefile</code> (optional) : a value of <code>true</code> specifies that the domain model and the diagram should be stored in the same file</li> <li><code>rcp</code> (optional) : a value of <code>true</code> specifies that the editor is intended to be part of a RCP product (printing is disabled)</li> <li><code>units</code> (optional) : the units for the diagram (e.g. <code>Pixels</code>)</li> </ul>"},{"location":"doc/eugenia/#gmfnode","title":"gmf.node","text":"<p>Applies to an <code>EClass</code> and denotes that it should appear on the diagram as a node. Accepts the following details:</p> <ul> <li><code>border.color</code> (optional) : an RGB color that will be set as the node's border color.</li> <li><code>border.style</code> (optional) : the style of the node's border. Can be set to <code>solid</code> (default), <code>dash</code> or <code>dot</code>.</li> <li><code>border.width</code> (optional) : an integer that specifies the width of the node's border.</li> <li><code>color</code> (optional) : an RGB color that will be set as the node's background color (e.g. <code>255,0,0</code>).</li> <li><code>figure</code> (optional) : the figure that will represent the node. Can be set to <code>rectangle</code>, <code>ellipse</code>, <code>rounded</code> (default), <code>svg</code> (see <code>svg.uri</code>), <code>polygon</code> (see <code>polygon.x</code> and <code>polygon.y</code>) or the fully qualified name of a Java class that implements Figure.</li> <li><code>label</code>: the name(s) of the <code>EAttribute</code>(s) of the <code>EClass</code>, the value(s) of which will be displayed as the label of the node. If <code>label.placement</code> is set to <code>none</code>, this detail is not required.</li> <li><code>label.color</code> (optional, since 1.5.0) : an RGB color that will be set as the node's foreground color. Labels will have a fixed font of this color.</li> <li><code>label.icon</code> (optional) : if set to <code>true</code> (default) a small icon appears on the left of the label.</li> <li><code>label.parser</code> (optional) : indicates the unqualified name of the class that will parse the text entered by the user into the label. By default, a MessageFormat-based parser is generated, but it can be manually customized after generation.</li> <li><code>label.edit.pattern</code> (optional) : like <code>label.pattern</code>, but only for editing the label.</li> <li><code>label.pattern</code> (optional) : if more than one attributes are specified in the label, the format detail is necessary to show how their values will be rendered in the label. The format follows the Java Message Format style (e.g. <code>{0} : {1}</code>). The same pattern is used for editing and viewing the label.</li> <li><code>label.view.pattern</code> (optional) : like <code>label.pattern</code>, but only for viewing the label.</li> <li><code>label.placement</code> (optional) : defines the placement of the label in relation to the node. Can be set to <code>internal</code>, <code>external</code> or <code>none</code> (no label will be shown). ''(The default distance of an external label in GMF is 20pt which is a bit too far away for my taste. Read more about fixing this without changing the generated code every time)''.</li> <li><code>label.text</code> (optional) : defines the default text to be used when the <code>EAttribute</code>(s) in <code>label</code> are not set. By default, it is set to the name of the <code>EClass</code>.</li> <li><code>label.readOnly</code> (optional) : a value of <code>true</code> denotes that the label cannot be changed in the generated diagram editor.</li> <li><code>margin</code> (optional) : inset margin (5 units by default) for the node.</li> <li><code>phantom</code> (optional) : defines if the node is phantom (<code>true</code>/<code>false</code>). Phantom nodes are particularly useful in order to visualize containment references using links instead of spatial containment (read more...).</li> <li><code>polygon.x</code> (when <code>figure</code> is set to <code>polygon</code>) : list of space-separated integers with the X coordinates of the polygon used as figure.</li> <li><code>polygon.y</code> (when <code>figure</code> is set to <code>polygon</code>) : list of space-separated integers with the Y coordinates of the polygon used as figure.</li> <li><code>resizable</code> (optional) : a value of <code>false</code> disables all the resize handles for the node</li> <li><code>size</code> (optional) : a GMF dimension that will be used as the node's preferred size (e.g. <code>10,5</code>). Width is specified before height.</li> <li><code>svg.uri</code> (when <code>figure</code> is set to <code>svg</code>) : URI of the <code>.svg</code> file to be used as figure for the node. For instance, <code>platform:/plugin/my.plugin/my.svg</code> will access the <code>my.svg</code> file in the <code>my.plugin</code> plugin. Note: until Kepler, using SVG figures required the GMF Tooling Experimental SDK (available from this update site). Remember to add the <code>.svg</code> file to the binary builds of your plugin.</li> <li><code>tool.description</code> (optional) : the description of the creation tool.</li> <li><code>tool.large.bundle</code> (optional) : the bundle of the large icon of the creation tool.</li> <li><code>tool.large.path</code> (optional) : the path of the large icon of the creation tool.</li> <li><code>tool.name</code> (optional) : the name of the creation tool.</li> <li><code>tool.small.bundle</code> (optional) : the bundle of the small icon of the creation tool.</li> <li><code>tool.small.path</code> (optional) : the path of the small icon of the creation tool.</li> </ul>"},{"location":"doc/eugenia/#gmflink","title":"gmf.link","text":"<p>Applies to <code>EClass</code>es that should appear on the diagram as links and to non-containment <code>EReference</code>s.</p>"},{"location":"doc/eugenia/#gmflink-for-eclass","title":"gmf.link (for EClass)","text":"<p>It accepts the following details:</p> <ul> <li><code>color</code> (optional) : the RGB color of the link.</li> <li><code>incoming</code> (optional) : Boolean value which specifies whether the generated editor should allow links to be created from target to source. Defaults to <code>false</code>.</li> <li><code>label</code> (optional) : the names of the <code>EAttribute</code>s of the <code>EClass</code> the value of which will be displayed as the label of the link.</li> <li><code>label.parser</code> (optional) : indicates the unqualified name of the class that will parse the text entered by the user into the label. By default, a MessageFormat-based parser is generated, but it can be manually customized after generation.</li> </ul> <ul> <li><code>source</code> : the source non-containment <code>EReference</code> of the link.</li> <li><code>source.constraint</code> (optional) : OCL assertion that should be checked by the graphical editor when creating a link. For instance, <code>self &lt;&gt; oppositeEnd</code> would forbid users for creating a link from a node to itself (a self-loop): <code>self</code> is the source of the link, and <code>oppositeEnd</code> is the target of the link.</li> <li><code>source.decoration</code> (optional) : the decoration of the source end of the link. Can be set to <code>none</code>, <code>arrow</code>, <code>rhomb</code>, <code>filledrhomb</code>, <code>square</code>, <code>filledsquare</code>, <code>closedarrow</code>, <code>filledclosedarrow</code>, or the fully qualified name of a Java class that implements the <code>org.eclipse.draw2d.RotatableDecoration</code> interface</li> <li><code>style</code> (optional) : the style of the link (see <code>border.style</code> above).</li> <li><code>target</code> : the target non-containment <code>EReference</code> of the link.</li> <li><code>target.constraint</code> (optional) : OCL assertion that should be checked by the graphical editor when creating a link. For instance, <code>self &lt;&gt; oppositeEnd</code> would forbid users for creating a link from a node to itself (a self-loop): <code>self</code> is the target of the link, and <code>oppositeEnd</code> is the source of the link.</li> <li><code>target.decoration</code> (optional) : See <code>source.decoration</code>.</li> <li><code>tool.description</code> (optional) : the description of the creation tool.</li> <li><code>tool.large.bundle</code> (optional) : the bundle of the large icon of the creation tool.</li> <li><code>tool.large.path</code> (optional) : the path of the large icon of the creation tool.</li> <li><code>tool.name</code> (optional) : the name of the creation tool.</li> <li><code>tool.small.bundle</code> (optional) : the bundle of the small icon of the creation tool.</li> <li><code>tool.small.path</code> (optional) : the path of the small icon of the creation tool.</li> <li><code>width</code> (optional) : the width of the link.</li> </ul> <p>For an example see the <code>Sync</code> class in the <code>filesystem</code> metamodel</p>"},{"location":"doc/eugenia/#gmflink-for-non-containment-ereference","title":"gmf.link (for non-containment EReference)","text":"<p>It accepts the following details:</p> <ul> <li><code>color</code> (optional) : the RGB color of the link</li> <li><code>label</code> (optional) : The static text that will be displayed as the label of the link. If no label is specified, the name of the reference is displayed instead.</li> <li><code>label.text</code> (optional) : equivalent to <code>label</code> in this case.</li> <li><code>source.decoration</code> (optional) : The decoration of the source end of the link. Can be set to <code>none</code>, <code>arrow</code>, <code>rhomb</code>, <code>filledrhomb</code>, <code>square</code>, <code>filledsquare</code>, <code>closedarrow</code>, <code>filledclosedarrow</code>, or the fully qualified name of a Java class that implements an appropriate interface</li> <li><code>style</code> (optional) : the style of the link (see <code>border.style</code> above)</li> <li><code>target.decoration</code> (optional) : As above.</li> <li><code>tool.description</code> (optional) : the description of the creation tool</li> <li><code>tool.large.bundle</code> (optional) : The bundle of the large icon of the creation tool</li> <li><code>tool.large.path</code> (optional) : The path of the large icon of the creation tool</li> <li><code>tool.name</code> (optional) : the name of the creation tool</li> <li><code>tool.small.bundle</code> (optional) : The bundle of the small icon of the creation tool</li> <li><code>tool.small.path</code> (optional) : The path of the small icon of the creation tool</li> <li><code>width</code> (optional) : the width of the link</li> </ul>"},{"location":"doc/eugenia/#gmfcompartment-for-containment-ereference","title":"gmf.compartment (for containment EReference)","text":"<p>Defines that the containment reference will create a compartment where model elements that conform to the type of the reference can be placed. It accepts the following details:</p> <ul> <li><code>collapsible</code> (optional) : Set to <code>false</code> to prevent the compartment from collapsing (default is <code>true</code>)</li> <li><code>layout</code> (optional) : The layout of the compartment. Can be set to free (default) or list</li> </ul>"},{"location":"doc/eugenia/#gmfaffixed-for-containment-ereference","title":"gmf.affixed (for containment EReference)","text":"<p>Defines that the containment reference will create nodes which are affixed to the edges of the containing node. See an example.</p>"},{"location":"doc/eugenia/#gmflabel-for-eattribute","title":"gmf.label (for EAttribute)","text":"<p>Defines additional labels for the containing <code>EClass</code>. These labels will be displayed underneath the default label for the containing <code>EClass</code>. It accepts the following details:</p> <ul> <li><code>label.edit.pattern</code> (optional) : like <code>label.pattern</code>, but only for editing the label.</li> <li><code>label.parser</code> (optional) : indicates the unqualified name of the class that will parse the text entered by the user into the label. By default, a MessageFormat-based parser is generated, but it can be manually customized after generation.</li> <li><code>label.pattern</code> (optional) : if more than one attributes are specified in the label, the format detail is necessary to show how their values will be rendered in the label. The format follows the Java Message Format style (e.g. <code>{0} : {1}</code>). The same pattern is used for editing and viewing the label.</li> <li><code>label.readOnly</code> (optional) : A value of <code>true</code> denotes that the label cannot be changed in the generated diagram editor.</li> <li><code>label.text</code> (optional) : defines the default text to be used when the attribute is not set.</li> <li><code>label.view.pattern</code> (optional) : like <code>label.pattern</code>, but only for viewing the label.</li> </ul>"},{"location":"doc/eugenia/#installing-eugenia","title":"Installing Eugenia","text":"<p>Eugenia is a part of the main Epsilon distribution, available from its update site. Detailed installation instructions are available.</p> <p>Although not necessary, the Emfatic toolkit mentioned above is heavily recommended: install it from its update site.</p>"},{"location":"doc/eugenia/#running-eugenia","title":"Running Eugenia","text":"<p>To run Eugenia you need to do the following:</p> <ul> <li>Create a new general project</li> <li>Create and annotate your Emfatic (or Ecore) metamodel in the root of your project</li> <li>Right-click your Emfatic (or Ecore) metamodel and select <code>Eugenia</code> \u2192 <code>Generate GMF editor</code></li> <li>Launch a new Eclipse instance from the <code>Run</code> \u2192 <code>Eclipse Application</code> right-click menu of the project that contains your metamodel</li> <li>In the new Eclipse instance create a new <code>General</code> \u2192 <code>Project</code> and in it create a new <code>Filesystem diagram</code> through the <code>File</code> \u2192 <code>New</code> \u2192 <code>Other...</code> dialog</li> </ul>"},{"location":"doc/eugenia/#re-running-eugenia","title":"Re-running Eugenia","text":"<p>If you now change your metamodel you'll have to rerun Eugenia to generate your updated editor:</p> <ul> <li>Right-click your Ecore metamodel (or Emfatic file) and select <code>Eugenia</code> \u2192 <code>Generate GMF editor</code></li> <li>Run a new instance of Eclipse</li> </ul> <p>(Please note that any changes you have made manually to the editor's <code>.gmfgraph</code>, <code>.gmftool</code> and <code>.gmfmap</code> models will be overwritten. Have a look here for an alternative way to customize these models)</p>"},{"location":"doc/eugenia/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Certain versions of Emfatic do not support annotations without details (e.g. <code>@gmf</code> or <code>@gmf.diagram</code>). You can use dummy details as a workaround (e.g. <code>@gmf(foo=\"bar\")</code>)</li> <li>Should you run across the \"Node is referenced from multiple containers with different 'List Layout' values\" message during validation please ignore it and proceed with the editor code generation.</li> <li>Eugenia does not work with Ecore metamodels that span across multiple files/sub-packages</li> <li>Ensure that the name of your package is different to the names of the classes it contains (i.e. a package Foo should not contain a Foo class)</li> </ul>"},{"location":"doc/eugenia/#recipes","title":"Recipes","text":"<ul> <li>Nodes with user defined images (e.g. jpg, png, gif)</li> <li>Nodes with user defined images at runtime</li> </ul>"},{"location":"doc/eugenia/#customizing-your-editor","title":"Customizing your editor","text":"<p>Click here to find out how you can further customize the generated <code>.gmfgraph</code>, <code>.gmfmap</code> and <code>.gmftool</code> models in ways that are not supported by the annotations provided by Eugenia, and still preserve the customizations when Eugenia is re-invoked.</p>"},{"location":"doc/eugenia/#adding-copyright","title":"Adding Copyright","text":"<p>To add copyright information to your generated .gmfgen model, simply create a file named copyright.txt next to it. Next time you invoke <code>Eugenia</code> \u2192 <code>Synchronize GMF gen model</code>, Eugenia will pick it up and place its contents in the root GenDiagramEditor of your .gmfgen model. If you have added the copyright.txt file, you can also inject its contents to your .genmodel model (EMF generator model) by right-clicking it and invoking <code>Eugenia</code> \u2192 <code>Synchronize EMF gen model</code>.</p>"},{"location":"doc/eugenia/#next-steps","title":"Next Steps","text":"<p>Now that you've learned how to generate a GMF-based editor using Eugenia, you may also want to add some constraints to your editor, which you can then evaluate (explicitly or on-save) to check the correctness/consistency of your models:</p> <p></p>"},{"location":"doc/exeed/","title":"Exeed (Extended EMF Editor)","text":"<p>Exeed is an extended version of the built-in tree-based reflective editor provided by EMF. The aim of Exeed is to enable developers to customize the appearance of the editor (labels and icons) by annotating Ecore metamodels. As a result, developers can enjoy the benefits of a customized editor for their models without needing to generate one and then customize it using Java.</p> Plain Reflective Editor Exeed"},{"location":"doc/exeed/#exeed-annotations-keys","title":"Exeed Annotations Keys","text":"<p>The source for exeed annotations is <code>exeed</code>. Exeed annotations are only supported in <code>EClass</code>, <code>EEnumLiteral</code> and <code>EStructuralFeature</code> elements of the metamodel. For each element the following keys are supported:</p>"},{"location":"doc/exeed/#eclass","title":"EClass","text":"<ul> <li><code>label</code>: Defines the label that will be used to for the element when it is displayed on all views related to the editor (editing tree, properties view, etc.)</li> <li><code>referenceLabel</code>: Defines the label for a reference to an instance of this <code>EClass</code> ((e.g. in the properties view).</li> <li><code>icon</code>: Defines the icon to use to display alongside the element on all views related to the editor (editing tree, properties view, etc.). If specified, it overrides the <code>classIcon</code> annotation.</li> <li><code>classIcon</code>: Defines the icon of the instances of the <code>EClass</code>.</li> </ul>"},{"location":"doc/exeed/#eenumliteral","title":"EEnumLiteral","text":"<ul> <li><code>label</code>: Defines the label that will be used for the enumeration literal when it is displayed on all views related to the editor (editing tree, properties view, etc.)</li> </ul>"},{"location":"doc/exeed/#estructuralfeature","title":"EStructuralFeature","text":"<ul> <li><code>featureLabel</code>: Defines the label that will be used for the structural feature when it is displayed on all views related to the editor (editing tree, properties view, etc.)</li> </ul>"},{"location":"doc/exeed/#exeed-annotations-values","title":"Exeed Annotations Values","text":"<p>All keys, except for <code>classIcon</code>, accept an EOL script as their value. This allows labels and icons to be dynamically allocated based on the properties of the instance. The EOL script is evaluated in the context of each instance, that is, the current instance can be accessed via the <code>self</code> keyword. Further, all other model elements are accessible via navigation (i.e. references from the instance) or by getting all elements of a type (e.g. MyType.all). </p> <p>For the <code>icon</code> and <code>classIcon</code> keys the expected value is the name of one of the icons available in Exeed. Thus, for <code>icon</code> the EOL script must return a string with the name of the icon and for <code>classIcon</code> the value must be the name of the icon. The following icons are available (the extension should not be included):</p> <p></p>"},{"location":"doc/exeed/#example","title":"Example","text":"<p>The images show the tree view of a OO Model with the EMF Reflective Editor (left) and the Exeed Editor (right).</p> <p></p> <p>The following code presents the annotated OO metamodel (in Emfatic) that was used to obtain the Exeed result above (the example is available from the examples folder of the Git repository):</p> <pre><code>@namespace(uri=\"OO\", prefix=\"\")\npackage OO;\n\n@exeed(classIcon=\"model\")\nclass Model extends Package {\n}\n\n@exeed(referenceLabel=\"\nvar str : String;\nstr = self.closure(pe:PackageableElement|pe.package).collect(p|p.name).invert().concat('.');\nif (self.package.isDefined()){\n    str = str + '.';\n}\nstr = str + self.name;\nreturn str;\n\")\nabstract class PackageableElement extends NamedElement {\n   ref Package#contents ~package;\n}\n\nabstract class AnnotatedElement {\n  val Annotation[*] annotations;\n}\n\n@exeed(label=\"return self.key + ' -&gt; ' + self.value;\", classIcon=\"annotation\")\nclass Annotation {\n  attr String key;\n  attr String value;\n}\n\n@exeed(label=\"return self.name;\")\nabstract class NamedElement extends AnnotatedElement {\n  attr String name;\n}\n\n@exeed(classIcon=\"package\", label=\"return self.name;\")\nclass Package extends PackageableElement {\n  val PackageableElement[*]#~package contents;\n  ref Package[*] uses;\n}\n\nabstract class Classifier extends PackageableElement { }\n\nclass ExternalClass extends Class { }\n\n@exeed(classIcon=\"class\", label=\"\nvar label : String;\nlabel = self.name;\nif (self.extends.isDefined()){\n    label = label + ' extends ' + self.extends.name;\n}\nreturn label;\n\")\nclass Class extends Classifier {\n  ref Class#extendedBy ~extends;\n  ref Class[*]#~extends extendedBy;\n  val Feature[*]#owner features;\n  attr Boolean isAbstract;\n}\n\n@exeed(classIcon=\"datatype\")\nclass Datatype extends Classifier {\n}\n\nabstract class Feature extends NamedElement {\n  ref Class#features owner;\n  ref Classifier type;\n  attr VisibilityEnum visibility;\n}\n\n@exeed(label=\"\nvar label : String;\nlabel = self.name;\nif (self.type.isDefined()){\n    if (self.isMany) {\n        label = label + ' [*]';\n    }\n    label = label + '  : ' + self.type.name;\n}\nreturn label;\", \nicon=\"\nif (self.visibility = VisibilityEnum#private) {\n    return 'private';\n}\nelse {\n    return 'public';\n}\n\")\nabstract class StructuralFeature extends Feature {\n    attr Boolean isMany;\n}\n\n@exeed(label=\"\nvar label : String;\nlabel = self.name + ' (';\nfor (p in self.parameters) {\n    label = label + p.name;\n    if (p.type.isDefined()) {\n        label = label + ' : ' + p.type.name;\n    }\n    if (hasMore) {\n        label = label + ', ';\n    }\n}\nlabel = label + ')';\nif (self.type.isDefined()) {\n    label = label + ' : ' + self.type.name;\n}\nreturn label;\n\", classIcon=\"operation\")\nclass Operation extends Feature {\n   val Parameter[*]#owner parameters;\n}\n\n@exeed(label=\"\nvar label : String;\nlabel = self.name;\nif (self.type.isDefined()){\n    label = label + ' : ' + self.type.name;\n}\nreturn label;\n\", classIcon=\"parameter\")\nclass Parameter extends NamedElement {\n  ref Classifier type;\n  ref Operation#parameters owner;\n}\n\nclass Reference extends StructuralFeature { }\n\nclass Attribute extends StructuralFeature { }\n\nenum VisibilityEnum {\n  public = 1;\n  private = 2;\n}\n</code></pre>"},{"location":"doc/exeed/#resources","title":"Resources","text":"<ul> <li>Article: Inspecting EMF Models with Exeed</li> </ul>"},{"location":"doc/flexmi/","title":"Flexmi","text":"<p>Flexmi (pronounced flex-em-eye) is a reflective textual syntax for EMF models. Flexmi supports an XML-based and a YAML-based flavour and offers features such as fuzzy matching of tags and attributes against Ecore class/feature names, support for embedding EOL expressions in models and for defining and instantiating model element templates. For example, the following XML document (<code>acme.flexmi</code>):</p> <pre><code>&lt;?nsuri psl?&gt;\n&lt;project title=\"ACME\"&gt;\n&lt;person name=\"Alice\"/&gt;\n&lt;person name=\"Bob\"/&gt;\n&lt;task title=\"Analysis\" start=\"1\" dur=\"3\"&gt;\n&lt;effort person=\"Alice\"/&gt;\n&lt;/task&gt;\n&lt;task title=\"Design\" start=\"4\" dur=\"6\"&gt;\n&lt;effort person=\"Bob\"/&gt;\n&lt;/task&gt;\n&lt;task title=\"Implementation\" start=\"7\" dur=\"3\"&gt;\n&lt;effort person=\"Bob\" perc=\"50\"/&gt;\n&lt;effort person=\"Alice\" perc=\"50\"/&gt;\n&lt;/task&gt;\n&lt;/project&gt;\n</code></pre> <p>is a valid instance of the Ecore metamodel (in Emfatic) below (<code>psl</code> stands for Project Scheduling Language):</p> <pre><code>@namespace(uri=\"psl\", prefix=\"\")\npackage psl;\n\nclass Project {\n  attr String name;\n  attr String description;\n  val Task[*] tasks;\n  val Person[*] people;\n}\n\nclass Task {\n  attr String title;\n  attr int start;\n  attr int duration;\n  val Effort[*] effort;\n}\n\nclass Person {\n  attr String name;\n  ref Skill[*] skills;\n}\n\nclass Effort {\n  ref Person person;\n  attr int percentage = 100;\n}\n\nclass Skill {\n  attr String name;\n}</code></pre>"},{"location":"doc/flexmi/#getting-started","title":"Getting started","text":"<ul> <li>Create a text file named <code>psl.emf</code> in your workspace and place the Emfatic content above in it.</li> <li>Convert it into Ecore and register the produced Ecore metamodel     (<code>psl.ecore</code>) as shown     here.</li> <li>Create a new text file named <code>acme.flexmi</code> and place the XML content above in it.</li> <li>The result should look like the screenshot below.</li> </ul>"},{"location":"doc/flexmi/#fuzzy-parsing","title":"Fuzzy Parsing","text":"<p>The Flexmi parser uses fuzzy matching to map the tags in the XML document to instances of EClasses in the target metamodel. In Flexmi, attributes and non-containment references are captured using XML attributes. Multiple values can be captured in a single XML attribute as comma-delimited strings as shown below.</p> <pre><code>&lt;?nsuri psl?&gt;\n&lt;_&gt;\n&lt;person name=\"Alice\" skills=\"Java, HTML\"/&gt;\n&lt;skill name=\"Java\"/&gt;\n&lt;skill name=\"HTML\"/&gt;\n&lt;/_&gt;\n</code></pre> <p>Containment references are captured using XML element containment. If an XML element has attributes, the Flexmi parser will compare its tag against EClass/EReference names expected in the context and choose the best match. For example, when it encounters the <code>&lt;person&gt;</code> element below, knowing that it is already in the context of <code>Project</code> it will match the name <code>person</code> against the names of the containment references of <code>Project</code> (<code>tasks</code>, <code>people</code>) and (all the sub-types of) their types (<code>Person</code>, <code>Task</code>) and will decide that the best match for it is <code>Person</code>.</p> <pre><code>&lt;?nsuri psl?&gt;\n&lt;project title=\"ACME\"&gt;\n&lt;person name=\"Alice\"/&gt;\n...\n&lt;/project&gt;\n</code></pre> <p>As such, it will create an instance of <code>Person</code> and will then try to find a suitable containment reference for it (<code>people</code>). If there were multiple containment references of type <code>Person</code> in class <code>Project</code>, we could help the Flexmi parser by either using the name of the target reference instead or <code>person</code>, or by using an empty container element as follows.</p> <pre><code>&lt;?nsuri psl?&gt;\n&lt;project title=\"ACME\"&gt;\n&lt;people&gt;\n&lt;person name=\"Alice\"/&gt;\n&lt;/people&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"doc/flexmi/#non-containment-reference-resolution","title":"Non-Containment Reference Resolution","text":"<p>To resolve non-containment references, Flexmi needs target elements to have some kind of ID. If a class has an EAttribute marked as <code>id</code>, Flexmi will use that to identify its instances, otherwise, it will use the value of the <code>name</code> attribute, if present. Fully-qualified ID paths, separated by <code>.</code> are also supported.</p>"},{"location":"doc/flexmi/#long-attribute-values","title":"Long Attribute Values","text":"<p>XML elements can also be used instead of XML attributes to capture long/multiline EAttributes. For example, we can use a <code>&lt;description&gt;</code> nested element instead of an attribute as below.</p> <pre><code>&lt;?nsuri psl?&gt;\n&lt;project title=\"ACME\"&gt;\n&lt;description&gt;\nLorem ipsum dolor sit amet,\n    consectetur adipiscing elit,\n    sed do eiusmod tempor incididunt\n    ut labore et dolore magna aliqua.\n  &lt;/description&gt;\n&lt;/project&gt;\n</code></pre> <p>To keep very long values out of Flexmi models altogether, appending an <code>_</code> to the name of an attribute will instruct the Flexmi parser to look for a file with that name and parse its content as the value of the attribute as shown below.</p> <pre><code>&lt;?nsuri psl?&gt;\n&lt;project title=\"ACME\" description_=\"readme.txt\"&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"doc/flexmi/#attribute-assignment","title":"Attribute Assignment","text":"<p>The Flexmi parser uses an implementation of the Hungarian algorithm to decide the best match of XML attribute names to EAttribute and non-containment EReference names. Containment EReference names are currently ignored during matching.</p>"},{"location":"doc/flexmi/#executable-attributes","title":"Executable Attributes","text":"<p>Prepending <code>:</code> to the name of an attribute instructs the Flexmi parser to interpret its value as an executable EOL expression instead of a literal value. Also, Flexmi supports attaching a <code>:var</code> or a <code>:global</code> attribute to XML elements, to declare local/global variables that can be used in EOL expressions. The scope of local variables includes siblings of the element, and their descendants, while global variables can be accessed from anywhere in the model.</p> <p>For example, in the Flexmi model below, the <code>Design</code> task is assigned to a local variable named <code>design</code>, which is then used to compute the value of the <code>start</code> time of the implementation task.</p> <pre><code>&lt;?nsuri psl?&gt;\n&lt;project title=\"ACME\"&gt;\n&lt;person name=\"Alice\"/&gt;\n&lt;person name=\"Bob\"/&gt;\n&lt;task title=\"Analysis\" start=\"1\" dur=\"3\"&gt;\n&lt;effort person=\"Alice\"/&gt;\n&lt;/task&gt;\n&lt;task title=\"Design\" start=\"4\" dur=\"6\" :var=\"design\"&gt;\n&lt;effort person=\"Bob\"/&gt;\n&lt;/task&gt;\n&lt;task title=\"Implementation\" :start=\"design.start + design.duration + 1\" dur=\"3\"&gt;\n&lt;effort person=\"Bob\" perc=\"50\"/&gt;\n&lt;effort person=\"Alice\" perc=\"50\"/&gt;\n&lt;/task&gt;\n&lt;/project&gt;\n</code></pre> <p>You can also use <code>:var</code>/<code>:global</code> and EOL attributes to refer to model elements without using names/ids as identifiers. For example, in the version, below, <code>Alice</code> is attached to the local variable name <code>alice</code>, which is then used in the <code>:person</code> reference of the second effort of the <code>Implementation</code> task.</p> <pre><code>&lt;?nsuri psl?&gt;\n&lt;project title=\"ACME\"&gt;\n&lt;person name=\"Alice\" :var=\"alice\"/&gt;\n&lt;person name=\"Bob\"/&gt;\n&lt;task title=\"Analysis\" start=\"1\" dur=\"3\"&gt;\n&lt;effort person=\"Alice\"/&gt;\n&lt;/task&gt;\n&lt;task title=\"Design\" start=\"4\" dur=\"6\" :var=\"design\"&gt;\n&lt;effort person=\"Bob\"/&gt;\n&lt;/task&gt;\n&lt;task title=\"Implementation\" :start=\"design.start+design.duration+1\" dur=\"3\"&gt;\n&lt;effort person=\"Bob\" perc=\"50\"/&gt;\n&lt;effort :person=\"alice\" perc=\"50\"/&gt;\n&lt;/task&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"doc/flexmi/#object-initialization","title":"Object Initialization","text":"<p>An XML element representing an object can have an <code>:init</code> child with complex EOL-based initialization logic. For example, this would initialize the \"Analysis\" task to have an Effort child pointing to the first Person in the model:</p> <pre><code>&lt;?nsuri psl?&gt;\n&lt;project title=\"ACME\"&gt;\n&lt;person name=\"Alice\"/&gt;\n&lt;person name=\"Bob\"/&gt;\n&lt;task title=\"Analysis\" start=\"1\" dur=\"3\"&gt;\n&lt;:init&gt;\nvar effort = new Effort();\n      self.effort.add(effort);\n      effort.person = Person.all.first();\n    &lt;/:init&gt;\n&lt;/task&gt;\n&lt;/project&gt;\n</code></pre> <p>ITool instances not available</p> <p>Since Flexmi is designed to work from outside Eclipse, Eclipse extension point-based tools are not available from Flexmi EOL code.</p>"},{"location":"doc/flexmi/#including-and-importing-other-flexmi-models","title":"Including and Importing other Flexmi Models","text":"<p>Flexmi supports the <code>&lt;?import other.flexmi?&gt;</code> and <code>&lt;?include other.flexmi?&gt;</code> processing instructions. <code>import</code> creates a new resource for <code>other.flexmi</code> while <code>include</code> parses the contents of <code>other.flexmi</code> as if they were embedded in the Flexmi model that contains the <code>include</code> processing instruction.</p>"},{"location":"doc/flexmi/#instantiating-types-from-multiple-ecore-metamodels","title":"Instantiating Types from Multiple Ecore Metamodels","text":"<p>Multiple <code>&lt;?nsuri metamodeluri?&gt;</code> processing instructions can be used in the preamble of a Flexmi model, allowing it to instantiate multiple Ecore metamodels. However, in case of name clashes between them, there's no good way for disambiguation.</p>"},{"location":"doc/flexmi/#models-with-multiple-root-elements","title":"Models with Multiple Root Elements","text":"<p>If you need to have multiple top-level elements in your model, you can add them under a <code>&lt;_&gt;</code> root element, which has no other semantics.</p>"},{"location":"doc/flexmi/#reusable-templates","title":"Reusable Templates","text":"<p>Flexmi supports defining reusable templates through the reserved <code>&lt;:template&gt;</code> XML tag. For example, when designing one-person projects where all tasks take place in sequence, we can omit all the repetitive <code>&lt;effort&gt;</code> elements that refer to the same person, and we can automate the calculation of the start date of each task using a <code>simpletask</code> template, as shown below.</p> <pre><code>&lt;?nsuri psl?&gt;\n&lt;_&gt;\n&lt;project title=\"ACME\"&gt;\n&lt;person name=\"Alice\"/&gt;\n&lt;simpletask title=\"Analysis\" dur=\"3\"/&gt;\n&lt;simpletask title=\"Design\" dur=\"3\"/&gt;\n&lt;simpletask title=\"Implementation\" dur=\"6\"/&gt;\n&lt;/project&gt;\n\n&lt;:template name=\"simpletask\"&gt;\n&lt;content&gt;\n&lt;task :start=\"Task.all.indexOf(self).asVar('index') == 0 ? 1 : Task.all.get(index-1).asVar('previous').start + previous.duration\"&gt;\n&lt;effort :person=\"Person.all.first()\"/&gt;\n&lt;/task&gt;\n&lt;/content&gt;\n&lt;/:template&gt;\n&lt;/_&gt;\n</code></pre>"},{"location":"doc/flexmi/#parameters","title":"Parameters","text":"<p>Flexmi templates also support parameters, which can be used to configure the content they produce when they are invoked. An example is shown below:</p> <pre><code>&lt;?nsuri psl?&gt;\n&lt;_&gt;\n&lt;project title=\"ACME\"&gt;\n&lt;person name=\"Alice\"/&gt;\n&lt;design dur=\"3\" person=\"Alice\"/&gt;\n&lt;/project&gt;\n\n&lt;:template name=\"design\"&gt;\n&lt;parameter name=\"person\"/&gt;\n&lt;content&gt;\n&lt;task name=\"Design\"&gt;\n&lt;effort person=\"${person}\"/&gt;\n&lt;/task&gt;\n&lt;/content&gt;\n&lt;/:template&gt;\n&lt;/_&gt;\n</code></pre>"},{"location":"doc/flexmi/#dynamic-templates-and-slots","title":"Dynamic Templates and Slots","text":"<p>To further customise the content that Flexmi templates produce, one can use an EGL template that produces XML as the value of the <code>&lt;content&gt;</code> element of the template, by setting it's language to EGL as shown below. Also Flexmi supports a <code>&lt;:slot&gt;</code> element in the content of templates, which specifies where any nested elements of the caller should be placed in the produced XML as shown below.</p> <pre><code>&lt;?nsuri psl?&gt;\n&lt;_&gt;\n&lt;project title=\"ACME\"&gt;\n&lt;person name=\"Alice\"/&gt;\n&lt;longtask title=\"Implementation\" years=\"2\"&gt;\n&lt;effort person=\"Alice\"/&gt;\n&lt;/longtask&gt;\n&lt;/project&gt;\n\n&lt;:template name=\"longtask\"&gt;\n&lt;parameter name=\"years\"/&gt;\n&lt;content language=\"EGL\"&gt;\n&lt;![CDATA[\n      &lt;task duration=\"[%=years.asInteger()*12%]\"&gt;\n        &lt;:slot/&gt;\n      &lt;/task&gt;\n      ]]&gt;\n&lt;/content&gt;\n&lt;/:template&gt;\n&lt;/_&gt;\n</code></pre>"},{"location":"doc/flexmi/#reusing-templates-in-different-flexmi-models","title":"Reusing Templates in Different Flexmi Models","text":"<p>Templates can be stored in separate Flexmi files and be imported from different models using Flexmi's <code>&lt;?include ?&gt;</code> processing instruction.</p>"},{"location":"doc/flexmi/#use-in-epsilon-and-java","title":"Use in Epsilon and Java","text":"<p>Flexmi offers and registers an implementation of EMF's Resource interface (<code>FlexmiResource</code>), and can be used like any other EMF resource implementation. For example, you can add <code>.flexmi</code> models as regular EMF models to the run configuration of your Epsilon program. An example of using Flexmi from Java follows.</p> <pre><code>ResourceSet resourceSet = new ResourceSetImpl();\nresourceSet.getResourceFactoryRegistry().\ngetExtensionToFactoryMap().put(\"flexmi\",\nnew FlexmiResourceFactory());\nResource resource = resourceSet.createResource\n(URI.createFileURI(\"/../acme.flexmi\"));\nresource.load(null);\n</code></pre>"},{"location":"doc/flexmi/#converting-to-xmi","title":"Converting to XMI","text":"<p>You can convert a Flexmi model to standard XMI (with no templates, executable attributes etc.) by right-clicking on it in the Project Explorer view and selecting <code>Generate XMI</code>.</p> <p>Converting an XMI model to Flexmi on the other hand is not supported as there's no unique mapping in this direction.</p>"},{"location":"doc/flexmi/#yaml-flavour","title":"YAML Flavour","text":"<p>Since Epsilon 2.3.0, Flexmi also supports a YAML flavour. Equivalent YAML representations for the XML-based model at the top of this page are shown below.</p> <p>Info</p> <p>The YAML flavour of Flexmi supports all the features of the XML flavour, including plain and dynamic templates, and executable attributes. Also, it is worth noting that YAML is a superset of JSON.</p> Indentation-basedCurly brackets-based <pre><code>?nsuri: psl\nproject:\n- name: ACME\n- person: {name: Alice}\n- person: {name: Bob}\n- task:\n- title: Analysis\n- start: 1\n- dur: 3\n- effort: {person: Alice}\n- task:\n- title: Design\n- start: 4\n- dur: 6\n- effort: {person: Bob}\n- task:\n- title: Implementation\n- start: 7\n- dur: 3\n- effort: {person: Bob, perc: 50}\n- effort: {person: Alice, perc: 50}\n</code></pre> <pre><code>?nsuri: psl\nproject: {\n  name: ACME,\n  person: {name: Alice},\n  person: {name: Bob},\n  task: {\n    title: Analysis,\n    start: 1,\n    dur: 3,\n    effort: {person: Alice}\n},\n  task: {\n    title: Design,\n    start: 4,\n    dur: 6,\n    effort: {person: Bob}\n},\n  task: {\n    title: Implementation,\n    start: 7,\n    dur: 3,\n    effort: {person: Bob, perc: 50},\n    effort: {person: Alice, perc: 50}\n}\n}\n</code></pre> <p>For multi-valued attributes and non-containment references, comma-separated values, or lists of scalars can be used as shown below.</p> <pre><code>- ?nsuri: psl\n- person:\n- name: Alice - skills: Java, HTML # Comma-separated\n- person:\n- name: Bob\n- skills: # List of scalars\n- Java\n- HTML\n- skill: {name: Java}\n- skill: {name: HTML}\n</code></pre> <p>Tabs vs. Spaces</p> <p>If your YAML-flavoured Flexmi model doesn't parse (i.e. the outline view of the Flexmi editor is empty), you may want to check that you have not accidentally used tabs instead of spaces for indentation.</p> <p>The Flexmi parser auto-detects whether a file is XML-based or YAML-based and parses it accordingly. As such, you should be able to edit YAML-flavoured <code>*.flexmi</code> files in the Flexmi editor. Additional examples of YAML-flavoured Flexmi models are available in this test project (look for <code>*.yaml</code> files).</p>"},{"location":"doc/flexmi/#dynamic-templates-in-yaml","title":"Dynamic Templates in YAML","text":"<p>The YAML flavour requires a <code>script</code> attribute in the <code>content</code> of dynamic templates, that holds the EGL script used to dynamically produce the YAML content. The YAML equivalent of the XML-based dynamic template shown above is as follows.</p> <pre><code>- ?nsuri: psl\n\n- project:\n- title: ACME\n- person:\n- name: Alice\n- longtask:\n- title: Implementation\n- years: 2\n- effort:\n- person: Alice\n\n- :template:\n- name: longtask\n- parameter:\n- name: years\n- content:\n- language: EGL\n- script: |- # Multi-line EGL script\n- task:\n- duration: [%=years.asInteger()*12%]\n- :slot\n</code></pre>"},{"location":"doc/flexmi/#philosophy","title":"Philosophy","text":"<p>Flexmi was originally developed as a quick and dirty way to type in EMF models without having to define an Xtext grammar or adhere to the rigid naming rules of XMI or HUTN. The name is a combination of the word \"flexible\" and the \"XMI\" acronym.</p>"},{"location":"doc/flexmi/#limitations","title":"Limitations","text":"<ul> <li>Flexmi resources can't be saved programmatically (i.e. trying to call <code>resource.save(...)</code> will do nothing).</li> <li>There is no code completion in the Flexmi editor at the moment.</li> </ul>"},{"location":"doc/flexmi/#resources","title":"Resources","text":"<ul> <li>More examples of using Flexmi can be found in projects containing <code>flexmi</code> in their name, under the examples folder of Epsilon's Git repository.</li> <li>This article shows how to use Flexmi models in ANT/Gradle/Maven builds</li> <li>Flexmi and relevant underpinning research is further described in the following papers:<ul> <li>Towards Flexible Parsing of StructuredTextual Model Representations</li> <li>Towards a Modular and Flexible Human-UsableTextual Syntax for EMF Models</li> <li>Type Inference in Flexible Model-Driven Engineering using Classification Algorithms</li> </ul> </li> </ul>"},{"location":"doc/modelink/","title":"Modelink","text":"<p>ModeLink is an editor consisting of 2-3 side-by-side EMF tree-based editors, and in combination with the reflective Exeed editor, it is very convenient for establishing links between different models using drag-and-drop. ModeLink uses native EMF cross-resource references to capture links between different models and as such, models constructed with it can be then used by any EMF-compliant tool/language.</p> <p></p>"},{"location":"doc/picto/","title":"Visualising Models with Picto","text":"<p>Picto is an Eclipse view for visualising models via model-to-text transformation to SVG/HTML. Compared to existing graphical modelling frameworks such as Sirius and GMF/Eugenia, the main appeal of Picto is that model visualisation takes place in an embedded browser and therefore you can leverage any HTML/SVG/JavaScript-based technology such as D3.js, mxGraph and JointJS. Picto also provides built-in support for the powerful Graphviz and PlantUML textual syntaxes (which are transformed to SVG via the respective tools). A distinguishing feature of Picto is that it does not require running multiple Eclipse instances as the metamodels, models and visualisation transformations can all reside in the same workspace.</p> <p>Tip</p> <p>As Picto uses EGL for model-to-text transformation, it is not limited to EMF-based models and can be used to visualise the contents of Simulink models, XML documents, spreadsheets, and any other type of artefact supported by an Epsilon EMC driver.</p> Citing Picto in a publication? <p>If you are referring to Picto in a publication, please cite this paper instead of the website URL. A pre-print of the paper is available here.</p> <p>On the flip side, Picto displays read-only views of models and as such it is not a good fit if diagram-based model editing capabilities are required. In this article we demonstrate Picto through a small social network example. The complete source code of the example is available here.</p> <p></p>"},{"location":"doc/picto/#metamodel","title":"Metamodel","text":"<p>We start with the metamodel of our social network DSL expressed in Emfatic (the <code>.ecore</code> version of the metamodel is also provided in the repository). The DSL allows modelling people in a network and likes/dislikes relationships between them.</p> <pre><code>@namespace(uri=\"socialnetwork\", prefix=\"\")\npackage socialnetwork;\n\nclass SocialNetwork {\n    val Person[*] people;\n}\n\nclass Person {\n    attr String name;\n    ref Person[*] likes;\n    ref Person[*] dislikes;\n}</code></pre>"},{"location":"doc/picto/#model","title":"Model","text":"<p>Below is a model that conforms to the social network metamodel. The model is defined for convenience in Flexmi, however Picto also works with XMI-based models (see below).</p> <pre><code>&lt;?nsuri socialnetwork?&gt;\n&lt;?render-egx picto/socialnetwork.egx?&gt;\n&lt;socialnetwork&gt;\n&lt;person name=\"Alice\" likes=\"Bob, Charlie\"/&gt;\n&lt;person name=\"Bob\" likes=\"Enid, Alice\" dislikes=\"Fred, Charlie\"/&gt;\n&lt;person name=\"Charlie\" likes=\"Fred, Alice\" dislikes=\"Dawn, Enid\"/&gt;\n&lt;person name=\"Dawn\" likes=\"Bob\" dislikes=\"Fred\"/&gt;\n&lt;person name=\"Enid\" likes=\"Charlie\" dislikes=\"Alice\"/&gt;\n&lt;person name=\"Fred\" dislikes=\"Bob\" likes=\"Enid, Alice\"/&gt;\n&lt;/socialnetwork&gt;\n</code></pre> <p>In line 2 of the model, notice the <code>render-egx</code> processing instruction, which specifies a model-to-text transformation written in EGX/EGL, that Picto should use to visualise this model.</p>"},{"location":"doc/picto/#model-to-text-transformation","title":"Model-to-Text Transformation","text":"<p>The <code>socialnetwork.egx</code> EGX model-to-text transformation is as follows:</p> <pre><code>rule Network2Graphviz\n    transform n : socialnetwork::SocialNetwork {\n\n    template : \"socialnetwork2graphviz.egl\"\n\n    parameters : Map{\n        \"path\" = Sequence{\"Social Network\"},\n        \"icon\" = \"diagram-ffffff\",\n        \"format\" = \"graphviz-circo\",\n        \"layers\" = Sequence {\n            Map {\"id\"=\"likes\", \"title\"=\"Likes\", \"active\"=true},\n            Map {\"id\"=\"dislikes\", \"title\"=\"Dislikes\", \"active\"=true}\n        },\n        \"people\" = n.people\n    }\n\n}\n\nrule Person2Graphviz\n    transform p : socialnetwork::Person {\n\n    template : \"socialnetwork2graphviz.egl\"\n\n    parameters : Map{\n        \"path\" = Sequence{\"Social Network\", p.name},\n        \"icon\" = \"diagram-c0c0c0\",\n        \"format\" = \"graphviz-dot\",\n        \"layers\" = Sequence {\n            Map {\"id\"=\"likes\", \"title\"=\"Likes\", \"active\"=true},\n            Map {\"id\"=\"dislikes\", \"title\"=\"Dislikes\", \"active\"=true}\n        },\n        \"people\" = Sequence{p}\n    }\n\n}</code></pre> <p>The transformation consists of two rules:</p> <ul> <li><code>Network2Graphviz</code> which will be executed once and will produce a Graphviz graph for the entire network</li> <li><code>Person2Graphviz</code> which will be executed for every person in the network and produce the person's own local likes/dislikes graph</li> </ul> <p>Each rule specifies the EGL template that it will invoke (<code>socialnetwork2graphviz.egl</code> in both cases here) as well as a set of parameters that Picto needs. The parameters are as follows:</p> <ul> <li><code>path</code>: A collection of strings that specify the path of the produced view in the Picto tree</li> <li><code>icon</code>: The icon of the view on the Picto tree. Allowed values at the moment are file names (without the extension) of all icon files under this folder, as well as <code>diagram-rrggbb</code> values where <code>rrggbb</code> is a hex colour. Additionally, you can extend the available set of icons by populating an <code>icons</code> folder next to the model-to-text transformation file that defines your Picto visualisation (e.g. next to <code>socialnetwork.egx</code>)</li> <li><code>format</code>: The format of the view that the EGL transformation will produce. Built-in formats supported in Epsilon 2.4.0 are <code>graphviz-dot</code>, <code>graphviz-circo</code>, <code>graphviz-neato</code>, <code>graphviz-fdp</code>, <code>plantuml</code>, <code>text</code>, <code>html</code> and <code>svg</code>. Epsilon 2.5.0 will add integration with Kroki servers (both public and self-hosted): the Kroki <code>/FORMAT/svg</code> endpoint is available as <code>kroki-FORMAT</code> (e.g. <code>kroki-plantuml</code>, <code>kroki-structurizr</code>, or <code>kroki-mermaid</code>).</li> <li><code>layers</code>: A sequence of maps, each of which represents a layer of the view. Each layer needs to define an <code>id</code>, a <code>title</code> and (optionally), whether it is <code>active</code> by default</li> </ul> <p>The EGL template <code>socialnetwork2graphviz.egl</code> is as follows:</p> <pre><code>digraph G {\n    node[shape=rectangle, fontname=Tahoma, fontsize=10, style=\"filled\",\n        gradientangle=\"270\", fillcolor=\"bisque\"]\n\n    edge[penwidth=3, style=tapered, arrowhead=none]\n\n[%for (p in people){%]\n\n    [%=p.name%] [%if (people.size()==1){%][fillcolor=\"azure2\"][%}%]\n\n    [%if (isLayerActive(\"likes\")){%]\n        [%for (l in p.likes){%]\n            [%=p.name%] -&gt; [%=l.name%] [color=\"#2A6C41\"]\n        [%}%]\n    [%}%]\n\n    [%if (isLayerActive(\"dislikes\")){%]\n        [%for (l in p.dislikes){%]\n            [%=p.name%] -&gt; [%=l.name%] [color=\"#B43431\"]\n        [%}%]\n    [%}%]\n\n[%}%]\n\n}\n\n[%\noperation isLayerActive(id : String) {\n    var layer = layers.selectOne(l|l.id = id);\n    if (layer.isDefined()) {\n        return layer.active;\n    }\n    else {\n        return true;\n    }\n}\n%]</code></pre>"},{"location":"doc/picto/#result","title":"Result","text":"<p>Every time <code>socialnetwork.flexmi</code> is saved, Picto will run the EGX/EGL transformation and display the results in a view that consists of a tree viewer and a browser. For this model, Picto produces 7 diagrams; one for the network as a whole through the application of the <code>Network2Graphviz</code> rule and one for each person in the network through the application of the <code>Person2Graphviz</code> rule. Screenshots of the populated Picto view appear below.</p> <p></p> <p></p>"},{"location":"doc/picto/#layers","title":"Layers","text":"<p>Picto supports the concept of layers to allow users to show/hide information on a diagram. Both EGX rules specify a \"likes\" and a \"dislikes\" layer (lines 11-12 and 29-30) which the user can turn on/off to show/hide like/dislike relationships in the current diagram. Hiding the \"dislikes\" layer, makes the network-level diagram look like this.</p> <p></p>"},{"location":"doc/picto/#scalability","title":"Scalability","text":"<p>Picto works in a lazy way and initially computes only the details needed to show the tree of views (view paths and icons) on its left-hand side. The content of individual views is computed on demand when a user clicks on a view in the Picto tree. We have used Picto with models and visualisation transformations that produce hundreds of deeply nested views without performance issues. Having said that, as models grow in size, the time it takes the underlying modelling framework (e.g. EMF) to load them into memory and the time it takes EGL to process them are also bound to grow. In such cases, consider fragmenting your models across many files. It is also important to try and do as little work as possible at the EGX level and carry out any expensive computations within the EGL templates instead.</p> <p>When targeting Graphviz or PlantUML it is also advisable to keep your generated diagrams relatively small as auto-layout is computationally expensive (particularly routing edges) and rendering your views can take a long time. For example, generating the Graphviz representation of the full UML metamodel class diagram (260+ classes/650+ references) is instantaneous but getting Graphviz's dot program to render it takes hours. In any event, such a diagram would have been unreadable, and hence pointless (see the 20-class/50-references diagram of Ecore.ecore below, which is generated and rendered instantaneously).</p> <p></p> <p>To \"protect\" your visualisation rules from input that is bound to generate meaningless output you can use guards as shown below.</p> <pre><code>rule ClassDiagram {\n\n    guard : EClass.all.size() &lt; 30\n\n    parameters : Map {\n        \"classes\" = EClass.all,\n        \"format\" = \"graphviz-dot\",\n        \"path\" = List{\"Model\", \"(All Classes)\"},\n        \"icon\" = \"diagram-ff0000\"\n    }\n\n    template: \"ecore2dot.egl\"\n\n}</code></pre> <p>In such cases, it is preferable to generate many smaller diagrams; for this example, a class diagram for each class of the metamodel, surrounded by its super/sub/referenced types.</p>"},{"location":"doc/picto/#interactive-diagrams","title":"Interactive Diagrams","text":"<p>Diagrams can also be linked to each other and link back to the models from which they were generated. For example, clicking any of the yellow classes in the diagram below takes you to the respective diagram and clicking on the green EClassifer class, takes you to the class definition in the Ecore editor. This is achieved through two built-in JavaScript functions below, which are showcased here.</p> Signature Description showView(String[] path) Shows the view with the specified path - e.g. <code>top.showView(['Model', 'Classes', 'EClassifier'])</code> showElement(String elementId, String resourceUri) Selects the specified element in its Eclipse-based editor (e.g. the EMF tree-based editor) <p></p>"},{"location":"doc/picto/#multiple-picto-views","title":"Multiple Picto Views","text":"<p>It is possible to open several Picto views in the same Eclipse workbench, which can be pinned to the same or different model editors. In the image below, the class diagram on the bottom left is pinned to the Social Network metamodel shown in the top left. The three Picto windows on the bottom right contain different views of the social network model shown in the tree editor of the top right.</p> <p></p>"},{"location":"doc/picto/#editors-supported-by-picto","title":"Editors supported by Picto","text":"<ul> <li>Any editor that implements EMF's <code>IEditingDomainProvider</code> interface (e.g. the reflective Ecore editor, Exeed) as long as next to the edited file there is a file with the same name and a <code>.picto</code> suffix providing the format of the visualisation and the EGL template to be used (see the XMI-based <code>socialnetwork.model</code> and <code>socialnetwork.model.picto</code> files in the example directory)</li> <li>Flexmi editor: as long as the Flexmi model contains a <code>&lt;?render-xxx ?&gt;</code> processing instruction</li> <li>Emfatic editor</li> <li>Default text editor editing files with <code>.html</code>, <code>.svg</code>, <code>.dot</code>, <code>.neato</code> file extensions (mainly for debugging)</li> </ul>"},{"location":"doc/picto/#extending-picto","title":"Extending Picto","text":"<p>Picto provides the following extension points that can be used to extend its functionality.</p> Extension Point Description org.eclipse.epsilon.picto.pictoSource Bind Picto to a type of Eclipse-based editors so that Picto auto-refreshes every time a file in an editor of this type is saved org.eclipse.epsilon.picto.browserFunction Add a custom Javascript function that generated diagrams can call (much like the <code>showView</code> and <code>showElement</code> functions above) org.eclipse.epsilon.picto.browserScript Add a Javascript that executes when the Picto browser loads org.eclipse.epsilon.picto.viewContentTransformer Transform a custom content type to HTML, or to a content type that another ViewContentTransformer can transform. See MarkdownContentTransformer as an example. org.eclipse.epsilon.picto.htmlElementTransformer Add support for custom HTML elements to Picto. See PictoViewElementTransformer as an example, which adds a new <code>&lt;picto-view path=\"...\"/&gt;</code> HTML tag to Picto, that supports embedding Picto views within other Picto views. <p>Please see this plugin.xml, which shows how some of these extension points were used to integrate Picto with different technologies, such as PlantUML or Mermaid.</p>"},{"location":"doc/picto/#using-picto-in-standalone-mode-with-many-models","title":"Using Picto in standalone mode / with many models","text":"<p>Picto also suports a standalone mode, where the details of the models to be visualised are provided within the <code>.picto</code> file itself. An example of visualising <code>socialnetwork.model</code> in standalone mode (without the model being open in a tree editor) is below and in <code>socialnetwork-standalone.picto</code> in the example folder.</p> <pre><code>&lt;?nsuri picto?&gt;\n&lt;picto format=\"egx\" transformation=\"picto/socialnetwork.egx\" standalone=\"true\"&gt;\n&lt;model type=\"EMF\"&gt;\n&lt;parameter name=\"name\" value=\"M\"/&gt;\n&lt;parameter name=\"metamodelUri\" value=\"socialnetwork\"/&gt;\n&lt;parameter name=\"modelFile\" file=\"socialnetwork.model\"/&gt;\n&lt;/model&gt;\n&lt;/picto&gt;\n</code></pre>"},{"location":"doc/picto/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If you can't find the Picto view, you will need to upgrade to a version of Epsilon &gt;= 2.0.</li> <li>Graphviz (on which the PlantUML integration also depends) does not ship as part of Picto. You will need to install it manually on your computer. Picto expects the Graphviz programs (e.g. <code>dot</code>, <code>circo</code>) to be:<ul> <li>Anywhere on the path in Windows.</li> <li>Under <code>/usr/local/bin/</code> in MacOS.</li> <li>Under <code>/usr/bin/</code> in Linux.</li> </ul> </li> <li>If you are using Windows and some of the web content is not rendering correctly, you may want to enable the option in \"Window - Preferences - Epsilon - Picto\" to use Edge as the embedded browser.<ul> <li>This is available from Epsilon 2.5, and it requires Eclipse 4.19 (2021-03) or later.</li> <li>If it still fails to render, you may need to install Microsoft WebView2.</li> </ul> </li> </ul>"},{"location":"doc/picto/#philosophy","title":"Philosophy","text":"<p>While EMF provides support for reflective model instantiation within the same Eclipse workspace, graphical and textual modelling frameworks that sit on top of it such as GMF, Sirius and Xtext involve code generation and/or contributing to Eclipse extension points and hence require spawning a new Eclipse instance. While this inconvenience can pay off for large DSLs, it feels like an overkill when one needs to throw together a small DSL in situ. The original aim of Picto was to complement Flexmi in this respect by contributing model visualisation capabilities where creating a new dedicated graphical editor is considered to be an overkill.</p>"},{"location":"doc/picto/#gallery","title":"Gallery","text":""},{"location":"doc/picto/#additional-resources","title":"Additional Resources","text":"<p>Additional resources about Picto are available here.</p>"},{"location":"doc/pinset/","title":"Dataset Extraction (Pinset)","text":"<p>The Pinset language offers specific syntax constructs to extract table-like datasets from models. The main objective of Pinset is to facilitate the analysis of models data via conventional data mining and machine learning techniques, which impose a tabular input format. In addition, tables can be useful as an extra viewpoint when creating model visualisations.</p>"},{"location":"doc/pinset/#model-example","title":"Model example","text":"<p>We use as running example a course model, which contains the enrolled students along with their grades. All models and Pinset scripts shown in this documentation can be found in an example project in the Epsilon repository.</p> <p>All Pinset scripts query the following metamodel:</p> classDiagram class Course {     name: String } class Student {     ID: String     name: String     isRemote: Boolean } class ContactDetails {     email: String     phone: String } class EvaluationItem {     name: String     percentage: int } class Grade {     points: int } Course *--&gt; Student: students * Course *--&gt; EvaluationItem: items * Student *--&gt; ContactDetails: contact Student *--&gt; Grade: grades * Grade --&gt; EvaluationItem: item <p>As for the data shown as a result of the Pinset scripts, we use the following Flexmi model, which conforms to the metamodel above:</p> <pre><code>&lt;?nsuri grades?&gt;\n&lt;course name=\"Model-Driven Engineering\"&gt;\n&lt;item name=\"Lab 1\" perc=\"15\"/&gt;\n&lt;item name=\"Lab 2\" perc=\"15\"/&gt;\n&lt;item name=\"Partial Test\" perc=\"20\"/&gt;\n&lt;item name=\"Final Exam\" perc=\"50\"/&gt;\n\n&lt;student id=\"S1\" name=\"Alice\"&gt;\n&lt;contact email=\"alice@university.com\" phone=\"+44 101\"/&gt;\n&lt;grade item=\"Lab 1\" points=\"60\"/&gt;\n&lt;grade item=\"Lab 2\" points=\"90\"/&gt;\n&lt;grade item=\"Partial Test\" points=\"80\"/&gt;\n&lt;grade item=\"Final Exam\" points=\"85\"/&gt;\n&lt;/student&gt;\n&lt;student id=\"S2\" name=\"Bob\" remote=\"true\"&gt;\n&lt;contact email=\"bob@university.com\" phone=\"+44 654\"/&gt;\n&lt;grade item=\"Lab 1\" points=\"60\"/&gt;\n&lt;grade item=\"Final Exam\" points=\"100\"/&gt;\n&lt;/student&gt;\n&lt;student id=\"S3\" name=\"Charlie\" remote=\"true\"&gt;\n&lt;contact email=\"charlie@university.com\" phone=\"+44 333\"/&gt;\n&lt;grade item=\"Lab 1\" points=\"50\"/&gt;\n&lt;grade item=\"Lab 2\" points=\"35\"/&gt;\n&lt;grade item=\"Partial Test\" points=\"20\"/&gt;\n&lt;/student&gt;\n&lt;student id=\"S4\" name=\"Dana\"&gt;\n&lt;contact email=\"dana@university.com\"/&gt;\n&lt;grade item=\"Lab 1\" points=\"100\"/&gt;\n&lt;grade item=\"Lab 2\" points=\"90\"/&gt;\n&lt;grade item=\"Partial Test\" points=\"70\"/&gt;\n&lt;grade item=\"Final Exam\" points=\"95\"/&gt;\n&lt;/student&gt;\n&lt;/course&gt;\n</code></pre>"},{"location":"doc/pinset/#overview","title":"Overview","text":"<p>This first Pinset example defines a dataset from students data, containing some basic information such as name and student ID, contact details, the number of completed evaluation items, and the final grade for the course:</p> <pre><code>dataset studentsSummary over s : Student {\n    column id: s.ID\n    column name: s.name\n    column phone: s.contact.phone\n\n    column items_completed: s.grades.size\n    column final_grade : s.getFinalGrade()\n\n    column course_outcome {\n        if (final_grade &lt; 50) {\n            return \"fail\";\n        }\n        else if (final_grade &lt; 70) {\n            return \"good\";\n        }\n        else if (final_grade &lt; 90) {\n            return \"notable\";\n        }\n        else {\n            return \"excellent\";\n        }\n    }\n}\n\n@cached\noperation Student getFinalGrade() {\n    return self.grades\n            .collect(g | g.points * g.item.percentage)\n            .sum() / 100;\n}</code></pre> <p>From that Pinset script, the following dataset is generated:</p> id name phone items_completed final_grade course_outcome S1 Alice +44 101 4 81 notable S2 Bob +44 654 2 59 good S3 Charlie +44 333 3 16 fail S4 Dana 4 90 excellent <p>As the above example shows, Pinset offers a rule-based syntax to declare datasets. These rules are specified as a set of column generators that capture data from instances of a type included in an input model. That type is defined as a parameter, after the <code>over</code> keyword. In the example, the chosen type is <code>Student</code>, which by default means that each Student instance of the input model will be used to populate a row of the output dataset.</p> <p>Pinset offers different column generators. This first example uses the <code>column</code> one, which is composed of the name of the column header and an EOL expression to calculate the cell value over the row element.</p> <p>Other common EOL constructs are also available in Pinset scripts. For instance, an EOL block can be used for those column calculations that might be better organised in an imperative set of statements, such as the <code>course_outcome</code> column that shows the final course result in a textual format as used in the Spanish education system. In addition, external operations can be invoked in the column expressions, such as the <code>getFinalGrade()</code> operation used in the example.</p> <p>As a last comment for the <code>column</code> generator, values of previously calculated columns of an element can be used in subsequent definitions. For instance, the <code>course_outcome</code> column uses the <code>finalGrade</code></p> <p>After this overview, next sections describe extra column generators, as well as on other functionalities offered by Pinset for an easier dataset extraction specification.</p>"},{"location":"doc/pinset/#properties-accessors","title":"Properties accessors","text":"<p>As a way to facilitate the definition of columns that simply hold element properties, Pinset offers some column generators to access these properties:</p> <pre><code>dataset studentsContact over s : Student {\n    properties [ID as StudentId, name]\n    reference contact[email, phone]\n}</code></pre> <p>The previous dataset rule results in:</p> StudentId name contact_email contact_phone S1 Alice alice@university.com +44 101 S2 Bob bob@university.com +44 654 S3 Charlie charlie@university.com +44 333 S4 Dana dana@university.com <p>Precisely, Pinset offers two property accessors: the <code>properties</code> generator can be used to generate columns for attributes of the selected type (e.g. <code>ID</code> and <code>name</code> in the example), while the <code>references</code> one allows getting attributes from single references (i.e. upper bound of 1) of the type, such as <code>contact</code>.</p> <p>When using the <code>properties</code> accessor, the name of the attribute is used as column name, while for the <code>references</code> accessor a combination of the name of the reference with the name of the attribute is used (e.g. <code>contact_phone</code>). This default behaviour can be altered by using the <code>as</code> keyword.</p> <p>These accessors also offer null safety. If any attributes or the traversed reference point to null, Pinset automatically inserts a blank value in the cell.</p>"},{"location":"doc/pinset/#row-filtering","title":"Row filtering","text":"<p>By default, all elements of the selected type are processed into rows. As this might sometimes not be desired, Pinset offers some ways to filter out rows from the resulting dataset:</p> <pre><code>dataset remoteStudents over s : Student {\n    guard: s.isRemote\n\n    properties[ID, name]\n}\n\ndataset finalExamAssistants over s : Student\n    from : Student.all.select(s |\n            s.grades.exists(g | g.item.name == \"Final Exam\")) {\n\n    properties[ID, name]\n}</code></pre> <p>These dataset rules show the two ways that can be used to perform filtering in Pinset:</p> <ul> <li> <p>The <code>remoteStudents</code> dataset uses a <code>guard</code> to limit the processed students to the remote ones (based in their boolean attribute). Any element not meeting the guard requirements is excluded from the dataset generation step.</p> </li> <li> <p>The <code>finalExamAssistants</code> dataset uses a <code>from</code> expression to only include those students that took the final exam of the course. A <code>from</code> expression must return a collection of elements of the selected type to be used for the dataset generation. Therefore, this expression can be used for row filtering, and for other things such as performance improvements (i.e. calculate a collection, and use it for multiple dataset generations).</p> </li> </ul> <p>If necessary, both filtering mechanisms can be used simultaneously. For instance, if we combine the <code>guard</code> and <code>from</code> expressions shown above, we would obtain a dataset with the remote students that took the final exam of the course.</p>"},{"location":"doc/pinset/#multiple-columns-grid","title":"Multiple columns: grid","text":"<p>In some cases, we might want to generate a set of columns that are calculated using the same expression, just by changing the parameter(s) of such expression. In the course example, this happens when generating a table including the detailed grades of the students for all the evaluated items of the course, such as the following:</p> ID name Lab_1 Lab_2 Partial_Test Final_Exam final_grade S1 Alice 60 90 80 85 81 S2 Bob 60 100 59 S3 Charlie 50 35 20 16 S4 Dana 100 90 70 95 90 <p>Defining this table with the <code>column</code> generator would quickly become very verbose and tedious, as we would need to use one expression for each evaluated item of the course. Also, using that strategy would match the Pinset script to the specific course, as the script would include the name of the grades that are being represented as columns. Any new item added to future editions of the course, or any new course we might want to suport, would require updating the Pinset script / creating a new one.</p> <p>To prevent this, Pinset offers the <code>grid</code> generator, which allows the batch-definition of similar columns. A <code>grid</code> has three components:</p> <ul> <li><code>keys</code>: determine the elements to use as seeds or parameters of each column.</li> <li><code>header</code>: used to create the name or header of the column, based on the value of each individual <code>key</code>.</li> <li><code>body</code>: used to calculate the value of each cell of the column. Generally, both the row element and the grid <code>key</code> intervene here.</li> </ul> <p>This generator is used in the following dataset rule, which generates the grades table depicted above:</p> <pre><code>dataset studentGrades over s : Student {\n    properties[ID, name]\n\n    grid {\n        keys: EvaluationItem.all\n        header: key.name\n        body: s.grades.selectOne(g | g.item == key)?.points\n    }\n\n    column final_grade : s.getFinalGrade()\n}</code></pre> <p>In that grid generator, the course evaluation items are used as <code>keys</code>, which means that each one of these items would be evaluated over the <code>header</code> and <code>body</code> expressions to generate a new column. The <code>header</code> of the columns uses the item name, and the <code>body</code> is calculated by looking for a grade of the student for the evaluation item. The body uses the <code>?.</code> safe null navigation operator in case the student does not have a grade for certain item.</p>"},{"location":"doc/pinset/#typeless-dataset-rules","title":"Typeless dataset rules","text":"<p>The <code>from</code> expression presented above to filter rows during the generation can be also used to define datasets where the row elements are not instances coming from an input model. This can be useful to perform data aggregations, or to generate synthetic tables starting from a custom collection of values.</p> <p>The following dataset rule generates a basic table using a sequence of numbers as row elements and different column generators:</p> <pre><code>dataset numbers over n from : 1.to(5) {\n    column number : n\n    column squared : n * n\n\n    grid {\n        keys: 2.to(5)\n        header: \"times_\" + key\n        body: n * key\n    }\n}</code></pre> number squared times_2 times_3 times_4 times_5 1 1 2 3 4 5 2 4 4 6 8 10 3 9 6 9 12 15 4 16 8 12 16 20 5 25 10 15 20 25"},{"location":"doc/pinset/#nested-column-generators","title":"Nested column generators","text":"<p>When certain intermediate value has to be used in several column calculations, Pinset offers a nested, composite column generator. This generator is defined by a <code>from</code> expression that calculates a value, followed by a block containing column generators that can use that value:</p> <pre><code>dataset gradesDetails over g : Grade {\n    properties[points]\n    reference item[name]\n    from student : g.eContainer {\n        column id : student.ID\n        column final_grade : student.getFinalGrade()\n        column grade_lowerthan_final : g.points &lt; final_grade\n    }\n}</code></pre> <p>The rule above generates a dataset with one row per grade in the course. The rule includes a <code>from</code> expression, which obtains the student that obtained the grade through the containment reference. Then, it is used to obtain the student id and final grade, and an extra column that determines whether a grade contributed negatively to the final grade of the student, by checking if it has less points than the final grade.</p> <p>The names of the nested column generators are prefixed with the name given to the object calculated by the <code>from</code> expression:</p> points item_name student_id student_final_grade student_grade_lowerthan_final 60 Lab 1 S1 81 true 90 Lab 2 S1 81 false 80 Partial Test S1 81 true 85 Final Exam S1 81 false 60 Lab 1 S2 59 false 100 Final Exam S2 59 false 50 Lab 1 S3 16 false 35 Lab 2 S3 16 false 20 Partial Test S3 16 false 100 Lab 1 S4 90 false 90 Lab 2 S4 90 false 70 Partial Test S4 90 true 95 Final Exam S4 90 false"},{"location":"doc/pinset/#column-post-processing","title":"Column post-processing","text":"<p>Pinset offers some column post-processing operations that are frequently used to prepare a dataset for an analysis. These operations are invoked by annotating the column generators.</p> <pre><code>dataset studentGradesPostProcessed over s : Student {\n    properties[ID]\n\n    @fillNulls 0\n    grid {\n        keys: EvaluationItem.all\n        header: key.name\n        body: s.grades.selectOne(g | g.item == key)?.points\n    }\n\n    column final_grade : s.getFinalGrade()\n    @normalize 100\n    column final_grade_normalized : final_grade\n}</code></pre> ID Lab_1 Lab_2 Partial_Test Final_Exam final_grade final_grade_normalized S1 60 90 80 85 81 0.81 S2 60 0 0 100 59 0.59 S3 50 35 20 0 16 0.16 S4 100 90 70 95 90 0.9"},{"location":"doc/pinset/#fill-nulls","title":"Fill nulls","text":"<p>It is possible to <code>@fillNulls</code> with a custom value, or with a special and sometimes used value, such as the <code>mean</code> or the <code>mode</code> of the column values. The following dataset rule</p> <p>By annotating the grid in the detailed grades example, we can fill with zeros those cells where a student did not took an evaluation item.</p>"},{"location":"doc/pinset/#normalisation","title":"Normalisation","text":"<p>We can <code>@normalize</code> data columns between the [0,1] interval (useful when applying distance-based algorithms with numeric columns in different scales). A value can be provided to the annotation to perform the normalisation. If no value is given, the maximum value encountered in the column is used instead.</p> <p>The dataset rule above contains a column with the normalised final grade of the course.</p>"},{"location":"doc/pinset/#picto-integration","title":"Picto Integration","text":"<p>Check out this article to learn how Pinset can be used to generate Picto table visualisations.</p>"},{"location":"download/","title":"Download","text":"<p>The simplest way to get a copy of Eclipse with Epsilon 2.5 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon.</p> <p></p> OS Architecture Eclipse Installer Windows x86_64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-jre-win64.exe Mac x86_64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-jre-mac64.dmg Mac AArch64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-jre-mac-aarch64.dmg Linux x86_64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-jre-linux64.tar.gz Linux AArch64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-jre-linux-aarch64.tar.gz <p>Can't find Epsilon?</p> <p>If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted.</p> <p>Warning</p> <p>Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product.</p>"},{"location":"download/#update-sites","title":"Update Sites","text":"<p>Alternatively, you can use the following update sites through the <code>Help</code> \u2192 <code>Install new software</code> menu in Eclipse to install (parts of) Epsilon.</p> Site Location Stable <code>http://download.eclipse.org/epsilon/updates/2.5/</code> Interim <code>http://download.eclipse.org/epsilon/interim/</code> <p>Eclipse failing to find dependencies?</p> <p>While Epsilon update sites contain references to all 3rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: <code>Cannot complete the install because one or more required items could not be found</code>.</p> <p>When this happens, please untick the <code>Contact all update sites during install to find required software</code> option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum.</p> <p>How often is the interim update site rebuilt?</p> <p>The interim update site is rebuilt automatically with every push to the main branch of the Epsilon repo. Bugs fixed in the interim version (compared to the latest stable version) are listed here</p>"},{"location":"download/#archived-update-sites","title":"Archived Update Sites","text":"<p>Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls.</p> Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.5/epsilon-2.5-site.zip Interim https://www.eclipse.org/downloads/download.php?file=/epsilon/interim/epsilon-interim-site.zip"},{"location":"download/#eclipse-marketplace","title":"Eclipse Marketplace","text":"<p>If you prefer to install Epsilon through the Eclipse Marketplace, you can drag and drop  into a running instance of Eclipse.</p>"},{"location":"download/#source-code","title":"Source Code","text":"<p>The source code of Epsilon is in the following Git repository.</p> Type Location Repository <code>https://github.com/eclipse/epsilon</code> Release tag <code>https://github.com/eclipse/epsilon/releases/tag/2.5</code> <p>Additional projects which are experimental or have dependencies which are incompatible with the Eclipse Public License are available in Epsilon Labs.</p>"},{"location":"download/#maven","title":"Maven","text":"<p>Epsilon JARs are available from Maven Central. For instance, to use the <code>EOL engine</code> JAR from your <code>pom.xml</code>:</p> <pre><code>&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.eol.engine&lt;/artifactId&gt;\n&lt;version&gt;2.5.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>To use the latest SNAPSHOT (interim) version of Epsilon, you should add the Sonatype snapshots repository to your <code>pom.xml</code> and set the version of the Epsilon libraries to <code>2.6.0-SNAPSHOT</code> as shown below.</p> <pre><code>&lt;repositories&gt;\n&lt;repository&gt;\n&lt;id&gt;ossrh&lt;/id&gt;\n&lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;\n&lt;/repository&gt;\n&lt;/repositories&gt;\n\n&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.eol.engine&lt;/artifactId&gt;\n&lt;version&gt;2.6.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"download/#older-versions","title":"Older versions","text":"<p>Previous stable versions of Epsilon are available here.</p>"},{"location":"download/#this-website","title":"This website","text":"<p>This article demonstrates how to download and manage the Epsilon website in your machine.</p>"},{"location":"download/1.x/","title":"Epsilon 1.x","text":""},{"location":"download/1.x/#distributions","title":"Distributions","text":"<p>Ready-to-use Eclipse distributions containing a stable 1.x version of Epsilon and all its mandatory and optional  dependencies. You will only need a Java Runtime Environment. </p> Version Location 1.5 https://archive.eclipse.org/epsilon/1.5/distributions/ (Once you have downloaded the 1.5 distribution, please update Epsilon from the update site below to version 1.5.1, which contains a fix for a regression that affects the properties view of Exeed.) 1.4 https://archive.eclipse.org/epsilon/1.4/distributions/ 1.3 https://archive.eclipse.org/epsilon/1.3/distributions/ 1.2 https://archive.eclipse.org/epsilon/1.2/distributions/ 1.1_SR1 https://archive.eclipse.org/epsilon/1.1_SR1/distributions/ 1.1 https://archive.eclipse.org/epsilon/1.1/distributions/ 1.0 https://archive.eclipse.org/epsilon/1.0/distributions/"},{"location":"download/1.x/#prerequisites","title":"Prerequisites","text":"<p>The development tools of Epsilon come as a set of Eclipse plugins and therefore, unless you download one of the ready-made distributions above, to install Epsilon you need to download and install a  Java Runtime Environment and Eclipse first. The Eclipse Modeling Tools distribution contains most of the necessary prerequisites for Epsilon 1.x. See this page to find out which modeling tools distribution matches the version of Epsilon you wish to install.</p>"},{"location":"download/1.x/#update-site","title":"Update Site","text":"<p>You can use the following update sites through the <code>Help</code> \u2192 <code>Install new software</code> menu in Eclipse to install (parts of) Epsilon. Please untick the <code>Show only the latest versions of available software</code> check box, as shown below, to reveal older versions of Epsilon.</p> Site Location Stable <code>http://download.eclipse.org/epsilon/updates/</code> <p></p>"},{"location":"download/1.x/#dependencies","title":"Dependencies","text":"Dependency Update Site Notes Emfatic <code>http://download.eclipse.org/emfatic/update/</code> None. GMF Tooling <code>http://download.eclipse.org/modeling/gmp/gmf-tooling/updates/releases/</code> Install Graphical Modelling Framework (GMF) Tooling SDK. Required for Eugenia. QVTo <code>http://download.eclipse.org/mmt/qvto/updates/releases/latest/</code> Versions of QVTo &gt;= 3.9.1 should all work with with GMF Tooling"},{"location":"download/1.x/#archived-update-sites","title":"Archived Update Sites","text":"<p>Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls.</p> Site Zip Archive 1.5 https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/1.5/epsilon-1.5-site.zip 1.4 https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/1.4/epsilon-1.4-site.zip 1.3 https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/1.3/epsilon-1.3-site.zip 1.2 https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/1.2/epsilon-1.2-site.zip"},{"location":"download/1.x/#source-code","title":"Source Code","text":"<p>The source code of 1.x versions of Epsilon can be obtained by checking out the respective tag listed under https://github.com/eclipse/epsilon/tags (e.g. <code>https://github.com/eclipse/epsilon/releases/tag/1.4</code> for 1.4)</p>"},{"location":"download/1.x/#maven","title":"Maven","text":"<p>Older versions of Epsilon JARs are available from Maven Central. Note that prior to 2.0, the structure was different (less modular). For instance, to use the <code>epsilon-core</code> JAR from your <code>pom.xml</code>:</p> <pre><code>&lt;dependencies&gt;\n...\n  &lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;epsilon-core&lt;/artifactId&gt;\n&lt;version&gt;1.5.1&lt;/version&gt;\n&lt;/dependency&gt;\n...\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"download/2.1/","title":"Epsilon 2.1","text":"<p>The simplest way to get a copy of Eclipse with Epsilon 2.1 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon. Note that you will need a Java Runtime Environment installed on your system.</p> <p></p> OS Eclipse Installer Windows http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-win64.exe Mac http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac64.dmg Linux http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux64.tar.gz <p>Can't find Epsilon?</p> <p>If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted.</p> <p>Warning</p> <p>Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product.</p>"},{"location":"download/2.1/#update-sites","title":"Update Sites","text":"<p>Alternatively, you can use the following update site through the <code>Help</code> \u2192 <code>Install new software</code> menu in Eclipse to install (parts of) Epsilon.</p> Site Location Stable <code>http://download.eclipse.org/epsilon/updates/2.1/</code> <p>Eclipse failing to find dependencies?</p> <p>While Epsilon update sites contain references to all 3rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: <code>Cannot complete the install because one or more required items could not be found</code>.</p> <p>When this happens, please untick the <code>Contact all update sites during install to find required software</code> option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum.</p>"},{"location":"download/2.1/#archived-update-sites","title":"Archived Update Sites","text":"<p>Below is also a link to a compressed version of the Epsilon 2.1 update site for long-term archival and to support users who are behind corporate firewalls.</p> Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.1/epsilon-2.1-site.zip"},{"location":"download/2.1/#source-code","title":"Source Code","text":"<p>The source code of Epsilon 2.1 is in the following Git repository.</p> Type Location Repository <code>https://github.com/eclipse/epsilon</code> Release tag <code>https://github.com/eclipse/epsilon/releases/tag/2.1</code>"},{"location":"download/2.1/#maven","title":"Maven","text":"<p>Epsilon JARs are available from Maven Central. For instance, to use the <code>EOL engine</code> JAR from your <code>pom.xml</code>:</p> <pre><code>&lt;dependencies&gt;\n...\n    &lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.eol.engine&lt;/artifactId&gt;\n&lt;version&gt;2.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n...\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"download/2.2/","title":"Download","text":"<p>The simplest way to get a copy of Eclipse with Epsilon 2.2 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon. Note that you will need a Java Runtime Environment installed on your system.</p> <p></p> OS Eclipse Installer Windows http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-win64.exe Mac http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac64.dmg Linux http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux64.tar.gz <p>Can't find Epsilon?</p> <p>If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted.</p> <p>Warning</p> <p>Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product.</p>"},{"location":"download/2.2/#update-sites","title":"Update Sites","text":"<p>Alternatively, you can use the following update sites through the <code>Help</code> \u2192 <code>Install new software</code> menu in Eclipse to install (parts of) Epsilon.</p> Site Location Stable <code>http://download.eclipse.org/epsilon/updates/2.2/</code> Interim <code>http://download.eclipse.org/epsilon/interim/</code> <p>Eclipse failing to find dependencies?</p> <p>While Epsilon update sites contain references to all 3rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: <code>Cannot complete the install because one or more required items could not be found</code>.</p> <p>When this happens, please untick the <code>Contact all update sites during install to find required software</code> option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum.</p> <p>How often is the interim update site rebuilt?</p> <p>The interim update site is rebuilt automatically with every push to the main branch of the Epsilon repo. Bugs fixed in the interim version (compared to the latest stable version) are listed here</p>"},{"location":"download/2.2/#archived-update-sites","title":"Archived Update Sites","text":"<p>Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls.</p> Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.2/epsilon-2.2-site.zip Interim https://www.eclipse.org/downloads/download.php?file=/epsilon/interim/epsilon-interim-site.zip"},{"location":"download/2.2/#eclipse-marketplace","title":"Eclipse Marketplace","text":"<p>If you prefer to install Epsilon through the Eclipse Marketplace, you can drag and drop  into a running instance of Eclipse.</p>"},{"location":"download/2.2/#source-code","title":"Source Code","text":"<p>The source code of Epsilon is in the following Git repository.</p> Type Location Repository <code>https://github.com/eclipse/epsilon</code> Release tag <code>https://github.com/eclipse/epsilon/releases/tag/2.2</code> <p>Additional projects which are experimental or have dependencies which are incompatible with the Eclipse Public License are available in Epsilon Labs.</p>"},{"location":"download/2.2/#maven","title":"Maven","text":"<p>Epsilon JARs are available from Maven Central. For instance, to use the <code>EOL engine</code> JAR from your <code>pom.xml</code>:</p> <pre><code>&lt;dependencies&gt;\n...\n    &lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.eol.engine&lt;/artifactId&gt;\n&lt;version&gt;2.2.0&lt;/version&gt;\n&lt;/dependency&gt;\n...\n&lt;/dependencies&gt;\n</code></pre> <p>To use the latest SNAPSHOT (interim) version of Epsilon, please see the standalone example POM.</p>"},{"location":"download/2.2/#older-versions","title":"Older versions","text":"<p>Previous stable versions of Epsilon are available here.</p>"},{"location":"download/2.2/#this-website","title":"This website","text":"<p>This article demonstrates how to download and manage the Epsilon website in your machine.</p>"},{"location":"download/2.3/","title":"Download","text":"<p>Regression in recent versions of Eclipse</p> <p>The Epsilon language editors in version 2.3 throw a null pointer exception upon initialisation when installed on versions of Eclipse after 2021-12. This has been fixed in version 2.4 of Epsilon.</p> <p>The simplest way to get a copy of Eclipse with Epsilon 2.3 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon. Note that you will need a Java Runtime Environment installed on your system.</p> <p></p> OS Eclipse Installer Windows http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-win64.exe Mac http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac64.dmg Linux http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux64.tar.gz <p>Can't find Epsilon?</p> <p>If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted.</p> <p>Warning</p> <p>Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product.</p>"},{"location":"download/2.3/#update-sites","title":"Update Sites","text":"<p>Alternatively, you can use the following update sites through the <code>Help</code> \u2192 <code>Install new software</code> menu in Eclipse to install (parts of) Epsilon.</p> Site Location Stable <code>http://download.eclipse.org/epsilon/updates/2.3/</code> Interim <code>http://download.eclipse.org/epsilon/interim/</code> <p>Eclipse failing to find dependencies?</p> <p>While Epsilon update sites contain references to all 3rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: <code>Cannot complete the install because one or more required items could not be found</code>.</p> <p>When this happens, please untick the <code>Contact all update sites during install to find required software</code> option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum.</p> <p>How often is the interim update site rebuilt?</p> <p>The interim update site is rebuilt automatically with every push to the main branch of the Epsilon repo. Bugs fixed in the interim version (compared to the latest stable version) are listed here</p>"},{"location":"download/2.3/#archived-update-sites","title":"Archived Update Sites","text":"<p>Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls.</p> Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.3/epsilon-2.3-site.zip Interim https://www.eclipse.org/downloads/download.php?file=/epsilon/interim/epsilon-interim-site.zip"},{"location":"download/2.3/#eclipse-marketplace","title":"Eclipse Marketplace","text":"<p>If you prefer to install Epsilon through the Eclipse Marketplace, you can drag and drop  into a running instance of Eclipse.</p>"},{"location":"download/2.3/#source-code","title":"Source Code","text":"<p>The source code of Epsilon is in the following Git repository.</p> Type Location Repository <code>https://github.com/eclipse/epsilon</code> Release tag <code>https://github.com/eclipse/epsilon/releases/tag/2.3</code> <p>Additional projects which are experimental or have dependencies which are incompatible with the Eclipse Public License are available in Epsilon Labs.</p>"},{"location":"download/2.3/#maven","title":"Maven","text":"<p>Epsilon JARs are available from Maven Central. For instance, to use the <code>EOL engine</code> JAR from your <code>pom.xml</code>:</p> <pre><code>&lt;dependencies&gt;\n...\n    &lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.eol.engine&lt;/artifactId&gt;\n&lt;version&gt;2.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n...\n&lt;/dependencies&gt;\n</code></pre> <p>To use the latest SNAPSHOT (interim) version of Epsilon, please see the standalone example POM.</p>"},{"location":"download/2.3/#older-versions","title":"Older versions","text":"<p>Previous stable versions of Epsilon are available here.</p>"},{"location":"download/2.3/#this-website","title":"This website","text":"<p>This article demonstrates how to download and manage the Epsilon website in your machine.</p>"},{"location":"download/2.4/","title":"Download","text":"<p>The simplest way to get a copy of Eclipse with Epsilon 2.4 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon. Note that you will need a Java Runtime Environment installed on your system.</p> <p></p> OS Architecture Eclipse Installer Windows x86_64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-jre-win64.exe Mac x86_64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-jre-mac64.dmg Mac AArch64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-jre-mac-aarch64.dmg Linux x86_64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-jre-linux64.tar.gz Linux AArch64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-jre-linux-aarch64.tar.gz <p>Can't find Epsilon?</p> <p>If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted.</p> <p>Warning</p> <p>Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product.</p>"},{"location":"download/2.4/#update-sites","title":"Update Sites","text":"<p>Alternatively, you can use the following update sites through the <code>Help</code> \u2192 <code>Install new software</code> menu in Eclipse to install (parts of) Epsilon.</p> <p>Warning</p> <p>Please note that updates in recent (2022) versions of Eclipse have broken Eugenia. If you need to install Eugenia, please use an older version of Eclipse.</p> Site Location Stable <code>http://download.eclipse.org/epsilon/updates/2.4/</code> Interim <code>http://download.eclipse.org/epsilon/interim/</code> <p>Eclipse failing to find dependencies?</p> <p>While Epsilon update sites contain references to all 3rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: <code>Cannot complete the install because one or more required items could not be found</code>.</p> <p>When this happens, please untick the <code>Contact all update sites during install to find required software</code> option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum.</p> <p>How often is the interim update site rebuilt?</p> <p>The interim update site is rebuilt automatically with every push to the main branch of the Epsilon repo. Bugs fixed in the interim version (compared to the latest stable version) are listed here</p>"},{"location":"download/2.4/#archived-update-sites","title":"Archived Update Sites","text":"<p>Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls.</p> Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.4/epsilon-2.4-site.zip Interim https://www.eclipse.org/downloads/download.php?file=/epsilon/interim/epsilon-interim-site.zip"},{"location":"download/2.4/#eclipse-marketplace","title":"Eclipse Marketplace","text":"<p>If you prefer to install Epsilon through the Eclipse Marketplace, you can drag and drop  into a running instance of Eclipse.</p>"},{"location":"download/2.4/#source-code","title":"Source Code","text":"<p>The source code of Epsilon is in the following Git repository.</p> Type Location Repository <code>https://github.com/eclipse/epsilon</code> Release tag <code>https://github.com/eclipse/epsilon/releases/tag/2.4</code> <p>Additional projects which are experimental or have dependencies which are incompatible with the Eclipse Public License are available in Epsilon Labs.</p>"},{"location":"download/2.4/#maven","title":"Maven","text":"<p>Epsilon JARs are available from Maven Central. For instance, to use the <code>EOL engine</code> JAR from your <code>pom.xml</code>:</p> <pre><code>&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.eol.engine&lt;/artifactId&gt;\n&lt;version&gt;2.4.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>To use the latest SNAPSHOT (interim) version of Epsilon, you should add the Sonatype snapshots repository to your <code>pom.xml</code> and set the version of the Epsilon libraries to <code>2.5.0-SNAPSHOT</code> as shown below.</p> <pre><code>&lt;repositories&gt;\n&lt;repository&gt;\n&lt;id&gt;ossrh&lt;/id&gt;\n&lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;\n&lt;/repository&gt;\n&lt;/repositories&gt;\n\n&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.epsilon&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.epsilon.eol.engine&lt;/artifactId&gt;\n&lt;version&gt;2.5.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"download/2.4/#older-versions","title":"Older versions","text":"<p>Previous stable versions of Epsilon are available here.</p>"},{"location":"download/2.4/#this-website","title":"This website","text":"<p>This article demonstrates how to download and manage the Epsilon website in your machine.</p>"},{"location":"download/all-versions/","title":"All Versions of Epsilon","text":"Version Eclipse Release Release Date Release Type 2.5 4.30 (2023-12) 15 April 2024 Scheduled release 2.4 4.22 (2021-12) 6 March 2022 Scheduled release 2.3 4.19 (2021-03) 24 April 2021 Scheduled release 2.2 4.16 (2020-06) 4 September 2020 Scheduled release 2.1 4.16 (2020-06) 3 July 2020 Scheduled release 2.0 4.15 (2020-03) 30 May 2020 Major release (2.0 contained two significant regressions and was replaced by 2.1) 1.5.1 4.8 (Photon) 30 Sep 2018 Service release 1.5 4.8 (Photon) 12 Aug 2018 Scheduled release 1.4 4.6 (Neon) 6 Nov 2016 Scheduled release 1.3 4.5 (Mars) 8 Mar 2015 Scheduled release 1.2 4.4 (Luna) 25 Aug 2014 Scheduled release 1.1_SR1 4.3 (Kepler) 10 Sept 2013 Service release 1.1 4.3 (Kepler) 29 Aug 2013 Scheduled release 1.0 4.2 (Juno) 12 Nov 2012 Scheduled release"},{"location":"playground/readme/","title":"Quick Start","text":"<p>To run the playground locally, check that you have Maven and Node 18 installed and then:</p> <ul> <li>In this directory (<code>playground</code>), run <code>npx webpack --watch --mode=development</code></li> <li>In the <code>java</code> directory, run <code>mvn package</code></li> <li>In the parent directory (<code>docs</code>), run <code>npx http-server</code></li> <li>Open your browser in <code>http://localhost:8080/playground</code></li> </ul>"},{"location":"playground/readme/#webpack","title":"Webpack","text":"<p>We use <code>webpack</code> for compiling dependencies and custom JavaScript into a single <code>bundle.js</code> file under <code>dist</code>, which is then used in <code>index.html</code>. To rebuild <code>bundle.js</code> you need to run the following commands:</p> <ul> <li><code>npx webpack --watch --mode=development</code> for a development build (faster build, larger <code>bundle.js</code>)</li> <li><code>npx webpack --mode=production</code> before you push to GitHub (slower build, smaller <code>bundle.js</code>)</li> </ul>"},{"location":"playground/readme/#testing","title":"Testing","text":"<p>We use Cypress for automated testing. Tests are stored under the <code>cypress/e2e</code> folder. To run a single test, you need to use the following command:</p> <ul> <li><code>npx cypress run --browser firefox --spec \"cypress/e2e/eol.cy.js\"</code></li> </ul> <p>To run all the end-to-end tests under <code>cypress/e2e</code>, you can use the following command:</p> <ul> <li><code>npx cypress run --browser firefox --spec \"cypress/e2e/*.cy.js\"</code></li> </ul> <p>Note: When the browser is not set to <code>firefox</code>, tests in <code>download.cy.js</code> can be flaky.</p>"},{"location":"playground/readme/#why-http-server","title":"Why http-server?","text":"<p>The CheerpJ library that we use for syntax checking doesn't work well with the primitive built-in web server of MkDocs as it requires advanced HTTP features. For syntax checking to work, run <code>npx http-server</code> from the <code>docs</code> directory instead.</p>"},{"location":"professional-services/","title":"Professional Services","text":"<p>The organisations below offer professional support services (e.g. training, bespoke development, expertise) for Epsilon.</p>"},{"location":"professional-services/#united-kingdom","title":"United Kingdom","text":"<ul> <li>Kinori Tech</li> <li>University of York</li> </ul>"},{"location":"professional-services/#hungary","title":"Hungary","text":"<ul> <li>BlackBelt</li> </ul> <p>If your organisation offers professional support services for Epsilon and you would like it to be listed here, please get in touch.</p>"},{"location":"users/","title":"Industry","text":"<p>Below is a list of known industrial users of Epsilon (based on bug reports, forum messages, blog posts, tweets and published articles). If you'd like to report additional uses of Epsilon in industry or you've spotted any outdated content, please let us know.</p> <p> </p>"},{"location":"users/#sources","title":"Sources","text":"<p>BAE Systems      [1], Bosch      [1], NASA      [1,     2,     3,     4],  THALES      [1,     2,     3], Siemens      [1,     2], Rolls-Royce      [1,     2,     3,     4,     5], Leonardo [1], IBM      [1,     2,     3,     4,     5], Oracle     [1], Blackbelt      [1,     2], Codebots     [1], Raytheon      [1,     2], Atos     [1], Ergon     [1], Talend     [1], Corpus     [1], develop group     [1], DevBoost     [1], Academa      [1,     2,     3,     4], Intelliment     [1], Maiborn Wolff     [1,     2]</p>"},{"location":"users/education/","title":"Education","text":"<p>Below is a list of institutions that use one or more components of Epsilon (e.g. EGL, Eugenia) as part of their modelling/MDE courses. If you'd like to report additional uses of Epsilon in taught courses or you've spotted any outdated content, please let us know.</p> <p> </p>"},{"location":"users/education/#sources","title":"Sources","text":"<p>University of York      [1], University of Texas      [1], University of Oslo      [1], Universidad Autonoma de Madrid      [1], McGill University     [1], University of Kassel      [1], University of Marburg      [1], Technische Universiteit Eindhoven      [1], Universitea Babes-Bolyai      [1], Universidad de los Andes      [1], Budapest University of Technology and Economics      [1], Technical University of Dresden      [1], University of Southern Denmark      [1], Norwegian University of Science and Technology      [1], University of Cadiz      [1], McMaster University      [1], University of Edinburgh      [1], Antwerp University      [1], King's College London     [1]</p>"},{"location":"users/open-source/","title":"Open Source Projects","text":"<p>Below is a list of open-source projects that are using languages and tools provided by Epsilon. If you'd like your project to appear here or you've spotted any outdated content, please let us know.</p> <ul> <li>NASA CertWare: The CertWare workbench contributes several core modules supporting safety case models, and extends these with a service-based APIs for plugging new capabilities into the workbench for processing these models.</li> <li>SAFECAP: Safecap is an Eclipse-based tool for entering and analysing railway junction schemas. The tool can be used for the analysis of control table for junction signals, assessment of capacity impact of signal positioning and train detection circuit boundaries, and also for conducting semi-automatic or automatic changes to schema topology or control tables.</li> <li>T4UME: Uncertainty Modeling and Evaluation (UME) is a  methodology that aims at detecting uncertainty caused by missing information on system models. UME aims at contributing to the Uncertainty Modeling (UM) standardization activity supported by the OMG focusing on models created with UML. Tool for UME (T4UME) is the companion supporting tool implemented on top of state of the art MDE technologies.</li> <li>EMF Rest: EMF-REST generates truly RESTful APIs for your EMF models. EMF-REST complements the existing (Java-based) API generation facilities EMF already provides and extends them to the Web.</li> <li>MTC Flow: MTC Flow s a tool which allows model-driven developers to design, develop, test and deploy Model Transformation Chains (MTCs). The tool offers a graphical DSL for defining MTC workflows independently of implementation technologies.</li> <li>Melanee: Melanee is a workbench for creating domain-specific languages which occupy an arbitrary number of ontological levels. It ships with a default general-purpose notation which is designed with the UML and Entity-Relationship diagrams in mind.</li> <li>JastEMF: JastEMF is a tool to support the integrated use of the JastAdd system - a rewriteable, circular, reference attribute grammar (ReCRAG) generator - and the Eclipse Modeling Framework (EMF) - a Java based metamodeling framework built around the Ecore metamodeling language.</li> <li>Tigerstripe: Tigerstripe is a framework for Model Driven Engineering (MDE) with special support for the Telecommunications Industry.</li> <li>HiLeS: The HiLeS2 Framework was developed to aid the Embedded System Designers during the design process. The HiLeS2 Framework purpose is to serve as a platform to create Embedded System Product Lines. It incorporates both tools developed by the group and open source tools to provide an Integrated Development Environment (IDE) suitable for system specification, product line construction and virtual prototype generation.</li> <li>EERCASE: The Enhanced Entity-Relationship (EER) Model is one of the most used modeling languages for the conceptual design of database. However, to the best of our knowledge, there are no metamodels and Computer-Aided Software Engineering (CASE) tool that provide support to code generation and schema validation from conceptual data model according to the EER classical notation (i.e., Chen/Elmasri and Navathe's notation -  cf. Fig below). Aiming to overcome the previous shortcoming, we have proposed a metamodel and a CASE tool named EER MetaModel (EERMM) and EERCASE, respectively.</li> <li>metaDepth: metaDepth is a framework for deep meta-modelling that provide supports for an arbitrary number of ontological meta-levels. This makes MetaDepth especially useful to define multi-level languages.</li> <li>bflow* Toolbox: The bflow Toolbox is an open source tool kit for business process management. The objective of bflow is to explore new ways and scenarios for the development and use of modelling tools.</li> <li>Pongo MongoDB Generator: Pongo is a template-based Java POJO generator for MongoDB. Instead of using low-level DBObjects to interact with your MongoDB database, with Pongo you can define your data/domain model using Emfatic and then generate strongly-typed Java classes you can then use to work with your database at a more convenient level of abstraction.</li> <li>TENTE C#: TENTE is a contribution for SPL architectural design and implementation. This process integrates relevant advances, from an SPL point of view, for separation of concerns and MDD technologies. This project contains the TENTE code generators for the C# approach.</li> <li>Brics: The prime objective of BRICS is to structure and formalize the robot development process itself and to provide tools, models, and functional libraries, which help accelerating this process significantly.</li> <li>MIDE: MIDE is an IDE for working with UML Class Diagrams. It extends the Eclipse UML2 Editor and enables carrying out complex tasks in one click, and provides a pattern-matching engine for detecting design errors as soon as they are made</li> <li>Event-B: Event-B is a formal method for system-level modelling and analysis. Key features of Event-B are the use of set theory as a modelling notation, the use of refinement to represent systems at different abstraction levels and the use of mathematical proof to verify consistency between refinement levels.</li> <li>PhpNoDB: While having a database is essential for any large-scale website, it can be an overkill for smaller projects/prototypes where read-only access to a small dataset would be sufficient. To save you the trouble of setting up and managing a database if you don't really need one, phpnodb lets you capture your data in a Google Spreadsheet and then generate from it a standalone PHP class that contains an embedded copy of your data.</li> <li>Collaborative Modeling Framework: This modeling framework uses the MetaDepth framework to model and generate collaborative Android applications. The framework includes - among others - chat, Dropbox, Foursquare and geo components.</li> <li>Product Line Documentation Toolkit for Eclipse: The aim of the project is to create an Eclipse plugin to support text and visual editing and validating of DRL documents. DRL stands for 'Document Reuse Language' - a special document markup language incorporating docbook features, designed for creating documentation for a series of highly-interrelated software products, otherwise known as 'Product Line'.</li> <li>Context Manager Framework: Context Manager Framework is a ongoing work at Department of Engineering and Computer Science and Mathematics at University of L'Aquila. It includes model-based methodologies and tools to support the non-functional (a.k.a. extra-functional)aspects of context-aware software systems.</li> <li>UNC Chapel Hill Libraries: University of North Carolina at Chapel Hill Libraries open-source project. Library metadata models and mapping tools implemented in Eclipse Modelling Framework (EMF).</li> <li>MetaGem: MeTAGeM is a Meta-Tool for the Automatic Generation of Model Transformations that makes possible to put into practice the MDE (Model-Driven Engineering) principles for developing model transformations, defining model transformations as models, without considering details of the code implementation.</li> <li>AcEdit: Editor for Assurance Cases, Implementing the Goal Structuring Notation (GSN) and the OMG Argumentation Metamodel (ARM). The editor implements the GSN standard as specified at www.goalstructuringnotation.info and the ARM standard available from sysa.omg.org</li> <li>Ecore 2 Doctrine: Ecore 2 Doctrine Model-to-model transformer</li> <li>Unicaneer2Sql: An Eclipse plugin for model-driven development of databases. The application provides facilities to create graphical ER models and generates code for SLQ Sever and Oracle.</li> <li>Reflo: This project aims to provide a machine-assisted environment for developers model programs, using a dataflow notation. It also provides a rewriting system for dataflow graphs.</li> <li>Prediqt Editors: Two versions of a editor for the PREDIQT method, one created using GMF, the other created using Graphiti.</li> <li>Kybele GMF Gen: Kybele GMF Generator (also known as KybeleGMFgen) is a new Model-Driven Software Development (MDSD) tool for Eclipse Modeling Tools for creating, in only a few steps, graphical editors from manually annotated metamodels and customization files.</li> <li>MODEmbed: MODembed is an experimental IDE aiming to provide a more advanced toolchain for embedded software development. It provides a model-based approach for defining the whole compilation process. The project aims to create a full-featured IDE which can support every aspect of an embedded system design using a model-based approach.</li> <li>rFSM Modeling: The purpose of this project is to create a meta-model for the representation of rFSM programs. This project contains a meta-model of rFSM, a grammar which is only defined for testing purposes, a complete programming environment based on that Xtext grammar, and a Lua code generation based on the model of an rFSM program.</li> <li>HyperFlex: HyperFlex is a collection of Eclipse plugins that support the development of robotics software product lines, a family of similar applications that are built reusing a set of software components and share the same architecture. HyperFlex provides a set of tools for designing variability models and architectural models for the most spread Robotics Software Frameworks (ROS, Orocos and the cloud-based Rapyuta).</li> <li>FraMED: FRaMED is the First Role Modeling EDitor allowing the graphical specification of Role-based Software Systems by means of compartments (aka. contexts), objects, roles, and relationships. Additionally, it supports a varity of constraints upon roles and relationships.</li> <li>Tura: Tura provides support for model-driven development of JEE/JSF web applications. Tura provides a dedicated domain-specific language for modelling web applications, supporting editors and generators built using the EMF, GMF and Epsilon frameworks, and supports the full development lifecycle including code generation, testing, compilation, building, and deployment.</li> <li>MMINT: Model Management INTeractive (MMINT) is an Eclipse-based workbench for graphical, interactive model management. MMINT allows modelers to do rapid prototyping and exploratory modeling while seamlessly keeping track of all relevant artifacts in their workspace. MMINT is developed by the Software Engineering group at the University of Toronto, under the supervision of Professor Marsha Chechik.</li> <li>MDebugger: MDebugger is a platform-independent model-level debugger for UML-RT models. It provides live debugging features (e.g., breakpoints) to debug generated systems from UML-RT models without using any program debugger or referring to the generated source code. To make it platform-independent, it uses model transformation (i.e. the Epsilon Object Language) to add support for debugging capabilities to the models.</li> </ul>"}]}